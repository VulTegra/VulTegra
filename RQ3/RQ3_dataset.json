[{"project": "NVD", "target": 1, "code": "int Transaction::processURI(const char *uri, const char *method,\n    const char *http_version) {\n\n    ms_dbg(4, \"Starting phase URI. (SecRules 0 + 1/2)\");\n\n    m_httpVersion = http_version;\n    m_uri = uri;\n    std::string uri_s(uri);\n\n    // any uri-fragment that was received should only be retained in\n    // - m_uri\n    // - m_variableRequestURIRaw\n    // - m_variableRequestLine\n    size_t pos_raw_fragment = uri_s.find(\"#\");\n    if (pos_raw_fragment != std::string::npos) {\n        uri_s = uri_s.substr(0, pos_raw_fragment);\n    }\n\n    size_t pos_raw_query = uri_s.find(\"?\");\n\n    m_uri_decoded = utils::uri_decode(uri_s);\n\n    size_t var_size = pos_raw_query;\n\n    m_variableRequestMethod.set(method, 0);\n\n\n    std::string requestLine(std::string(method) + \" \" + std::string(uri));\n    m_variableRequestLine.set(requestLine \\\n        + \" HTTP/\" + std::string(http_version), m_variableOffset);\n\n    m_variableRequestProtocol.set(\"HTTP/\" + std::string(http_version),\n        m_variableOffset + requestLine.size() + 1);\n\n    size_t pos_query = m_uri_decoded.find(\"?\");\n    if (pos_query != std::string::npos) {\n        m_uri_no_query_string_decoded = std::unique_ptr<std::string>(\n            new std::string(m_uri_decoded, 0, pos_query));\n    } else {\n        m_uri_no_query_string_decoded = std::unique_ptr<std::string>(\n            new std::string(m_uri_decoded));\n    }\n\n    if (pos_raw_query != std::string::npos) {\n        std::string qry = std::string(uri_s, pos_raw_query + 1,\n            uri_s.length() - (pos_raw_query + 1));\n        m_variableQueryString.set(qry, pos_raw_query + 1\n            + std::string(method).size() + 1);\n    }\n\n    std::string path_info;\n    if (pos_query == std::string::npos) {\n        path_info = std::string(m_uri_decoded, 0);\n    } else {\n        path_info = std::string(m_uri_decoded, 0, pos_query);\n    }\n    if (var_size == std::string::npos) {\n        var_size = uri_s.size();\n    }\n\n    m_variablePathInfo.set(path_info, m_variableOffset + strlen(method) +\n        1, var_size);\n    m_variableRequestFilename.set(path_info,  m_variableOffset +\n        strlen(method) + 1, var_size);\n\n\n    size_t offset = path_info.find_last_of(\"/\\\\\");\n    if (offset != std::string::npos && path_info.length() > offset + 1) {\n        std::string basename = std::string(path_info, offset + 1,\n            path_info.length() - (offset + 1));\n        m_variableRequestBasename.set(basename, m_variableOffset +\n            strlen(method) + 1 + offset + 1);\n    }\n\n    m_variableOffset = m_variableRequestLine.m_value.size();\n\n    std::string parsedURI = m_uri_decoded;\n    // The more popular case is without domain\n    if (!m_uri_decoded.empty() && m_uri_decoded.at(0) != '/') {\n        bool fullDomain = true;\n        size_t scheme = m_uri_decoded.find(\":\")+1;\n        if (scheme == std::string::npos) {\n            fullDomain = false;\n        }\n        // Searching with a pos of -1 is undefined we also shortcut\n        if (scheme != std::string::npos && fullDomain == true) {\n            // Assuming we found a colon make sure its followed\n            size_t netloc = m_uri_decoded.find(\"//\", scheme) + 2;\n            if (netloc == std::string::npos || (netloc != scheme + 2)) {\n                fullDomain = false;\n            }\n            if (netloc != std::string::npos && fullDomain == true) {\n                size_t path = m_uri_decoded.find(\"/\", netloc);\n                if (path != std::string::npos) {\n                    parsedURI = m_uri_decoded.substr(path);\n                }\n            }\n        }\n    }\n\n    m_variableRequestURI.set(parsedURI, std::string(method).size() + 1,\n        uri_s.size());\n    m_variableRequestURIRaw.set(uri, std::string(method).size() + 1);\n\n    if (m_variableQueryString.m_value.empty() == false) {\n        extractArguments(\"GET\", m_variableQueryString.m_value,\n            m_variableQueryString.m_offset);\n    }\n\n    m_variableOffset = m_variableOffset + 1;\n    return true;\n}"}, {"project": "NVD", "target": 1, "code": "#include \"config.h\"\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/cpu.h\"\n#include \"libavutil/mem_internal.h\"\n#include \"libavutil/ppc/cpu.h\"\n#include \"libavutil/ppc/util_altivec.h\"\n\n#include \"libavcodec/vp8dsp.h\"\n\n#include \"hpeldsp_altivec.h\"\n\n#if HAVE_ALTIVEC\n#define REPT4(...) { __VA_ARGS__, __VA_ARGS__, __VA_ARGS__, __VA_ARGS__ }\n\n// h subpel filter uses msum to multiply+add 4 pixel taps at once\nstatic const vec_s8 h_subpel_filters_inner[7] =\n{\n    REPT4( -6, 123,  12,  -1),\n    REPT4(-11, 108,  36,  -8),\n    REPT4( -9,  93,  50,  -6),\n    REPT4(-16,  77,  77, -16),\n    REPT4( -6,  50,  93,  -9),\n    REPT4( -8,  36, 108, -11),\n    REPT4( -1,  12, 123,  -6),\n};\n\n// for 6tap filters, these are the outer two taps\n// The zeros mask off pixels 4-7 when filtering 0-3\n// and vice-versa\nstatic const vec_s8 h_subpel_filters_outer[3] =\n{\n    REPT4(0, 0, 2, 1),\n    REPT4(0, 0, 3, 3),\n    REPT4(0, 0, 1, 2),\n};\n\n#define LOAD_H_SUBPEL_FILTER(i) \\\n    vec_s8 filter_inner  = h_subpel_filters_inner[i]; \\\n    vec_s8 filter_outerh = h_subpel_filters_outer[(i)>>1]; \\\n    vec_s8 filter_outerl = vec_sld(filter_outerh, filter_outerh, 2)\n\n#if HAVE_BIGENDIAN\n#define GET_PIXHL(offset)                   \\\n    a = vec_ld((offset)-is6tap-1, src);     \\\n    b = vec_ld((offset)-is6tap-1+15, src);  \\\n    pixh  = vec_perm(a, b, permh##offset);  \\\n    pixl  = vec_perm(a, b, perml##offset)\n\n#define GET_OUTER(offset) outer = vec_perm(a, b, perm_6tap##offset)\n#else\n#define GET_PIXHL(offset)                   \\\n    a = vec_vsx_ld((offset)-is6tap-1, src); \\\n    pixh  = vec_perm(a, a, perm_inner);     \\\n    pixl  = vec_perm(a, a, vec_add(perm_inner, vec_splat_u8(4)))\n\n#define GET_OUTER(offset) outer = vec_perm(a, a, perm_outer)\n#endif\n\n#define FILTER_H(dstv, off) \\\n    GET_PIXHL(off);                            \\\n    filth = vec_msum(filter_inner, pixh, c64); \\\n    filtl = vec_msum(filter_inner, pixl, c64); \\\n\\\n    if (is6tap) { \\\n        GET_OUTER(off);                                \\\n        filth = vec_msum(filter_outerh, outer, filth); \\\n        filtl = vec_msum(filter_outerl, outer, filtl); \\\n    } \\\n    if (w == 4) \\\n        filtl = filth; /* discard pixels 4-7 */ \\\n    dstv = vec_packs(filth, filtl); \\\n    dstv = vec_sra(dstv, c7)\n\nstatic av_always_inline\nvoid put_vp8_epel_h_altivec_core(uint8_t *dst, ptrdiff_t dst_stride,\n                                 const uint8_t *src, ptrdiff_t src_stride,\n                                 int h, int mx, int w, int is6tap)\n{\n    LOAD_H_SUBPEL_FILTER(mx-1);\n#if HAVE_BIGENDIAN\n    vec_u8 align_vec0, align_vec8, permh0, permh8;\n    vec_u8 perm_6tap0, perm_6tap8, perml0, perml8;\n    vec_u8 b;\n#endif\n    vec_u8 filt, a, pixh, pixl, outer;\n    vec_s16 f16h, f16l;\n    vec_s32 filth, filtl;\n\n    vec_u8 perm_inner6 = { 1,2,3,4, 2,3,4,5, 3,4,5,6, 4,5,6,7 };\n    vec_u8 perm_inner4 = { 0,1,2,3, 1,2,3,4, 2,3,4,5, 3,4,5,6 };\n    vec_u8 perm_inner  = is6tap ? perm_inner6 : perm_inner4;\n    vec_u8 perm_outer = { 4,9, 0,5, 5,10, 1,6, 6,11, 2,7, 7,12, 3,8 };\n    vec_s32 c64 = vec_sl(vec_splat_s32(1), vec_splat_u32(6));\n    vec_u16 c7  = vec_splat_u16(7);\n\n#if HAVE_BIGENDIAN\n    align_vec0 = vec_lvsl( -is6tap-1, src);\n    align_vec8 = vec_lvsl(8-is6tap-1, src);\n\n    permh0     = vec_perm(align_vec0, align_vec0, perm_inner);\n    permh8     = vec_perm(align_vec8, align_vec8, perm_inner);\n    perm_inner = vec_add(perm_inner, vec_splat_u8(4));\n    perml0     = vec_perm(align_vec0, align_vec0, perm_inner);\n    perml8     = vec_perm(align_vec8, align_vec8, perm_inner);\n    perm_6tap0 = vec_perm(align_vec0, align_vec0, perm_outer);\n    perm_6tap8 = vec_perm(align_vec8, align_vec8, perm_outer);\n#endif\n\n    while (h --> 0) {\n        FILTER_H(f16h, 0);\n\n        if (w == 16) {\n            FILTER_H(f16l, 8);\n            filt = vec_packsu(f16h, f16l);\n            vec_st(filt, 0, dst);\n        } else {\n            filt = vec_packsu(f16h, f16h);\n            vec_ste((vec_u32)filt, 0, (uint32_t*)dst);\n            if (w == 8)\n                vec_ste((vec_u32)filt, 4, (uint32_t*)dst);\n        }\n        src += src_stride;\n        dst += dst_stride;\n    }\n}\n\n// v subpel filter does a simple vertical multiply + add\nstatic const vec_u8 v_subpel_filters[7] =\n{\n    { 0,   6, 123,  12,   1,   0 },\n    { 2,  11, 108,  36,   8,   1 },\n    { 0,   9,  93,  50,   6,   0 },\n    { 3,  16,  77,  77,  16,   3 },\n    { 0,   6,  50,  93,   9,   0 },\n    { 1,   8,  36, 108,  11,   2 },\n    { 0,   1,  12, 123,   6,   0 },\n};\n\n#define LOAD_V_SUBPEL_FILTER(i) \\\n    vec_u8 subpel_filter = v_subpel_filters[i]; \\\n    vec_u8 f0 = vec_splat(subpel_filter, 0); \\\n    vec_u8 f1 = vec_splat(subpel_filter, 1); \\\n    vec_u8 f2 = vec_splat(subpel_filter, 2); \\\n    vec_u8 f3 = vec_splat(subpel_filter, 3); \\\n    vec_u8 f4 = vec_splat(subpel_filter, 4); \\\n    vec_u8 f5 = vec_splat(subpel_filter, 5)\n\n#define FILTER_V(dstv, vec_mul) \\\n    s1f = (vec_s16)vec_mul(s1, f1); \\\n    s2f = (vec_s16)vec_mul(s2, f2); \\\n    s3f = (vec_s16)vec_mul(s3, f3); \\\n    s4f = (vec_s16)vec_mul(s4, f4); \\\n    s2f = vec_subs(s2f, s1f); \\\n    s3f = vec_subs(s3f, s4f); \\\n    if (is6tap) { \\\n        s0f = (vec_s16)vec_mul(s0, f0); \\\n        s5f = (vec_s16)vec_mul(s5, f5); \\\n        s2f = vec_adds(s2f, s0f); \\\n        s3f = vec_adds(s3f, s5f); \\\n    } \\\n    dstv = vec_adds(s2f, s3f); \\\n    dstv = vec_adds(dstv, c64); \\\n    dstv = vec_sra(dstv, c7)\n\n#if HAVE_BIGENDIAN\n#define LOAD_HL(off, s, perm) load_with_perm_vec(off, s, perm)\n#else\n#define LOAD_HL(off, s, perm) vec_mergeh(vec_vsx_ld(off,s), vec_vsx_ld(off+8,s))\n#endif\n\nstatic av_always_inline\nvoid put_vp8_epel_v_altivec_core(uint8_t *dst, ptrdiff_t dst_stride,\n                                 const uint8_t *src, ptrdiff_t src_stride,\n                                 int h, int my, int w, int is6tap)\n{\n    LOAD_V_SUBPEL_FILTER(my-1);\n    vec_u8 s0, s1, s2, s3, s4, s5, filt, align_vech, perm_vec, align_vecl;\n    vec_s16 s0f, s1f, s2f, s3f, s4f, s5f, f16h, f16l;\n    vec_s16 c64 = vec_sl(vec_splat_s16(1), vec_splat_u16(6));\n    vec_u16 c7  = vec_splat_u16(7);\n\n#if HAVE_BIGENDIAN\n    // we want pixels 0-7 to be in the even positions and 8-15 in the odd,\n    // so combine this permute with the alignment permute vector\n    align_vech = vec_lvsl(0, src);\n    align_vecl = vec_sld(align_vech, align_vech, 8);\n    if (w ==16)\n        perm_vec = vec_mergeh(align_vech, align_vecl);\n    else\n        perm_vec = vec_mergeh(align_vech, align_vech);\n#endif\n\n    if (is6tap)\n        s0 = LOAD_HL(-2*src_stride, src, perm_vec);\n    s1 = LOAD_HL(-1*src_stride, src, perm_vec);\n    s2 = LOAD_HL( 0*src_stride, src, perm_vec);\n    s3 = LOAD_HL( 1*src_stride, src, perm_vec);\n    if (is6tap)\n        s4 = LOAD_HL( 2*src_stride, src, perm_vec);\n\n    src += (2+is6tap)*src_stride;\n\n    while (h --> 0) {\n        if (is6tap)\n            s5 = LOAD_HL(0, src, perm_vec);\n        else\n            s4 = LOAD_HL(0, src, perm_vec);\n\n        FILTER_V(f16h, vec_mule);\n\n        if (w == 16) {\n            FILTER_V(f16l, vec_mulo);\n            filt = vec_packsu(f16h, f16l);\n            vec_st(filt, 0, dst);\n        } else {\n            filt = vec_packsu(f16h, f16h);\n            if (w == 4)\n                filt = (vec_u8)vec_splat((vec_u32)filt, 0);\n            else\n                vec_ste((vec_u32)filt, 4, (uint32_t*)dst);\n            vec_ste((vec_u32)filt, 0, (uint32_t*)dst);\n        }\n\n        if (is6tap)\n            s0 = s1;\n        s1 = s2;\n        s2 = s3;\n        s3 = s4;\n        if (is6tap)\n            s4 = s5;\n\n        dst += dst_stride;\n        src += src_stride;\n    }\n}\n\n#define EPEL_FUNCS(WIDTH, TAPS) \\\nstatic av_noinline \\\nvoid put_vp8_epel ## WIDTH ## _h ## TAPS ## _altivec(uint8_t *dst, ptrdiff_t dst_stride, const uint8_t *src, ptrdiff_t src_stride, int h, int mx, int my) \\\n{ \\\n    put_vp8_epel_h_altivec_core(dst, dst_stride, src, src_stride, h, mx, WIDTH, TAPS == 6); \\\n} \\\n\\\nstatic av_noinline \\\nvoid put_vp8_epel ## WIDTH ## _v ## TAPS ## _altivec(uint8_t *dst, ptrdiff_t dst_stride, const uint8_t *src, ptrdiff_t src_stride, int h, int mx, int my) \\\n{ \\\n    put_vp8_epel_v_altivec_core(dst, dst_stride, src, src_stride, h, my, WIDTH, TAPS == 6); \\\n}\n\n#define EPEL_HV(WIDTH, HTAPS, VTAPS) \\\nstatic void put_vp8_epel ## WIDTH ## _h ## HTAPS ## v ## VTAPS ## _altivec(uint8_t *dst, ptrdiff_t dstride, const uint8_t *src, ptrdiff_t sstride, int h, int mx, int my) \\\n{ \\\n    DECLARE_ALIGNED(16, uint8_t, tmp)[(2*WIDTH+5)*16]; \\\n    if (VTAPS == 6) { \\\n        put_vp8_epel ## WIDTH ## _h ## HTAPS ## _altivec(tmp, 16,      src-2*sstride, sstride, h+5, mx, my); \\\n        put_vp8_epel ## WIDTH ## _v ## VTAPS ## _altivec(dst, dstride, tmp+2*16,      16,      h,   mx, my); \\\n    } else { \\\n        put_vp8_epel ## WIDTH ## _h ## HTAPS ## _altivec(tmp, 16,      src-sstride, sstride, h+4, mx, my); \\\n        put_vp8_epel ## WIDTH ## _v ## VTAPS ## _altivec(dst, dstride, tmp+16,      16,      h,   mx, my); \\\n    } \\\n}\n\nEPEL_FUNCS(16,6)\nEPEL_FUNCS(8, 6)\nEPEL_FUNCS(8, 4)\nEPEL_FUNCS(4, 6)\nEPEL_FUNCS(4, 4)\n\nEPEL_HV(16, 6,6)\nEPEL_HV(8,  6,6)\nEPEL_HV(8,  4,6)\nEPEL_HV(8,  6,4)\nEPEL_HV(8,  4,4)\nEPEL_HV(4,  6,6)\nEPEL_HV(4,  4,6)\nEPEL_HV(4,  6,4)\nEPEL_HV(4,  4,4)\n\nstatic void put_vp8_pixels16_altivec(uint8_t *dst, ptrdiff_t dstride, const uint8_t *src, ptrdiff_t sstride, int h, int mx, int my)\n{\n    register vector unsigned char perm;\n    int i;\n    register ptrdiff_t dstride2 = dstride << 1, sstride2 = sstride << 1;\n    register ptrdiff_t dstride3 = dstride2 + dstride, sstride3 = sstride + sstride2;\n    register ptrdiff_t dstride4 = dstride << 2, sstride4 = sstride << 2;\n\n#if HAVE_BIGENDIAN\n    perm = vec_lvsl(0, src);\n#endif\n// hand-unrolling the loop by 4 gains about 15%\n// mininum execution time goes from 74 to 60 cycles\n// it's faster than -funroll-loops, but using\n// -funroll-loops w/ this is bad - 74 cycles again.\n// all this is on a 7450, tuning for the 7450\n    for (i = 0; i < h; i += 4) {\n        vec_st(load_with_perm_vec(0, src, perm), 0, dst);\n        vec_st(load_with_perm_vec(sstride, src, perm), dstride, dst);\n        vec_st(load_with_perm_vec(sstride2, src, perm), dstride2, dst);\n        vec_st(load_with_perm_vec(sstride3, src, perm), dstride3, dst);\n        src += sstride4;\n        dst += dstride4;\n    }\n}\n\n#endif /* HAVE_ALTIVEC */\n\n\nav_cold void ff_vp78dsp_init_ppc(VP8DSPContext *c)\n{\n#if HAVE_ALTIVEC\n    if (!PPC_ALTIVEC(av_get_cpu_flags()))\n        return;\n\n    c->put_vp8_epel_pixels_tab[0][0][0] = put_vp8_pixels16_altivec;\n    c->put_vp8_epel_pixels_tab[0][0][2] = put_vp8_epel16_h6_altivec;\n    c->put_vp8_epel_pixels_tab[0][2][0] = put_vp8_epel16_v6_altivec;\n    c->put_vp8_epel_pixels_tab[0][2][2] = put_vp8_epel16_h6v6_altivec;\n\n    c->put_vp8_epel_pixels_tab[1][0][2] = put_vp8_epel8_h6_altivec;\n    c->put_vp8_epel_pixels_tab[1][2][0] = put_vp8_epel8_v6_altivec;\n    c->put_vp8_epel_pixels_tab[1][0][1] = put_vp8_epel8_h4_altivec;\n    c->put_vp8_epel_pixels_tab[1][1][0] = put_vp8_epel8_v4_altivec;\n\n    c->put_vp8_epel_pixels_tab[1][2][2] = put_vp8_epel8_h6v6_altivec;\n    c->put_vp8_epel_pixels_tab[1][1][1] = put_vp8_epel8_h4v4_altivec;\n    c->put_vp8_epel_pixels_tab[1][1][2] = put_vp8_epel8_h6v4_altivec;\n    c->put_vp8_epel_pixels_tab[1][2][1] = put_vp8_epel8_h4v6_altivec;\n\n    c->put_vp8_epel_pixels_tab[2][0][2] = put_vp8_epel4_h6_altivec;\n    c->put_vp8_epel_pixels_tab[2][2][0] = put_vp8_epel4_v6_altivec;\n    c->put_vp8_epel_pixels_tab[2][0][1] = put_vp8_epel4_h4_altivec;\n    c->put_vp8_epel_pixels_tab[2][1][0] = put_vp8_epel4_v4_altivec;\n\n    c->put_vp8_epel_pixels_tab[2][2][2] = put_vp8_epel4_h6v6_altivec;\n    c->put_vp8_epel_pixels_tab[2][1][1] = put_vp8_epel4_h4v4_altivec;\n    c->put_vp8_epel_pixels_tab[2][1][2] = put_vp8_epel4_h6v4_altivec;\n    c->put_vp8_epel_pixels_tab[2][2][1] = put_vp8_epel4_h4v6_altivec;\n#endif /* HAVE_ALTIVEC */\n}"}, {"project": "NVD", "target": 1, "code": "static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)\n{\n    RKMPPDecodeContext *rk_context = avctx->priv_data;\n    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;\n    RKMPPFrameContext *framecontext = NULL;\n    AVBufferRef *framecontextref = NULL;\n    int ret;\n    MppFrame mppframe = NULL;\n    MppBuffer buffer = NULL;\n    AVDRMFrameDescriptor *desc = NULL;\n    AVDRMLayerDescriptor *layer = NULL;\n    int mode;\n    MppFrameFormat mppformat;\n    uint32_t drmformat;\n\n    ret = decoder->mpi->decode_get_frame(decoder->ctx, &mppframe);\n    if (ret != MPP_OK && ret != MPP_ERR_TIMEOUT) {\n        av_log(avctx, AV_LOG_ERROR, \"Failed to get a frame from MPP (code = %d)\\n\", ret);\n        goto fail;\n    }\n\n    if (mppframe) {\n        // Check whether we have a special frame or not\n        if (mpp_frame_get_info_change(mppframe)) {\n            AVHWFramesContext *hwframes;\n\n            av_log(avctx, AV_LOG_INFO, \"Decoder noticed an info change (%dx%d), format=%d\\n\",\n                                        (int)mpp_frame_get_width(mppframe), (int)mpp_frame_get_height(mppframe),\n                                        (int)mpp_frame_get_fmt(mppframe));\n\n            avctx->width = mpp_frame_get_width(mppframe);\n            avctx->height = mpp_frame_get_height(mppframe);\n\n            decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);\n\n            av_buffer_unref(&decoder->frames_ref);\n\n            decoder->frames_ref = av_hwframe_ctx_alloc(decoder->device_ref);\n            if (!decoder->frames_ref) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n\n            mppformat = mpp_frame_get_fmt(mppframe);\n            drmformat = rkmpp_get_frameformat(mppformat);\n\n            hwframes = (AVHWFramesContext*)decoder->frames_ref->data;\n            hwframes->format    = AV_PIX_FMT_DRM_PRIME;\n            hwframes->sw_format = drmformat == DRM_FORMAT_NV12 ? AV_PIX_FMT_NV12 : AV_PIX_FMT_NONE;\n            hwframes->width     = avctx->width;\n            hwframes->height    = avctx->height;\n            ret = av_hwframe_ctx_init(decoder->frames_ref);\n            if (ret < 0)\n                goto fail;\n\n            // here decoder is fully initialized, we need to feed it again with data\n            ret = AVERROR(EAGAIN);\n            goto fail;\n        } else if (mpp_frame_get_eos(mppframe)) {\n            av_log(avctx, AV_LOG_DEBUG, \"Received a EOS frame.\\n\");\n            decoder->eos_reached = 1;\n            ret = AVERROR_EOF;\n            goto fail;\n        } else if (mpp_frame_get_discard(mppframe)) {\n            av_log(avctx, AV_LOG_DEBUG, \"Received a discard frame.\\n\");\n            ret = AVERROR(EAGAIN);\n            goto fail;\n        } else if (mpp_frame_get_errinfo(mppframe)) {\n            av_log(avctx, AV_LOG_ERROR, \"Received a errinfo frame.\\n\");\n            ret = AVERROR_UNKNOWN;\n            goto fail;\n        }\n\n        // here we should have a valid frame\n        av_log(avctx, AV_LOG_DEBUG, \"Received a frame.\\n\");\n\n        // setup general frame fields\n        frame->format           = AV_PIX_FMT_DRM_PRIME;\n        frame->width            = mpp_frame_get_width(mppframe);\n        frame->height           = mpp_frame_get_height(mppframe);\n        frame->pts              = mpp_frame_get_pts(mppframe);\n        frame->color_range      = mpp_frame_get_color_range(mppframe);\n        frame->color_primaries  = mpp_frame_get_color_primaries(mppframe);\n        frame->color_trc        = mpp_frame_get_color_trc(mppframe);\n        frame->colorspace       = mpp_frame_get_colorspace(mppframe);\n\n        mode = mpp_frame_get_mode(mppframe);\n        if ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED)\n            frame->flags |= AV_FRAME_FLAG_INTERLACED;\n        if ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST)\n            frame->flags |= AV_FRAME_FLAG_TOP_FIELD_FIRST;\n\n        mppformat = mpp_frame_get_fmt(mppframe);\n        drmformat = rkmpp_get_frameformat(mppformat);\n\n        // now setup the frame buffer info\n        buffer = mpp_frame_get_buffer(mppframe);\n        if (buffer) {\n            desc = av_mallocz(sizeof(AVDRMFrameDescriptor));\n            if (!desc) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n\n            desc->nb_objects = 1;\n            desc->objects[0].fd = mpp_buffer_get_fd(buffer);\n            desc->objects[0].size = mpp_buffer_get_size(buffer);\n\n            desc->nb_layers = 1;\n            layer = &desc->layers[0];\n            layer->format = drmformat;\n            layer->nb_planes = 2;\n\n            layer->planes[0].object_index = 0;\n            layer->planes[0].offset = 0;\n            layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);\n\n            layer->planes[1].object_index = 0;\n            layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);\n            layer->planes[1].pitch = layer->planes[0].pitch;\n\n            // we also allocate a struct in buf[0] that will allow to hold additionnal information\n            // for releasing properly MPP frames and decoder\n            framecontextref = av_buffer_allocz(sizeof(*framecontext));\n            if (!framecontextref) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n\n            // MPP decoder needs to be closed only when all frames have been released.\n            framecontext = (RKMPPFrameContext *)framecontextref->data;\n            framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);\n            framecontext->frame = mppframe;\n\n            frame->data[0]  = (uint8_t *)desc;\n            frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_frame,\n                                               framecontextref, AV_BUFFER_FLAG_READONLY);\n\n            if (!frame->buf[0]) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n\n            frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);\n            if (!frame->hw_frames_ctx) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n\n            return 0;\n        } else {\n            av_log(avctx, AV_LOG_ERROR, \"Failed to retrieve the frame buffer, frame is dropped (code = %d)\\n\", ret);\n            mpp_frame_deinit(&mppframe);\n        }\n    } else if (decoder->eos_reached) {\n        return AVERROR_EOF;\n    } else if (ret == MPP_ERR_TIMEOUT) {\n        av_log(avctx, AV_LOG_DEBUG, \"Timeout when trying to get a frame from MPP\\n\");\n    }\n\n    return AVERROR(EAGAIN);\n\nfail:\n    if (mppframe)\n        mpp_frame_deinit(&mppframe);\n\n    if (framecontext)\n        av_buffer_unref(&framecontext->decoder_ref);\n\n    if (framecontextref)\n        av_buffer_unref(&framecontextref);\n\n    if (desc)\n        av_free(desc);\n\n    return ret;\n}\n\nstatic int rkmpp_receive_frame(AVCodecContext *avctx, AVFrame *frame)\n{\n    RKMPPDecodeContext *rk_context = avctx->priv_data;\n    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;\n    int ret = MPP_NOK;\n    AVPacket pkt = {0};\n    RK_S32 usedslots, freeslots;\n\n    if (!decoder->eos_reached) {\n        // we get the available slots in decoder\n        ret = decoder->mpi->control(decoder->ctx, MPP_DEC_GET_STREAM_COUNT, &usedslots);\n        if (ret != MPP_OK) {\n            av_log(avctx, AV_LOG_ERROR, \"Failed to get decoder used slots (code = %d).\\n\", ret);\n            return ret;\n        }\n\n        freeslots = INPUT_MAX_PACKETS - usedslots;\n        if (freeslots > 0) {\n            ret = ff_decode_get_packet(avctx, &pkt);\n            if (ret < 0 && ret != AVERROR_EOF) {\n                return ret;\n            }\n\n            ret = rkmpp_send_packet(avctx, &pkt);\n            av_packet_unref(&pkt);\n\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Failed to send packet to decoder (code = %d)\\n\", ret);\n                return ret;\n            }\n        }\n\n        // make sure we keep decoder full\n        if (freeslots > 1)\n            return AVERROR(EAGAIN);\n    }\n\n    return rkmpp_retrieve_frame(avctx, frame);\n}"}, {"project": "NVD", "target": 1, "code": "static int parse_speex_extradata(AVCodecContext *avctx,\n    const uint8_t *extradata, int extradata_size)\n{\n    SpeexContext *s = avctx->priv_data;\n    const uint8_t *buf = av_strnstr(extradata, \"Speex   \", extradata_size);\n\n    if (!buf)\n        return AVERROR_INVALIDDATA;\n\n    buf += 28;\n\n    s->version_id = bytestream_get_le32(&buf);\n    buf += 4;\n    s->rate = bytestream_get_le32(&buf);\n    if (s->rate <= 0)\n        return AVERROR_INVALIDDATA;\n    s->mode = bytestream_get_le32(&buf);\n    if (s->mode < 0 || s->mode >= SPEEX_NB_MODES)\n        return AVERROR_INVALIDDATA;\n    s->bitstream_version = bytestream_get_le32(&buf);\n    if (s->bitstream_version != 4)\n        return AVERROR_INVALIDDATA;\n    s->nb_channels = bytestream_get_le32(&buf);\n    if (s->nb_channels <= 0 || s->nb_channels > 2)\n        return AVERROR_INVALIDDATA;\n    s->bitrate = bytestream_get_le32(&buf);\n    s->frame_size = bytestream_get_le32(&buf);\n    if (s->frame_size < NB_FRAME_SIZE << (s->mode > 0))\n        return AVERROR_INVALIDDATA;\n    s->frame_size *= 1 + (s->mode > 0);\n    s->vbr = bytestream_get_le32(&buf);\n    s->frames_per_packet = bytestream_get_le32(&buf);\n    if (s->frames_per_packet <= 0 ||\n        s->frames_per_packet > 64 ||\n        s->frames_per_packet >= INT32_MAX / s->nb_channels / s->frame_size)\n        return AVERROR_INVALIDDATA;\n    s->extra_headers = bytestream_get_le32(&buf);\n\n    return 0;\n}\n\nstatic av_cold int speex_decode_init(AVCodecContext *avctx)\n{\n    SpeexContext *s = avctx->priv_data;\n    int ret;\n\n    s->fdsp = avpriv_float_dsp_alloc(0);\n    if (!s->fdsp)\n        return AVERROR(ENOMEM);\n\n    if (avctx->extradata && avctx->extradata_size >= 80) {\n        ret = parse_speex_extradata(avctx, avctx->extradata, avctx->extradata_size);\n        if (ret < 0)\n            return ret;\n    } else {\n        s->rate = avctx->sample_rate;\n        if (s->rate <= 0)\n            return AVERROR_INVALIDDATA;\n\n        s->nb_channels = avctx->ch_layout.nb_channels;\n        if (s->nb_channels <= 0 || s->nb_channels > 2)\n            return AVERROR_INVALIDDATA;\n\n        switch (s->rate) {\n        case 8000:  s->mode = 0; break;\n        case 16000: s->mode = 1; break;\n        case 32000: s->mode = 2; break;\n        default: s->mode = 2;\n        }\n\n        s->frames_per_packet = 64;\n        s->frame_size = NB_FRAME_SIZE << s->mode;\n    }\n\n    if (avctx->codec_tag == MKTAG('S', 'P', 'X', 'N')) {\n        int quality;\n\n        if (!avctx->extradata || avctx->extradata && avctx->extradata_size < 47) {\n            av_log(avctx, AV_LOG_ERROR, \"Missing or invalid extradata.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        quality = avctx->extradata[37];\n        if (quality > 10) {\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported quality mode %d.\\n\", quality);\n            return AVERROR_PATCHWELCOME;\n        }\n\n        s->pkt_size = ((const uint8_t[]){ 5, 10, 15, 20, 20, 28, 28, 38, 38, 46, 62 })[quality];\n\n        s->mode = 0;\n        s->nb_channels = 1;\n        s->rate = avctx->sample_rate;\n        if (s->rate <= 0)\n            return AVERROR_INVALIDDATA;\n        s->frames_per_packet = 1;\n        s->frame_size = NB_FRAME_SIZE;\n    }\n\n    if (s->bitrate > 0)\n        avctx->bit_rate = s->bitrate;\n    av_channel_layout_uninit(&avctx->ch_layout);\n    avctx->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;\n    avctx->ch_layout.nb_channels = s->nb_channels;\n    avctx->sample_rate = s->rate;\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLT;\n\n    for (int m = 0; m <= s->mode; m++) {\n        ret = decoder_init(s, &s->st[m], &speex_modes[m]);\n        if (ret < 0)\n            return ret;\n    }\n\n    s->stereo.balance = 1.f;\n    s->stereo.e_ratio = .5f;\n    s->stereo.smooth_left = 1.f;\n    s->stereo.smooth_right = 1.f;\n\n    return 0;\n}"}, {"project": "NVD", "target": 1, "code": "static int vp9_decode_frame(AVCodecContext *avctx, AVFrame *frame,\n                            int *got_frame, AVPacket *pkt)\n{\n    const uint8_t *data = pkt->data;\n    int size = pkt->size;\n    VP9Context *s = avctx->priv_data;\n    int ret, i, j, ref;\n    int retain_segmap_ref = s->s.frames[REF_FRAME_SEGMAP].segmentation_map &&\n                            (!s->s.h.segmentation.enabled || !s->s.h.segmentation.update_map);\n    const VP9Frame *src;\n    AVFrame *f;\n\n    if ((ret = decode_frame_header(avctx, data, size, &ref)) < 0) {\n        return ret;\n    } else if (ret == 0) {\n        if (!s->s.refs[ref].f) {\n            av_log(avctx, AV_LOG_ERROR, \"Requested reference %d not available\\n\", ref);\n            return AVERROR_INVALIDDATA;\n        }\n        if ((ret = av_frame_ref(frame, s->s.refs[ref].f)) < 0)\n            return ret;\n        frame->pts     = pkt->pts;\n        frame->pkt_dts = pkt->dts;\n        for (int i = 0; i < 8; i++)\n            ff_progress_frame_replace(&s->next_refs[i], &s->s.refs[i]);\n        *got_frame = 1;\n        return pkt->size;\n    }\n    data += ret;\n    size -= ret;\n\n    src = !s->s.h.keyframe && !s->s.h.intraonly && !s->s.h.errorres ? &s->s.frames[CUR_FRAME] : NULL;\n    if (!retain_segmap_ref || s->s.h.keyframe || s->s.h.intraonly)\n        vp9_frame_replace(&s->s.frames[REF_FRAME_SEGMAP], src);\n    vp9_frame_replace(&s->s.frames[REF_FRAME_MVPAIR], src);\n    vp9_frame_unref(&s->s.frames[CUR_FRAME]);\n    if ((ret = vp9_frame_alloc(avctx, &s->s.frames[CUR_FRAME])) < 0)\n        return ret;\n    f = s->s.frames[CUR_FRAME].tf.f;\n    if (s->s.h.keyframe)\n        f->flags |= AV_FRAME_FLAG_KEY;\n    else\n        f->flags &= ~AV_FRAME_FLAG_KEY;\n    f->pict_type = (s->s.h.keyframe || s->s.h.intraonly) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n    // Non-existent frames have the implicit dimension 0x0 != CUR_FRAME\n    if (!s->s.frames[REF_FRAME_MVPAIR].tf.f ||\n        (s->s.frames[REF_FRAME_MVPAIR].tf.f->width  != s->s.frames[CUR_FRAME].tf.f->width ||\n         s->s.frames[REF_FRAME_MVPAIR].tf.f->height != s->s.frames[CUR_FRAME].tf.f->height)) {\n        vp9_frame_unref(&s->s.frames[REF_FRAME_SEGMAP]);\n    }\n\n    // ref frame setup\n    for (i = 0; i < 8; i++) {\n        ff_progress_frame_replace(&s->next_refs[i],\n                                   s->s.h.refreshrefmask & (1 << i) ?\n                                       &s->s.frames[CUR_FRAME].tf : &s->s.refs[i]);\n    }\n\n    if (avctx->hwaccel) {\n        const FFHWAccel *hwaccel = ffhwaccel(avctx->hwaccel);\n        ret = hwaccel->start_frame(avctx, NULL, 0);\n        if (ret < 0)\n            return ret;\n        ret = hwaccel->decode_slice(avctx, pkt->data, pkt->size);\n        if (ret < 0)\n            return ret;\n        ret = hwaccel->end_frame(avctx);\n        if (ret < 0)\n            return ret;\n        goto finish;\n    }\n\n    // main tile decode loop\n    memset(s->above_partition_ctx, 0, s->cols);\n    memset(s->above_skip_ctx, 0, s->cols);\n    if (s->s.h.keyframe || s->s.h.intraonly) {\n        memset(s->above_mode_ctx, DC_PRED, s->cols * 2);\n    } else {\n        memset(s->above_mode_ctx, NEARESTMV, s->cols);\n    }\n    memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);\n    memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);\n    memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);\n    memset(s->above_segpred_ctx, 0, s->cols);\n    s->pass = s->s.frames[CUR_FRAME].uses_2pass =\n        avctx->active_thread_type == FF_THREAD_FRAME && s->s.h.refreshctx && !s->s.h.parallelmode;\n    if ((ret = update_block_buffers(avctx)) < 0) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Failed to allocate block buffers\\n\");\n        return ret;\n    }\n    if (s->s.h.refreshctx && s->s.h.parallelmode) {\n        int j, k, l, m;\n\n        for (i = 0; i < 4; i++) {\n            for (j = 0; j < 2; j++)\n                for (k = 0; k < 2; k++)\n                    for (l = 0; l < 6; l++)\n                        for (m = 0; m < 6; m++)\n                            memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],\n                                   s->prob.coef[i][j][k][l][m], 3);\n            if (s->s.h.txfmmode == i)\n                break;\n        }\n        s->prob_ctx[s->s.h.framectxid].p = s->prob.p;\n        ff_thread_finish_setup(avctx);\n    } else if (!s->s.h.refreshctx) {\n        ff_thread_finish_setup(avctx);\n    }\n\n#if HAVE_THREADS\n    if (avctx->active_thread_type & FF_THREAD_SLICE) {\n        for (i = 0; i < s->sb_rows; i++)\n            atomic_store(&s->entries[i], 0);\n    }\n#endif\n\n    do {\n        for (i = 0; i < s->active_tile_cols; i++) {\n            s->td[i].b = s->td[i].b_base;\n            s->td[i].block = s->td[i].block_base;\n            s->td[i].uvblock[0] = s->td[i].uvblock_base[0];\n            s->td[i].uvblock[1] = s->td[i].uvblock_base[1];\n            s->td[i].eob = s->td[i].eob_base;\n            s->td[i].uveob[0] = s->td[i].uveob_base[0];\n            s->td[i].uveob[1] = s->td[i].uveob_base[1];\n            s->td[i].error_info = 0;\n        }\n\n#if HAVE_THREADS\n        if (avctx->active_thread_type == FF_THREAD_SLICE) {\n            int tile_row, tile_col;\n\n            av_assert1(!s->pass);\n\n            for (tile_row = 0; tile_row < s->s.h.tiling.tile_rows; tile_row++) {\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n                    int64_t tile_size;\n\n                    if (tile_col == s->s.h.tiling.tile_cols - 1 &&\n                        tile_row == s->s.h.tiling.tile_rows - 1) {\n                        tile_size = size;\n                    } else {\n                        tile_size = AV_RB32(data);\n                        data += 4;\n                        size -= 4;\n                    }\n                    if (tile_size > size)\n                        return AVERROR_INVALIDDATA;\n                    ret = ff_vpx_init_range_decoder(&s->td[tile_col].c_b[tile_row], data, tile_size);\n                    if (ret < 0)\n                        return ret;\n                    if (vpx_rac_get_prob_branchy(&s->td[tile_col].c_b[tile_row], 128)) // marker bit\n                        return AVERROR_INVALIDDATA;\n                    data += tile_size;\n                    size -= tile_size;\n                }\n            }\n\n            ff_slice_thread_execute_with_mainfunc(avctx, decode_tiles_mt, loopfilter_proc, s->td, NULL, s->s.h.tiling.tile_cols);\n        } else\n#endif\n        {\n            ret = decode_tiles(avctx, data, size);\n            if (ret < 0) {\n                ff_progress_frame_report(&s->s.frames[CUR_FRAME].tf, INT_MAX);\n                return ret;\n            }\n        }\n\n        // Sum all counts fields into td[0].counts for tile threading\n        if (avctx->active_thread_type == FF_THREAD_SLICE)\n            for (i = 1; i < s->s.h.tiling.tile_cols; i++)\n                for (j = 0; j < sizeof(s->td[i].counts) / sizeof(unsigned); j++)\n                    ((unsigned *)&s->td[0].counts)[j] += ((unsigned *)&s->td[i].counts)[j];\n\n        if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) {\n            ff_vp9_adapt_probs(s);\n            ff_thread_finish_setup(avctx);\n        }\n    } while (s->pass++ == 1);\n    ff_progress_frame_report(&s->s.frames[CUR_FRAME].tf, INT_MAX);\n\n    if (s->td->error_info < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Failed to decode tile data\\n\");\n        s->td->error_info = 0;\n        return AVERROR_INVALIDDATA;\n    }\n    if (avctx->export_side_data & AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS) {\n        ret = vp9_export_enc_params(s, &s->s.frames[CUR_FRAME]);\n        if (ret < 0)\n            return ret;\n    }\n\nfinish:\n    // ref frame setup\n    for (int i = 0; i < 8; i++)\n        ff_progress_frame_replace(&s->s.refs[i], &s->next_refs[i]);\n\n    if (!s->s.h.invisible) {\n        if ((ret = av_frame_ref(frame, s->s.frames[CUR_FRAME].tf.f)) < 0)\n            return ret;\n        *got_frame = 1;\n    }\n\n    return pkt->size;\n}"}, {"project": "NVD", "target": 1, "code": "#include \"libavutil/intreadwrite.h\"\n#include \"avformat.h\"\n#include \"avio_internal.h\"\n#include \"demux.h\"\n#include \"internal.h\"\n\n#define FORM_TAG MKBETAG('F', 'O', 'R', 'M')\n#define WVQA_TAG MKBETAG('W', 'V', 'Q', 'A')\n#define VQHD_TAG MKBETAG('V', 'Q', 'H', 'D')\n#define FINF_TAG MKBETAG('F', 'I', 'N', 'F')\n#define SND0_TAG MKBETAG('S', 'N', 'D', '0')\n#define SND1_TAG MKBETAG('S', 'N', 'D', '1')\n#define SND2_TAG MKBETAG('S', 'N', 'D', '2')\n#define VQFR_TAG MKBETAG('V', 'Q', 'F', 'R')\n#define VQFL_TAG MKBETAG('V', 'Q', 'F', 'L')\n\n/* don't know what these tags are for, but acknowledge their existence */\n#define CINF_TAG MKBETAG('C', 'I', 'N', 'F')\n#define CINH_TAG MKBETAG('C', 'I', 'N', 'H')\n#define CIND_TAG MKBETAG('C', 'I', 'N', 'D')\n#define LINF_TAG MKBETAG('L', 'I', 'N', 'F')\n#define PINF_TAG MKBETAG('P', 'I', 'N', 'F')\n#define PINH_TAG MKBETAG('P', 'I', 'N', 'H')\n#define PIND_TAG MKBETAG('P', 'I', 'N', 'D')\n#define CMDS_TAG MKBETAG('C', 'M', 'D', 'S')\n#define SN2J_TAG MKBETAG('S', 'N', '2', 'J')\n#define VIEW_TAG MKBETAG('V', 'I', 'E', 'W')\n#define ZBUF_TAG MKBETAG('Z', 'B', 'U', 'F')\n\n#define VQA_HEADER_SIZE 0x2A\n#define VQA_PREAMBLE_SIZE 8\n\ntypedef struct WsVqaDemuxContext {\n    int version;\n    int bps;\n    int channels;\n    int sample_rate;\n    int audio_stream_index;\n    int video_stream_index;\n    int64_t vqfl_chunk_pos;\n    int vqfl_chunk_size;\n} WsVqaDemuxContext;\n\nstatic int wsvqa_probe(const AVProbeData *p)\n{\n    /* need 12 bytes to qualify */\n    if (p->buf_size < 12)\n        return 0;\n\n    /* check for the VQA signatures */\n    if ((AV_RB32(&p->buf[0]) != FORM_TAG) ||\n        (AV_RB32(&p->buf[8]) != WVQA_TAG))\n        return 0;\n\n    return AVPROBE_SCORE_MAX;\n}\n\nstatic int wsvqa_read_header(AVFormatContext *s)\n{\n    WsVqaDemuxContext *wsvqa = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint8_t *header;\n    uint8_t scratch[VQA_PREAMBLE_SIZE];\n    uint32_t chunk_tag;\n    uint32_t chunk_size;\n    int fps, ret;\n\n    /* initialize the video decoder stream */\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->start_time = 0;\n    wsvqa->video_stream_index = st->index;\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id = AV_CODEC_ID_WS_VQA;\n    st->codecpar->codec_tag = 0;  /* no fourcc */\n\n    /* skip to the start of the VQA header */\n    avio_seek(pb, 20, SEEK_SET);\n\n    /* the VQA header needs to go to the decoder */\n    if ((ret = ff_get_extradata(s, st->codecpar, pb, VQA_HEADER_SIZE)) < 0)\n        return ret;\n    header = st->codecpar->extradata;\n    st->codecpar->width = AV_RL16(&header[6]);\n    st->codecpar->height = AV_RL16(&header[8]);\n    fps = header[12];\n    st->nb_frames =\n    st->duration  = AV_RL16(&header[4]);\n    if (fps < 1 || fps > 30) {\n        av_log(s, AV_LOG_ERROR, \"invalid fps: %d\\n\", fps);\n        return AVERROR_INVALIDDATA;\n    }\n    avpriv_set_pts_info(st, 64, 1, fps);\n\n    wsvqa->version      = AV_RL16(&header[ 0]);\n    wsvqa->sample_rate  = AV_RL16(&header[24]);\n    wsvqa->channels     = header[26];\n    wsvqa->bps          = header[27];\n    wsvqa->audio_stream_index = -1;\n    wsvqa->vqfl_chunk_pos     = 0;\n    wsvqa->vqfl_chunk_size    = 0;\n\n    s->ctx_flags |= AVFMTCTX_NOHEADER;\n\n    /* there are 0 or more chunks before the FINF chunk; iterate until\n     * FINF has been skipped and the file will be ready to be demuxed */\n    do {\n        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE)\n            return AVERROR(EIO);\n        chunk_tag = AV_RB32(&scratch[0]);\n        chunk_size = AV_RB32(&scratch[4]);\n\n        /* catch any unknown header tags, for curiosity */\n        switch (chunk_tag) {\n        case CINF_TAG:\n        case CINH_TAG:\n        case CIND_TAG:\n        case LINF_TAG:\n        case PINF_TAG:\n        case PINH_TAG:\n        case PIND_TAG:\n        case FINF_TAG:\n        case CMDS_TAG:\n        case VIEW_TAG:\n        case ZBUF_TAG:\n            break;\n\n        default:\n            av_log(s, AV_LOG_ERROR, \" note: unknown chunk seen (%s)\\n\",\n                   av_fourcc2str(chunk_tag));\n            break;\n        }\n\n        avio_skip(pb, chunk_size);\n    } while (chunk_tag != FINF_TAG);\n\n    return 0;\n}\n\nstatic int wsvqa_read_packet(AVFormatContext *s,\n                             AVPacket *pkt)\n{\n    WsVqaDemuxContext *wsvqa = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret = -1;\n    uint8_t preamble[VQA_PREAMBLE_SIZE];\n    uint32_t chunk_type;\n    int chunk_size;\n    unsigned skip_byte;\n\n    while (avio_read(pb, preamble, VQA_PREAMBLE_SIZE) == VQA_PREAMBLE_SIZE) {\n        chunk_type = AV_RB32(&preamble[0]);\n        chunk_size = AV_RB32(&preamble[4]);\n\n        if (chunk_size < 0)\n            return AVERROR_INVALIDDATA;\n        skip_byte = chunk_size & 0x01;\n\n        if (chunk_type == VQFL_TAG) {\n            /* Each VQFL chunk carries only a codebook update inside which must be applied\n             * before the next VQFR is rendered. That's why we stash the VQFL offset here\n             * so it can be combined with the next VQFR packet. This way each packet\n             * includes a whole frame as expected. */\n            wsvqa->vqfl_chunk_pos = avio_tell(pb);\n            if (chunk_size > 3 * (1 << 20))\n                return AVERROR_INVALIDDATA;\n            wsvqa->vqfl_chunk_size = chunk_size;\n            /* We need a big seekback buffer because there can be SNxx, VIEW and ZBUF\n             * chunks (<512 KiB total) in the stream before we read VQFR (<256 KiB) and\n             * seek back here. */\n            ffio_ensure_seekback(pb, wsvqa->vqfl_chunk_size + (512 + 256) * 1024);\n            avio_skip(pb, chunk_size + skip_byte);\n            continue;\n        } else if ((chunk_type == SND0_TAG) || (chunk_type == SND1_TAG) ||\n            (chunk_type == SND2_TAG) || (chunk_type == VQFR_TAG)) {\n\n            ret= av_get_packet(pb, pkt, chunk_size);\n            if (ret<0)\n                return AVERROR(EIO);\n\n            switch (chunk_type) {\n            case SND0_TAG:\n            case SND1_TAG:\n            case SND2_TAG:\n                if (wsvqa->audio_stream_index == -1) {\n                    AVStream *st = avformat_new_stream(s, NULL);\n                    if (!st)\n                        return AVERROR(ENOMEM);\n\n                    wsvqa->audio_stream_index = st->index;\n                    if (!wsvqa->sample_rate)\n                        wsvqa->sample_rate = 22050;\n                    if (!wsvqa->channels)\n                        wsvqa->channels = 1;\n                    if (!wsvqa->bps)\n                        wsvqa->bps = 8;\n                    st->codecpar->sample_rate = wsvqa->sample_rate;\n                    st->codecpar->bits_per_coded_sample = wsvqa->bps;\n                    av_channel_layout_default(&st->codecpar->ch_layout, wsvqa->channels);\n                    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n\n                    avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);\n\n                    switch (chunk_type) {\n                    case SND0_TAG:\n                        if (wsvqa->bps == 16)\n                            st->codecpar->codec_id = AV_CODEC_ID_PCM_S16LE;\n                        else\n                            st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                        break;\n                    case SND1_TAG:\n                        st->codecpar->codec_id = AV_CODEC_ID_WESTWOOD_SND1;\n                        break;\n                    case SND2_TAG:\n                        st->codecpar->codec_id = AV_CODEC_ID_ADPCM_IMA_WS;\n                        if ((ret = ff_alloc_extradata(st->codecpar, 2)) < 0)\n                            return ret;\n                        AV_WL16(st->codecpar->extradata, wsvqa->version);\n                        break;\n                    }\n                }\n\n                pkt->stream_index = wsvqa->audio_stream_index;\n                switch (chunk_type) {\n                case SND1_TAG:\n                    /* unpacked size is stored in header */\n                    if(pkt->data)\n                        pkt->duration = AV_RL16(pkt->data) / wsvqa->channels;\n                    break;\n                case SND2_TAG:\n                    /* 2 samples/byte, 1 or 2 samples per frame depending on stereo */\n                    pkt->duration = (chunk_size * 2) / wsvqa->channels;\n                    break;\n                }\n                break;\n            case VQFR_TAG:\n                /* if a new codebook is available inside an earlier a VQFL chunk then\n                 * append it to 'pkt' */\n                if (wsvqa->vqfl_chunk_size > 0) {\n                    int64_t current_pos = pkt->pos;\n\n                    if (avio_seek(pb, wsvqa->vqfl_chunk_pos, SEEK_SET) < 0)\n                        return AVERROR(EIO);\n\n                    /* the decoder expects chunks to be 16-bit aligned */\n                    if (wsvqa->vqfl_chunk_size % 2 == 1)\n                        wsvqa->vqfl_chunk_size++;\n\n                    if (av_append_packet(pb, pkt, wsvqa->vqfl_chunk_size) < 0)\n                        return AVERROR(EIO);\n\n                    if (avio_seek(pb, current_pos, SEEK_SET) < 0)\n                        return AVERROR(EIO);\n\n                    wsvqa->vqfl_chunk_pos = 0;\n                    wsvqa->vqfl_chunk_size = 0;\n                }\n\n                pkt->stream_index = wsvqa->video_stream_index;\n                pkt->duration = 1;\n                break;\n            }\n\n            /* stay on 16-bit alignment */\n            if (skip_byte)\n                avio_skip(pb, 1);\n\n            return ret;\n        } else {\n            switch(chunk_type){\n            case CMDS_TAG:\n            case SN2J_TAG:\n            case VIEW_TAG:\n            case ZBUF_TAG:\n                break;\n            default:\n                av_log(s, AV_LOG_INFO, \"Skipping unknown chunk %s\\n\",\n                       av_fourcc2str(av_bswap32(chunk_type)));\n            }\n            avio_skip(pb, chunk_size + skip_byte);\n        }\n    }\n\n    return ret;\n}\n\nconst FFInputFormat ff_wsvqa_demuxer = {\n    .p.name         = \"wsvqa\",\n    .p.long_name    = NULL_IF_CONFIG_SMALL(\"Westwood Studios VQA\"),\n    .priv_data_size = sizeof(WsVqaDemuxContext),\n    .read_probe     = wsvqa_probe,\n    .read_header    = wsvqa_read_header,\n    .read_packet    = wsvqa_read_packet,\n};"}, {"project": "NVD", "target": 1, "code": "#include <inttypes.h>\n\n#include \"avformat.h\"\n#include \"demux.h\"\n#include \"internal.h\"\n#include \"isom.h\"\n#include \"mov_chan.h\"\n#include \"libavcodec/flac.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/dict.h\"\n#include \"caf.h\"\n\ntypedef struct CafContext {\n    int bytes_per_packet;           ///< bytes in a packet, or 0 if variable\n    int frames_per_packet;          ///< frames in a packet, or 0 if variable\n    int64_t num_bytes;              ///< total number of bytes in stream\n\n    int64_t packet_cnt;             ///< packet counter\n    int64_t frame_cnt;              ///< frame counter\n\n    int64_t data_start;             ///< data start position, in bytes\n    int64_t data_size;              ///< raw data size, in bytes\n} CafContext;\n\nstatic int probe(const AVProbeData *p)\n{\n    if (AV_RB32(p->buf) != MKBETAG('c','a','f','f'))\n        return 0;\n    if (AV_RB16(&p->buf[4]) != 1)\n        return 0;\n    if (AV_RB32(p->buf + 8) != MKBETAG('d','e','s','c'))\n        return 0;\n    if (AV_RB64(p->buf + 12) != 32)\n        return 0;\n    return AVPROBE_SCORE_MAX;\n}\n\n/** Read audio description chunk */\nstatic int read_desc_chunk(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    CafContext *caf = s->priv_data;\n    AVStream *st;\n    int flags;\n\n    /* new audio stream */\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    /* parse format description */\n    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n    st->codecpar->sample_rate = av_clipd(av_int2double(avio_rb64(pb)), 0, INT_MAX);\n    st->codecpar->codec_tag   = avio_rl32(pb);\n    flags = avio_rb32(pb);\n    caf->bytes_per_packet  = avio_rb32(pb);\n    st->codecpar->block_align = caf->bytes_per_packet;\n    caf->frames_per_packet = avio_rb32(pb);\n    st->codecpar->ch_layout.nb_channels = avio_rb32(pb);\n    st->codecpar->bits_per_coded_sample = avio_rb32(pb);\n\n    if (caf->bytes_per_packet < 0 || caf->frames_per_packet < 0 || st->codecpar->ch_layout.nb_channels < 0)\n        return AVERROR_INVALIDDATA;\n\n    /* calculate bit rate for constant size packets */\n    if (caf->frames_per_packet > 0 && caf->bytes_per_packet > 0) {\n        st->codecpar->bit_rate = (uint64_t)st->codecpar->sample_rate * (uint64_t)caf->bytes_per_packet * 8\n                                 / (uint64_t)caf->frames_per_packet;\n    } else {\n        st->codecpar->bit_rate = 0;\n    }\n\n    /* determine codec */\n    if (st->codecpar->codec_tag == MKTAG('l','p','c','m'))\n        st->codecpar->codec_id = ff_mov_get_lpcm_codec_id(st->codecpar->bits_per_coded_sample, (flags ^ 0x2) | 0x4);\n    else\n        st->codecpar->codec_id = ff_codec_get_id(ff_codec_caf_tags, st->codecpar->codec_tag);\n    return 0;\n}\n\n/** Read magic cookie chunk */\nstatic int read_kuki_chunk(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    AVStream *st      = s->streams[0];\n    int ret;\n\n    if (size < 0 || size > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE)\n        return -1;\n\n    if (st->codecpar->codec_id == AV_CODEC_ID_AAC) {\n        /* The magic cookie format for AAC is an mp4 esds atom.\n           The lavc AAC decoder requires the data from the codec specific\n           description as extradata input. */\n        int strt, skip;\n\n        strt = avio_tell(pb);\n        ff_mov_read_esds(s, pb);\n        skip = size - (avio_tell(pb) - strt);\n        if (skip < 0 || !st->codecpar->extradata ||\n            st->codecpar->codec_id != AV_CODEC_ID_AAC) {\n            av_log(s, AV_LOG_ERROR, \"invalid AAC magic cookie\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        avio_skip(pb, skip);\n    } else if (st->codecpar->codec_id == AV_CODEC_ID_ALAC) {\n#define ALAC_PREAMBLE 12\n#define ALAC_HEADER   36\n#define ALAC_NEW_KUKI 24\n        uint8_t preamble[12];\n        if (size < ALAC_NEW_KUKI) {\n            av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n            avio_skip(pb, size);\n            return AVERROR_INVALIDDATA;\n        }\n        if (avio_read(pb, preamble, ALAC_PREAMBLE) != ALAC_PREAMBLE) {\n            av_log(s, AV_LOG_ERROR, \"failed to read preamble\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if ((ret = ff_alloc_extradata(st->codecpar, ALAC_HEADER)) < 0)\n            return ret;\n\n        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.\n         * The new style cookie only contains the last 24 bytes of what was\n         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes\n         * in that case to maintain compatibility. */\n        if (!memcmp(&preamble[4], \"frmaalac\", 8)) {\n            if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n                av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n                av_freep(&st->codecpar->extradata);\n                return AVERROR_INVALIDDATA;\n            }\n            if (avio_read(pb, st->codecpar->extradata, ALAC_HEADER) != ALAC_HEADER) {\n                av_log(s, AV_LOG_ERROR, \"failed to read kuki header\\n\");\n                av_freep(&st->codecpar->extradata);\n                return AVERROR_INVALIDDATA;\n            }\n            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);\n        } else {\n            AV_WB32(st->codecpar->extradata, 36);\n            memcpy(&st->codecpar->extradata[4], \"alac\", 4);\n            AV_WB32(&st->codecpar->extradata[8], 0);\n            memcpy(&st->codecpar->extradata[12], preamble, 12);\n            if (avio_read(pb, &st->codecpar->extradata[24], ALAC_NEW_KUKI - 12) != ALAC_NEW_KUKI - 12) {\n                av_log(s, AV_LOG_ERROR, \"failed to read new kuki header\\n\");\n                av_freep(&st->codecpar->extradata);\n                return AVERROR_INVALIDDATA;\n            }\n            avio_skip(pb, size - ALAC_NEW_KUKI);\n        }\n    } else if (st->codecpar->codec_id == AV_CODEC_ID_FLAC) {\n        int last, type, flac_metadata_size;\n        uint8_t buf[4];\n        /* The magic cookie format for FLAC consists mostly of an mp4 dfLa atom. */\n        if (size < (16 + FLAC_STREAMINFO_SIZE)) {\n            av_log(s, AV_LOG_ERROR, \"invalid FLAC magic cookie\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        /* Check cookie version. */\n        if (avio_r8(pb) != 0) {\n            av_log(s, AV_LOG_ERROR, \"unknown FLAC magic cookie\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        avio_rb24(pb); /* Flags */\n        /* read dfLa fourcc */\n        if (avio_read(pb, buf, 4) != 4) {\n            av_log(s, AV_LOG_ERROR, \"failed to read FLAC magic cookie\\n\");\n            return pb->error < 0 ? pb->error : AVERROR_INVALIDDATA;\n        }\n        if (memcmp(buf, \"dfLa\", 4)) {\n            av_log(s, AV_LOG_ERROR, \"invalid FLAC magic cookie\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        /* Check dfLa version. */\n        if (avio_r8(pb) != 0) {\n            av_log(s, AV_LOG_ERROR, \"unknown dfLa version\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        avio_rb24(pb); /* Flags */\n        if (avio_read(pb, buf, sizeof(buf)) != sizeof(buf)) {\n            av_log(s, AV_LOG_ERROR, \"failed to read FLAC metadata block header\\n\");\n            return pb->error < 0 ? pb->error : AVERROR_INVALIDDATA;\n        }\n        flac_parse_block_header(buf, &last, &type, &flac_metadata_size);\n        if (type != FLAC_METADATA_TYPE_STREAMINFO || flac_metadata_size != FLAC_STREAMINFO_SIZE) {\n            av_log(s, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        ret = ff_get_extradata(s, st->codecpar, pb, FLAC_STREAMINFO_SIZE);\n        if (ret < 0)\n            return ret;\n        if (!last)\n            av_log(s, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n    } else if (st->codecpar->codec_id == AV_CODEC_ID_OPUS) {\n        // The data layout for Opus is currently unknown, so we do not export\n        // extradata at all. Multichannel streams are not supported.\n        if (st->codecpar->ch_layout.nb_channels > 2) {\n            avpriv_request_sample(s, \"multichannel Opus in CAF\");\n            return AVERROR_PATCHWELCOME;\n        }\n        avio_skip(pb, size);\n    } else if ((ret = ff_get_extradata(s, st->codecpar, pb, size)) < 0) {\n        return ret;\n    }\n\n    return 0;\n}\n\n/** Read packet table chunk */\nstatic int read_pakt_chunk(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    AVStream *st      = s->streams[0];\n    CafContext *caf   = s->priv_data;\n    int64_t pos = 0, ccount, num_packets;\n    int i;\n    int ret;\n\n    ccount = avio_tell(pb);\n\n    num_packets = avio_rb64(pb);\n    if (num_packets < 0 || INT32_MAX / sizeof(AVIndexEntry) < num_packets)\n        return AVERROR_INVALIDDATA;\n\n    st->nb_frames  = avio_rb64(pb); /* valid frames */\n    st->nb_frames += avio_rb32(pb); /* priming frames */\n    st->nb_frames += avio_rb32(pb); /* remainder frames */\n\n    if (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {\n        st->duration = caf->frames_per_packet * num_packets;\n        pos          = caf-> bytes_per_packet * num_packets;\n    } else {\n        st->duration = 0;\n        for (i = 0; i < num_packets; i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n            ret = av_add_index_entry(s->streams[0], pos, st->duration, 0, 0, AVINDEX_KEYFRAME);\n            if (ret < 0)\n                return ret;\n            pos += caf->bytes_per_packet ? caf->bytes_per_packet : ff_mp4_read_descr_len(pb);\n            st->duration += caf->frames_per_packet ? caf->frames_per_packet : ff_mp4_read_descr_len(pb);\n        }\n    }\n\n    if (avio_tell(pb) - ccount > size) {\n        av_log(s, AV_LOG_ERROR, \"error reading packet table\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_seek(pb, ccount + size, SEEK_SET);\n\n    caf->num_bytes = pos;\n    return 0;\n}\n\n/** Read information chunk */\nstatic void read_info_chunk(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    unsigned int i;\n    unsigned int nb_entries = avio_rb32(pb);\n    for (i = 0; i < nb_entries && !avio_feof(pb); i++) {\n        char key[32];\n        char value[1024];\n        avio_get_str(pb, INT_MAX, key, sizeof(key));\n        avio_get_str(pb, INT_MAX, value, sizeof(value));\n        if (!*key)\n            continue;\n        av_dict_set(&s->metadata, key, value, 0);\n    }\n}\n\nstatic int read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    CafContext *caf = s->priv_data;\n    AVStream *st;\n    uint32_t tag = 0;\n    int found_data, ret;\n    int64_t size, pos;\n\n    avio_skip(pb, 8); /* magic, version, file flags */\n\n    /* audio description chunk */\n    if (avio_rb32(pb) != MKBETAG('d','e','s','c')) {\n        av_log(s, AV_LOG_ERROR, \"desc chunk not present\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    size = avio_rb64(pb);\n    if (size != 32)\n        return AVERROR_INVALIDDATA;\n\n    ret = read_desc_chunk(s);\n    if (ret)\n        return ret;\n    st = s->streams[0];\n\n    /* parse each chunk */\n    found_data = 0;\n    while (!avio_feof(pb)) {\n\n        /* stop at data chunk if seeking is not supported or\n           data chunk size is unknown */\n        if (found_data && (caf->data_size < 0 || !(pb->seekable & AVIO_SEEKABLE_NORMAL)))\n            break;\n\n        tag  = avio_rb32(pb);\n        size = avio_rb64(pb);\n        pos  = avio_tell(pb);\n        if (avio_feof(pb))\n            break;\n\n        switch (tag) {\n        case MKBETAG('d','a','t','a'):\n            avio_skip(pb, 4); /* edit count */\n            caf->data_start = avio_tell(pb);\n            caf->data_size  = size < 0 ? -1 : size - 4;\n            if (caf->data_size > 0 && (pb->seekable & AVIO_SEEKABLE_NORMAL))\n                avio_skip(pb, caf->data_size);\n            found_data = 1;\n            break;\n\n        case MKBETAG('c','h','a','n'):\n            if ((ret = ff_mov_read_chan(s, s->pb, st, size)) < 0)\n                return ret;\n            break;\n\n        /* magic cookie chunk */\n        case MKBETAG('k','u','k','i'):\n            if (read_kuki_chunk(s, size))\n                return AVERROR_INVALIDDATA;\n            break;\n\n        /* packet table chunk */\n        case MKBETAG('p','a','k','t'):\n            if (read_pakt_chunk(s, size))\n                return AVERROR_INVALIDDATA;\n            break;\n\n        case MKBETAG('i','n','f','o'):\n            read_info_chunk(s, size);\n            break;\n\n        default:\n            av_log(s, AV_LOG_WARNING,\n                   \"skipping CAF chunk: %08\"PRIX32\" (%s), size %\"PRId64\"\\n\",\n                   tag, av_fourcc2str(av_bswap32(tag)), size);\n        case MKBETAG('f','r','e','e'):\n            if (size < 0 && found_data)\n                goto found_data;\n            if (size < 0)\n                return AVERROR_INVALIDDATA;\n            break;\n        }\n\n        if (size > 0 && (pb->seekable & AVIO_SEEKABLE_NORMAL)) {\n            if (pos > INT64_MAX - size)\n                return AVERROR_INVALIDDATA;\n            avio_seek(pb, pos + size, SEEK_SET);\n        }\n    }\n\n    if (!found_data)\n        return AVERROR_INVALIDDATA;\n\nfound_data:\n    if (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {\n        if (caf->data_size > 0 && caf->data_size / caf->bytes_per_packet < INT64_MAX / caf->frames_per_packet)\n            st->nb_frames = (caf->data_size / caf->bytes_per_packet) * caf->frames_per_packet;\n    } else if (ffstream(st)->nb_index_entries && st->duration > 0) {\n        if (st->codecpar->sample_rate && caf->data_size / st->duration > INT64_MAX / st->codecpar->sample_rate / 8) {\n            av_log(s, AV_LOG_ERROR, \"Overflow during bit rate calculation %d * 8 * %\"PRId64\"\\n\",\n                   st->codecpar->sample_rate, caf->data_size / st->duration);\n            return AVERROR_INVALIDDATA;\n        }\n        st->codecpar->bit_rate = st->codecpar->sample_rate * 8LL *\n                                 (caf->data_size / st->duration);\n    } else {\n        av_log(s, AV_LOG_ERROR, \"Missing packet table. It is required when \"\n                                \"block size or frame size are variable.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);\n    st->start_time = 0;\n\n    /* position the stream at the start of data */\n    if (caf->data_size >= 0)\n        avio_seek(pb, caf->data_start, SEEK_SET);\n\n    return 0;\n}\n\n#define CAF_MAX_PKT_SIZE 4096\n\nstatic int read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    AVIOContext *pb = s->pb;\n    AVStream *st      = s->streams[0];\n    FFStream *const sti = ffstream(st);\n    CafContext *caf   = s->priv_data;\n    int res, pkt_size = 0, pkt_frames = 0;\n    int64_t left      = CAF_MAX_PKT_SIZE;\n\n    if (avio_feof(pb))\n        return AVERROR_EOF;\n\n    /* don't read past end of data chunk */\n    if (caf->data_size > 0) {\n        left = (caf->data_start + caf->data_size) - avio_tell(pb);\n        if (!left)\n            return AVERROR_EOF;\n        if (left < 0)\n            return AVERROR(EIO);\n    }\n\n    pkt_frames = caf->frames_per_packet;\n    pkt_size   = caf->bytes_per_packet;\n\n    if (pkt_size > 0 && pkt_frames == 1) {\n        pkt_size   = (CAF_MAX_PKT_SIZE / pkt_size) * pkt_size;\n        pkt_size   = FFMIN(pkt_size, left);\n        pkt_frames = pkt_size / caf->bytes_per_packet;\n    } else if (sti->nb_index_entries) {\n        if (caf->packet_cnt < sti->nb_index_entries - 1) {\n            pkt_size   = sti->index_entries[caf->packet_cnt + 1].pos       - sti->index_entries[caf->packet_cnt].pos;\n            pkt_frames = sti->index_entries[caf->packet_cnt + 1].timestamp - sti->index_entries[caf->packet_cnt].timestamp;\n        } else if (caf->packet_cnt == sti->nb_index_entries - 1) {\n            pkt_size   = caf->num_bytes - sti->index_entries[caf->packet_cnt].pos;\n            pkt_frames = st->duration   - sti->index_entries[caf->packet_cnt].timestamp;\n        } else {\n            return AVERROR(EIO);\n        }\n    }\n\n    if (pkt_size == 0 || pkt_frames == 0 || pkt_size > left)\n        return AVERROR(EIO);\n\n    res = av_get_packet(pb, pkt, pkt_size);\n    if (res < 0)\n        return res;\n\n    pkt->size           = res;\n    pkt->stream_index   = 0;\n    pkt->dts = pkt->pts = caf->frame_cnt;\n\n    caf->packet_cnt++;\n    caf->frame_cnt += pkt_frames;\n\n    return 0;\n}\n\nstatic int read_seek(AVFormatContext *s, int stream_index,\n                     int64_t timestamp, int flags)\n{\n    AVStream *st = s->streams[0];\n    FFStream *const sti = ffstream(st);\n    CafContext *caf = s->priv_data;\n    int64_t pos, packet_cnt, frame_cnt;\n\n    timestamp = FFMAX(timestamp, 0);\n\n    if (caf->frames_per_packet > 0 && caf->bytes_per_packet > 0) {\n        /* calculate new byte position based on target frame position */\n        pos = caf->bytes_per_packet * (timestamp / caf->frames_per_packet);\n        if (caf->data_size > 0)\n            pos = FFMIN(pos, caf->data_size);\n        packet_cnt = pos / caf->bytes_per_packet;\n        frame_cnt  = caf->frames_per_packet * packet_cnt;\n    } else if (sti->nb_index_entries) {\n        packet_cnt = av_index_search_timestamp(st, timestamp, flags);\n        frame_cnt  = sti->index_entries[packet_cnt].timestamp;\n        pos        = sti->index_entries[packet_cnt].pos;\n    } else {\n        return -1;\n    }\n\n    if (avio_seek(s->pb, pos + caf->data_start, SEEK_SET) < 0)\n        return -1;\n\n    caf->packet_cnt = packet_cnt;\n    caf->frame_cnt  = frame_cnt;\n\n    return 0;\n}\n\nconst FFInputFormat ff_caf_demuxer = {\n    .p.name         = \"caf\",\n    .p.long_name    = NULL_IF_CONFIG_SMALL(\"Apple CAF (Core Audio Format)\"),\n    .p.codec_tag    = ff_caf_codec_tags_list,\n    .priv_data_size = sizeof(CafContext),\n    .read_probe     = probe,\n    .read_header    = read_header,\n    .read_packet    = read_packet,\n    .read_seek      = read_seek,\n};"}, {"project": "NVD", "target": 1, "code": "static int check_stream_max_drift(AVFormatContext *s)\n{\n    int64_t min_pos, pos;\n    int i;\n    int *idx = av_calloc(s->nb_streams, sizeof(*idx));\n    if (!idx)\n        return AVERROR(ENOMEM);\n    for (min_pos = pos = 0; min_pos != INT64_MAX; pos = min_pos + 1LU) {\n        int64_t max_dts = INT64_MIN / 2;\n        int64_t min_dts = INT64_MAX / 2;\n        int64_t max_buffer = 0;\n\n        min_pos = INT64_MAX;\n\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            AVIStream *ast = st->priv_data;\n            FFStream *const sti = ffstream(st);\n            int n = sti->nb_index_entries;\n            while (idx[i] < n && sti->index_entries[idx[i]].pos < pos)\n                idx[i]++;\n            if (idx[i] < n) {\n                int64_t dts;\n                dts = av_rescale_q(sti->index_entries[idx[i]].timestamp /\n                                   FFMAX(ast->sample_size, 1),\n                                   st->time_base, AV_TIME_BASE_Q);\n                min_dts = FFMIN(min_dts, dts);\n                min_pos = FFMIN(min_pos, sti->index_entries[idx[i]].pos);\n            }\n        }\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            FFStream *const sti = ffstream(st);\n            AVIStream *ast = st->priv_data;\n\n            if (idx[i] && min_dts != INT64_MAX / 2) {\n                int64_t dts, delta_dts;\n                dts = av_rescale_q(sti->index_entries[idx[i] - 1].timestamp /\n                                   FFMAX(ast->sample_size, 1),\n                                   st->time_base, AV_TIME_BASE_Q);\n                delta_dts = av_sat_sub64(dts, min_dts);\n                max_dts = FFMAX(max_dts, dts);\n                max_buffer = FFMAX(max_buffer,\n                                   av_rescale(delta_dts,\n                                              st->codecpar->bit_rate,\n                                              AV_TIME_BASE));\n            }\n        }\n        if (av_sat_sub64(max_dts, min_dts) > 2 * AV_TIME_BASE ||\n            max_buffer > 1024 * 1024 * 8 * 8) {\n            av_free(idx);\n            return 1;\n        }\n    }\n    av_free(idx);\n    return 0;\n}\n    \nstatic int guess_ni_flag(AVFormatContext *s)\n{\n    int i;\n    int64_t last_start = 0;\n    int64_t first_end  = INT64_MAX;\n    int64_t oldpos     = avio_tell(s->pb);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        FFStream *const sti = ffstream(st);\n        int n = sti->nb_index_entries;\n        unsigned int size;\n\n        if (n <= 0)\n            continue;\n\n        if (n >= 2) {\n            int64_t pos = sti->index_entries[0].pos;\n            unsigned tag[2];\n            avio_seek(s->pb, pos, SEEK_SET);\n            tag[0] = avio_r8(s->pb);\n            tag[1] = avio_r8(s->pb);\n            avio_rl16(s->pb);\n            size = avio_rl32(s->pb);\n            if (get_stream_idx(tag) == i && pos + size > sti->index_entries[1].pos)\n                last_start = INT64_MAX;\n            if (get_stream_idx(tag) == i && size == sti->index_entries[0].size + 8)\n                last_start = INT64_MAX;\n        }\n\n        if (sti->index_entries[0].pos > last_start)\n            last_start = sti->index_entries[0].pos;\n        if (sti->index_entries[n - 1].pos < first_end)\n            first_end = sti->index_entries[n - 1].pos;\n    }\n    avio_seek(s->pb, oldpos, SEEK_SET);\n\n    if (last_start > first_end)\n        return 1;\n\n    return check_stream_max_drift(s);\n}"}, {"project": "NVD", "target": 1, "code": "static int decode_5elp(AVCodecContext *avctx,\n                       WavArcContext *s, GetBitContext *gb)\n{\n    int ch, finished, fill, correlated, order = 0;\n\n    ch = 0;\n    finished = 0;\n    while (!finished) {\n        int *samples = s->samples[ch];\n        int *ac_pred = s->ac_pred;\n        int *ac_out = s->ac_out;\n        int k, block_type;\n\n        if (get_bits_left(gb) <= 0)\n            return AVERROR_INVALIDDATA;\n\n        memset(s->ac_out, 0, sizeof(s->ac_out));\n\n        block_type = get_urice(gb, 1);\n        av_log(avctx, AV_LOG_DEBUG, \"block_type : %d\\n\", block_type);\n\n        if (block_type >= 0 && block_type <= 7) {\n            k = 1 + (avctx->sample_fmt == AV_SAMPLE_FMT_S16P);\n            k = get_urice(gb, k) + 1;\n            if (k >= 32)\n                return AVERROR_INVALIDDATA;\n        }\n\n        if (block_type <=  2 || block_type ==  6 || block_type == 13 ||\n            block_type == 14 || block_type == 15 || block_type == 19) {\n            order = get_urice(gb, 2);\n            if ((unsigned)order > FF_ARRAY_ELEMS(s->filter[ch]))\n                return AVERROR_INVALIDDATA;\n            for (int o = 0; o < order; o++)\n                s->filter[ch][o] = get_srice(gb, 2);\n        }\n\n        if (block_type >= 0 && block_type <= 7) {\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] = get_srice(gb, k);\n        } else {\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] = 0;\n        }\n\n        if (block_type >= 13 && block_type <= 20) {\n            const int ac_size = get_bits(gb, 12);\n            const int ac_pos = get_bits_count(gb);\n            GetBitContext ac_gb = *gb;\n            int ret;\n\n            skip_bits_long(gb, ac_size);\n            ret = ac_read_model(avctx, s, &ac_gb);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"bad arithmetic model\\n\");\n                return ret;\n            }\n\n            ret = ac_init(avctx, s, &ac_gb);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"cannot init arithmetic decoder\\n\");\n                return ret;\n            }\n\n            for (int n = 0; n < s->nb_samples; n++) {\n                uint16_t prob = ac_get_prob(s);\n                int ac = ac_map_symbol(s, prob);\n                ac_out[n] = ac - 0x80;\n                if ((ret = ac_normalize(avctx, s, &ac_gb)) < 0)\n                    return ret;\n            }\n\n            if (get_bits_count(&ac_gb) != ac_pos + ac_size) {\n                av_log(avctx, AV_LOG_DEBUG, \"over/under-read in arithmetic coder: %d\\n\",\n                       ac_pos + ac_size - get_bits_count(&ac_gb));\n            }\n        }\n\n        switch (block_type) {\n        case 12:\n            s->eof = 1;\n            return AVERROR_EOF;\n        case 11:\n            s->nb_samples = get_urice(gb, 8);\n            if (s->nb_samples > 570U) {\n                s->nb_samples = 570;\n                return AVERROR_INVALIDDATA;\n            }\n            continue;\n        case 10:\n            s->shift = get_urice(gb, 2);\n            if ((unsigned)s->shift > 31) {\n                s->shift = 0;\n                return AVERROR_INVALIDDATA;\n            }\n            continue;\n        case 9:\n            if (avctx->sample_fmt == AV_SAMPLE_FMT_U8P) {\n                fill = (int8_t)get_bits(gb, 8);\n                fill -= 0x80;\n            } else {\n                fill = (int16_t)get_bits(gb, 16);\n                fill -= 0x8000;\n            }\n\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] = fill;\n            finished = 1;\n            break;\n        case 8:\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] = 0;\n            finished = 1;\n            break;\n        case 20:\n        case 7:\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] += ac_out[n] + samples[n + 69] * 3U - samples[n + 68] * 3U + samples[n + 67];\n            finished = 1;\n            break;\n        case 19:\n        case 6:\n            for (int n = 0; n < 70; n++) {\n                ac_pred[n] = samples[n];\n                samples[n] = 0;\n            }\n\n            for (int n = 0; n < s->nb_samples; n++) {\n                int sum = 15;\n\n                for (int o = 0; o < order; o++)\n                    sum += s->filter[ch][o] * (unsigned)samples[n + 70 - o - 1];\n\n                samples[n + 70] += ac_out[n] + (sum >> 4);\n            }\n\n            for (int n = 0; n < 70; n++)\n                samples[n] = ac_pred[n];\n\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] += ac_out[n] + samples[n + 69] * 3U - samples[n + 68] * 3U + samples[n + 67];\n\n            finished = 1;\n            break;\n        case 18:\n        case 5:\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] += ac_out[n] + samples[n + 69] * 2U - samples[n + 68];\n            finished = 1;\n            break;\n        case 17:\n        case 4:\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] += ac_out[n];\n            finished = 1;\n            break;\n        case 16:\n        case 3:\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] += ac_out[n] + (unsigned)samples[n + 69];\n            finished = 1;\n            break;\n        case 15:\n        case 2:\n            for (int n = 0; n < 70; n++) {\n                ac_pred[n] = samples[n];\n                samples[n] = 0;\n            }\n\n            for (int n = 0; n < s->nb_samples; n++) {\n                int sum = 15;\n\n                for (int o = 0; o < order; o++)\n                    sum += s->filter[ch][o] * (unsigned)samples[n + 70 - o - 1];\n\n                samples[n + 70] += ac_out[n] + (sum >> 4);\n            }\n\n            for (int n = 0; n < 70; n++)\n                samples[n] = ac_pred[n];\n\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] += samples[n + 69] * 2U - samples[n + 68];\n\n            finished = 1;\n            break;\n        case 14:\n        case 1:\n            for (int n = 0; n < 70; n++) {\n                ac_pred[n] = samples[n];\n                samples[n] = 0;\n            }\n\n            for (int n = 0; n < s->nb_samples; n++) {\n                int sum = 15;\n\n                for (int o = 0; o < order; o++)\n                    sum += s->filter[ch][o] * (unsigned)samples[n + 70 - o - 1];\n\n                samples[n + 70] += (unsigned)ac_out[n] + (sum >> 4);\n            }\n\n            for (int n = 0; n < 70; n++)\n                samples[n] = ac_pred[n];\n\n            for (int n = 0; n < s->nb_samples; n++)\n                samples[n + 70] += (unsigned)samples[n + 69];\n\n            finished = 1;\n            break;\n        case 13:\n        case 0:\n            for (int n = 0; n < s->nb_samples; n++) {\n                int sum = 15;\n\n                for (int o = 0; o < order; o++)\n                    sum += s->filter[ch][o] * (unsigned)samples[n + 70 - o - 1];\n\n                samples[n + 70] += (unsigned)ac_out[n] + (sum >> 4);\n            }\n            finished = 1;\n            break;\n        default:\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (finished == 1 && avctx->ch_layout.nb_channels == 2) {\n            if (ch == 0)\n                correlated = get_bits1(gb);\n            finished = ch != 0;\n            do_stereo(s, ch, correlated, 70);\n            ch = 1;\n        }\n    }\n\n    if (avctx->ch_layout.nb_channels == 1) {\n        for (int n = 0; n < 70; n++)\n            s->samples[0][n] = s->samples[0][s->nb_samples + n];\n    }\n\n    return 0;\n}\n\nstatic int wavarc_decode(AVCodecContext *avctx, AVFrame *frame,\n                         int *got_frame_ptr, AVPacket *pkt)\n{\n    WavArcContext *s = avctx->priv_data;\n    GetBitContext *gb = &s->gb;\n    int buf_size, input_buf_size;\n    const uint8_t *buf;\n    int ret, n;\n\n    if ((!pkt->size && !s->bitstream_size) || s->nb_samples == 0 || s->eof) {\n        *got_frame_ptr = 0;\n        return pkt->size;\n    }\n\n    buf_size = FFMIN(pkt->size, s->max_framesize - s->bitstream_size);\n    input_buf_size = buf_size;\n    if (s->bitstream_index + s->bitstream_size + buf_size + AV_INPUT_BUFFER_PADDING_SIZE > s->max_framesize) {\n        memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size);\n        s->bitstream_index = 0;\n    }\n    if (pkt->data)\n        memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], pkt->data, buf_size);\n    buf                = &s->bitstream[s->bitstream_index];\n    buf_size          += s->bitstream_size;\n    s->bitstream_size  = buf_size;\n    if (buf_size < s->max_framesize && pkt->data) {\n        *got_frame_ptr = 0;\n        return input_buf_size;\n    }\n\n    if ((ret = init_get_bits8(gb, buf, buf_size)) < 0)\n        goto fail;\n    skip_bits(gb, s->skip);\n\n    switch (avctx->codec_tag) {\n    case MKTAG('0','C','P','Y'):\n        ret = decode_0cpy(avctx, s, gb);\n        break;\n    case MKTAG('1','D','I','F'):\n        ret = decode_1dif(avctx, s, gb);\n        break;\n    case MKTAG('2','S','L','P'):\n    case MKTAG('3','N','L','P'):\n    case MKTAG('4','A','L','P'):\n        ret = decode_2slp(avctx, s, gb);\n        break;\n    case MKTAG('5','E','L','P'):\n        ret = decode_5elp(avctx, s, gb);\n        break;\n    default:\n        ret = AVERROR_INVALIDDATA;\n    }\n\n    if (ret < 0)\n        goto fail;\n\n    s->skip = get_bits_count(gb) - 8 * (get_bits_count(gb) / 8);\n    n = get_bits_count(gb) / 8;\n\n    if (n > buf_size) {\nfail:\n        s->bitstream_size = 0;\n        s->bitstream_index = 0;\n        if (ret == AVERROR_EOF)\n            return 0;\n        return AVERROR_INVALIDDATA;\n    }\n\n    frame->nb_samples = s->nb_samples;\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        goto fail;\n\n    switch (avctx->sample_fmt) {\n    case AV_SAMPLE_FMT_U8P:\n        for (int ch = 0; ch < avctx->ch_layout.nb_channels; ch++) {\n            uint8_t *dst = (uint8_t *)frame->extended_data[ch];\n            const int *src = s->samples[ch] + s->offset;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = src[n] * (1U << s->shift) + 0x80U;\n        }\n        break;\n    case AV_SAMPLE_FMT_S16P:\n        for (int ch = 0; ch < avctx->ch_layout.nb_channels; ch++) {\n            int16_t *dst = (int16_t *)frame->extended_data[ch];\n            const int *src = s->samples[ch] + s->offset;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = src[n] * (1U << s->shift);\n        }\n        break;\n    }\n\n    *got_frame_ptr = 1;\n\n    if (s->bitstream_size) {\n        s->bitstream_index += n;\n        s->bitstream_size  -= n;\n        return input_buf_size;\n    }\n\n    return n;\n}"}, {"project": "NVD", "target": 1, "code": "static void esp_do_nodma(ESPState *s)\n{\n    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);\n    uint32_t cmdlen;\n    int len;\n\n    if (s->do_cmd) {\n        cmdlen = fifo8_num_used(&s->cmdfifo);\n        trace_esp_handle_ti_cmd(cmdlen);\n        s->ti_size = 0;\n        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {\n            /* No command received */\n            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {\n                return;\n            }\n\n            /* Command has been received */\n            s->do_cmd = 0;\n            do_cmd(s);\n        } else {\n            /*\n             * Extra message out bytes received: update cmdfifo_cdb_offset\n             * and then switch to command phase\n             */\n            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n            s->rregs[ESP_RINTR] |= INTR_BS;\n            esp_raise_irq(s);\n        }\n        return;\n    }\n\n    if (!s->current_req) {\n        return;\n    }\n\n    if (s->async_len == 0) {\n        /* Defer until data is available.  */\n        return;\n    }\n\n    if (to_device) {\n        len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);\n        esp_fifo_pop_buf(&s->fifo, s->async_buf, len);\n        s->async_buf += len;\n        s->async_len -= len;\n        s->ti_size += len;\n    } else {\n        if (fifo8_is_empty(&s->fifo)) {\n            fifo8_push(&s->fifo, s->async_buf[0]);\n            s->async_buf++;\n            s->async_len--;\n            s->ti_size--;\n        }\n    }\n\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        return;\n    }\n\n    s->rregs[ESP_RINTR] |= INTR_BS;\n    esp_raise_irq(s);\n}\n\nvoid esp_transfer_data(SCSIRequest *req, uint32_t len)\n{\n    ESPState *s = req->hba_private;\n    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);\n    uint32_t dmalen = esp_get_tc(s);\n\n    assert(!s->do_cmd);\n    trace_esp_transfer_data(dmalen, s->ti_size);\n    s->async_len = len;\n    s->async_buf = scsi_req_get_buf(req);\n\n    if (!to_device && !s->data_in_ready) {\n        /*\n         * Initial incoming data xfer is complete so raise command\n         * completion interrupt\n         */\n        s->data_in_ready = true;\n        s->rregs[ESP_RSTAT] |= STAT_TC;\n        s->rregs[ESP_RINTR] |= INTR_BS;\n        esp_raise_irq(s);\n    }\n\n    if (s->ti_cmd == 0) {\n        /*\n         * Always perform the initial transfer upon reception of the next TI\n         * command to ensure the DMA/non-DMA status of the command is correct.\n         * It is not possible to use s->dma directly in the section below as\n         * some OSs send non-DMA NOP commands after a DMA transfer. Hence if the\n         * async data transfer is delayed then s->dma is set incorrectly.\n         */\n        return;\n    }\n\n    if (s->ti_cmd == (CMD_TI | CMD_DMA)) {\n        if (dmalen) {\n            esp_do_dma(s);\n        } else if (s->ti_size <= 0) {\n            /*\n             * If this was the last part of a DMA transfer then the\n             * completion interrupt is deferred to here.\n             */\n            esp_dma_done(s);\n            esp_lower_drq(s);\n        }\n    } else if (s->ti_cmd == CMD_TI) {\n        esp_do_nodma(s);\n    }\n}\n\nstatic void handle_ti(ESPState *s)\n{\n    uint32_t dmalen;\n\n    if (s->dma && !s->dma_enabled) {\n        s->dma_cb = handle_ti;\n        return;\n    }\n\n    s->ti_cmd = s->rregs[ESP_CMD];\n    if (s->dma) {\n        dmalen = esp_get_tc(s);\n        trace_esp_handle_ti(dmalen);\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        esp_do_dma(s);\n    } else {\n        trace_esp_handle_ti(s->ti_size);\n        esp_do_nodma(s);\n    }\n}\n\nuint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t val;\n\n    switch (saddr) {\n    case ESP_FIFO:\n        if (s->dma_memory_read && s->dma_memory_write &&\n                (s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n            /* Data out.  */\n            qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");\n            s->rregs[ESP_FIFO] = 0;\n        } else {\n            if ((s->rregs[ESP_RSTAT] & 0x7) == STAT_DI) {\n                if (s->ti_size) {\n                    esp_do_nodma(s);\n                } else {\n                    /*\n                     * The last byte of a non-DMA transfer has been read out\n                     * of the FIFO so switch to status phase\n                     */\n                    s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n                }\n            }\n            s->rregs[ESP_FIFO] = esp_fifo_pop(&s->fifo);\n        }\n        val = s->rregs[ESP_FIFO];\n        break;\n    case ESP_RINTR:\n        /*\n         * Clear sequence step, interrupt register and all status bits\n         * except TC\n         */\n        val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        /*\n         * According to the datasheet ESP_RSEQ should be cleared, but as the\n         * emulation currently defers information transfers to the next TI\n         * command leave it for now so that pedantic guests such as the old\n         * Linux 2.6 driver see the correct flags before the next SCSI phase\n         * transition.\n         *\n         * s->rregs[ESP_RSEQ] = SEQ_0;\n         */\n        esp_lower_irq(s);\n        break;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            val = s->chip_id;\n        } else {\n            val = s->rregs[saddr];\n        }\n        break;\n     case ESP_RFLAGS:\n        /* Bottom 5 bits indicate number of bytes in FIFO */\n        val = fifo8_num_used(&s->fifo);\n        break;\n    default:\n        val = s->rregs[saddr];\n        break;\n    }\n\n    trace_esp_mem_readb(saddr, val);\n    return val;\n}"}, {"project": "NVD", "target": 1, "code": "static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx, bool extra_pass)\n{\n\tu8 tm = -1;\n\tu64 func_addr;\n\tbool func_addr_fixed;\n\tint i = insn - ctx->prog->insnsi;\n\tint ret, jmp_offset;\n\tconst u8 code = insn->code;\n\tconst u8 cond = BPF_OP(code);\n\tconst u8 t1 = LOONGARCH_GPR_T1;\n\tconst u8 t2 = LOONGARCH_GPR_T2;\n\tconst u8 src = regmap[insn->src_reg];\n\tconst u8 dst = regmap[insn->dst_reg];\n\tconst s16 off = insn->off;\n\tconst s32 imm = insn->imm;\n\tconst u64 imm64 = (u64)(insn + 1)->imm << 32 | (u32)insn->imm;\n\tconst bool is32 = BPF_CLASS(insn->code) == BPF_ALU || BPF_CLASS(insn->code) == BPF_JMP32;\n\n\tswitch (code) {\n\t/* dst = src */\n\tcase BPF_ALU | BPF_MOV | BPF_X:\n\tcase BPF_ALU64 | BPF_MOV | BPF_X:\n\t\tmove_reg(ctx, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = imm */\n\tcase BPF_ALU | BPF_MOV | BPF_K:\n\tcase BPF_ALU64 | BPF_MOV | BPF_K:\n\t\tmove_imm(ctx, dst, imm, is32);\n\t\tbreak;\n\n\t/* dst = dst + src */\n\tcase BPF_ALU | BPF_ADD | BPF_X:\n\tcase BPF_ALU64 | BPF_ADD | BPF_X:\n\t\temit_insn(ctx, addd, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst + imm */\n\tcase BPF_ALU | BPF_ADD | BPF_K:\n\tcase BPF_ALU64 | BPF_ADD | BPF_K:\n\t\tif (is_signed_imm12(imm)) {\n\t\t\temit_insn(ctx, addid, dst, dst, imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, addd, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst - src */\n\tcase BPF_ALU | BPF_SUB | BPF_X:\n\tcase BPF_ALU64 | BPF_SUB | BPF_X:\n\t\temit_insn(ctx, subd, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst - imm */\n\tcase BPF_ALU | BPF_SUB | BPF_K:\n\tcase BPF_ALU64 | BPF_SUB | BPF_K:\n\t\tif (is_signed_imm12(-imm)) {\n\t\t\temit_insn(ctx, addid, dst, dst, -imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, subd, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst * src */\n\tcase BPF_ALU | BPF_MUL | BPF_X:\n\tcase BPF_ALU64 | BPF_MUL | BPF_X:\n\t\temit_insn(ctx, muld, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst * imm */\n\tcase BPF_ALU | BPF_MUL | BPF_K:\n\tcase BPF_ALU64 | BPF_MUL | BPF_K:\n\t\tmove_imm(ctx, t1, imm, is32);\n\t\temit_insn(ctx, muld, dst, dst, t1);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst / src */\n\tcase BPF_ALU | BPF_DIV | BPF_X:\n\tcase BPF_ALU64 | BPF_DIV | BPF_X:\n\t\temit_zext_32(ctx, dst, is32);\n\t\tmove_reg(ctx, t1, src);\n\t\temit_zext_32(ctx, t1, is32);\n\t\temit_insn(ctx, divdu, dst, dst, t1);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst / imm */\n\tcase BPF_ALU | BPF_DIV | BPF_K:\n\tcase BPF_ALU64 | BPF_DIV | BPF_K:\n\t\tmove_imm(ctx, t1, imm, is32);\n\t\temit_zext_32(ctx, dst, is32);\n\t\temit_insn(ctx, divdu, dst, dst, t1);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst % src */\n\tcase BPF_ALU | BPF_MOD | BPF_X:\n\tcase BPF_ALU64 | BPF_MOD | BPF_X:\n\t\temit_zext_32(ctx, dst, is32);\n\t\tmove_reg(ctx, t1, src);\n\t\temit_zext_32(ctx, t1, is32);\n\t\temit_insn(ctx, moddu, dst, dst, t1);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst % imm */\n\tcase BPF_ALU | BPF_MOD | BPF_K:\n\tcase BPF_ALU64 | BPF_MOD | BPF_K:\n\t\tmove_imm(ctx, t1, imm, is32);\n\t\temit_zext_32(ctx, dst, is32);\n\t\temit_insn(ctx, moddu, dst, dst, t1);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = -dst */\n\tcase BPF_ALU | BPF_NEG:\n\tcase BPF_ALU64 | BPF_NEG:\n\t\tmove_imm(ctx, t1, imm, is32);\n\t\temit_insn(ctx, subd, dst, LOONGARCH_GPR_ZERO, dst);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst & src */\n\tcase BPF_ALU | BPF_AND | BPF_X:\n\tcase BPF_ALU64 | BPF_AND | BPF_X:\n\t\temit_insn(ctx, and, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst & imm */\n\tcase BPF_ALU | BPF_AND | BPF_K:\n\tcase BPF_ALU64 | BPF_AND | BPF_K:\n\t\tif (is_unsigned_imm12(imm)) {\n\t\t\temit_insn(ctx, andi, dst, dst, imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, and, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst | src */\n\tcase BPF_ALU | BPF_OR | BPF_X:\n\tcase BPF_ALU64 | BPF_OR | BPF_X:\n\t\temit_insn(ctx, or, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst | imm */\n\tcase BPF_ALU | BPF_OR | BPF_K:\n\tcase BPF_ALU64 | BPF_OR | BPF_K:\n\t\tif (is_unsigned_imm12(imm)) {\n\t\t\temit_insn(ctx, ori, dst, dst, imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, or, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst ^ src */\n\tcase BPF_ALU | BPF_XOR | BPF_X:\n\tcase BPF_ALU64 | BPF_XOR | BPF_X:\n\t\temit_insn(ctx, xor, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst ^ imm */\n\tcase BPF_ALU | BPF_XOR | BPF_K:\n\tcase BPF_ALU64 | BPF_XOR | BPF_K:\n\t\tif (is_unsigned_imm12(imm)) {\n\t\t\temit_insn(ctx, xori, dst, dst, imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, xor, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst << src (logical) */\n\tcase BPF_ALU | BPF_LSH | BPF_X:\n\t\temit_insn(ctx, sllw, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_LSH | BPF_X:\n\t\temit_insn(ctx, slld, dst, dst, src);\n\t\tbreak;\n\n\t/* dst = dst << imm (logical) */\n\tcase BPF_ALU | BPF_LSH | BPF_K:\n\t\temit_insn(ctx, slliw, dst, dst, imm);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_LSH | BPF_K:\n\t\temit_insn(ctx, sllid, dst, dst, imm);\n\t\tbreak;\n\n\t/* dst = dst >> src (logical) */\n\tcase BPF_ALU | BPF_RSH | BPF_X:\n\t\temit_insn(ctx, srlw, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_RSH | BPF_X:\n\t\temit_insn(ctx, srld, dst, dst, src);\n\t\tbreak;\n\n\t/* dst = dst >> imm (logical) */\n\tcase BPF_ALU | BPF_RSH | BPF_K:\n\t\temit_insn(ctx, srliw, dst, dst, imm);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_RSH | BPF_K:\n\t\temit_insn(ctx, srlid, dst, dst, imm);\n\t\tbreak;\n\n\t/* dst = dst >> src (arithmetic) */\n\tcase BPF_ALU | BPF_ARSH | BPF_X:\n\t\temit_insn(ctx, sraw, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_ARSH | BPF_X:\n\t\temit_insn(ctx, srad, dst, dst, src);\n\t\tbreak;\n\n\t/* dst = dst >> imm (arithmetic) */\n\tcase BPF_ALU | BPF_ARSH | BPF_K:\n\t\temit_insn(ctx, sraiw, dst, dst, imm);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_ARSH | BPF_K:\n\t\temit_insn(ctx, sraid, dst, dst, imm);\n\t\tbreak;\n\n\t/* dst = BSWAP##imm(dst) */\n\tcase BPF_ALU | BPF_END | BPF_FROM_LE:\n\t\tswitch (imm) {\n\t\tcase 16:\n\t\t\t/* zero-extend 16 bits into 64 bits */\n\t\t\temit_insn(ctx, bstrpickd, dst, dst, 15, 0);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\t/* zero-extend 32 bits into 64 bits */\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\t/* do nothing */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase BPF_ALU | BPF_END | BPF_FROM_BE:\n\t\tswitch (imm) {\n\t\tcase 16:\n\t\t\temit_insn(ctx, revb2h, dst, dst);\n\t\t\t/* zero-extend 16 bits into 64 bits */\n\t\t\temit_insn(ctx, bstrpickd, dst, dst, 15, 0);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\temit_insn(ctx, revb2w, dst, dst);\n\t\t\t/* zero-extend 32 bits into 64 bits */\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\temit_insn(ctx, revbd, dst, dst);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* PC += off if dst cond src */\n\tcase BPF_JMP | BPF_JEQ | BPF_X:\n\tcase BPF_JMP | BPF_JNE | BPF_X:\n\tcase BPF_JMP | BPF_JGT | BPF_X:\n\tcase BPF_JMP | BPF_JGE | BPF_X:\n\tcase BPF_JMP | BPF_JLT | BPF_X:\n\tcase BPF_JMP | BPF_JLE | BPF_X:\n\tcase BPF_JMP | BPF_JSGT | BPF_X:\n\tcase BPF_JMP | BPF_JSGE | BPF_X:\n\tcase BPF_JMP | BPF_JSLT | BPF_X:\n\tcase BPF_JMP | BPF_JSLE | BPF_X:\n\tcase BPF_JMP32 | BPF_JEQ | BPF_X:\n\tcase BPF_JMP32 | BPF_JNE | BPF_X:\n\tcase BPF_JMP32 | BPF_JGT | BPF_X:\n\tcase BPF_JMP32 | BPF_JGE | BPF_X:\n\tcase BPF_JMP32 | BPF_JLT | BPF_X:\n\tcase BPF_JMP32 | BPF_JLE | BPF_X:\n\tcase BPF_JMP32 | BPF_JSGT | BPF_X:\n\tcase BPF_JMP32 | BPF_JSGE | BPF_X:\n\tcase BPF_JMP32 | BPF_JSLT | BPF_X:\n\tcase BPF_JMP32 | BPF_JSLE | BPF_X:\n\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\tmove_reg(ctx, t1, dst);\n\t\tmove_reg(ctx, t2, src);\n\t\tif (is_signed_bpf_cond(BPF_OP(code))) {\n\t\t\temit_sext_32(ctx, t1, is32);\n\t\t\temit_sext_32(ctx, t2, is32);\n\t\t} else {\n\t\t\temit_zext_32(ctx, t1, is32);\n\t\t\temit_zext_32(ctx, t2, is32);\n\t\t}\n\t\tif (emit_cond_jmp(ctx, cond, t1, t2, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* PC += off if dst cond imm */\n\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\tcase BPF_JMP | BPF_JNE | BPF_K:\n\tcase BPF_JMP | BPF_JGT | BPF_K:\n\tcase BPF_JMP | BPF_JGE | BPF_K:\n\tcase BPF_JMP | BPF_JLT | BPF_K:\n\tcase BPF_JMP | BPF_JLE | BPF_K:\n\tcase BPF_JMP | BPF_JSGT | BPF_K:\n\tcase BPF_JMP | BPF_JSGE | BPF_K:\n\tcase BPF_JMP | BPF_JSLT | BPF_K:\n\tcase BPF_JMP | BPF_JSLE | BPF_K:\n\tcase BPF_JMP32 | BPF_JEQ | BPF_K:\n\tcase BPF_JMP32 | BPF_JNE | BPF_K:\n\tcase BPF_JMP32 | BPF_JGT | BPF_K:\n\tcase BPF_JMP32 | BPF_JGE | BPF_K:\n\tcase BPF_JMP32 | BPF_JLT | BPF_K:\n\tcase BPF_JMP32 | BPF_JLE | BPF_K:\n\tcase BPF_JMP32 | BPF_JSGT | BPF_K:\n\tcase BPF_JMP32 | BPF_JSGE | BPF_K:\n\tcase BPF_JMP32 | BPF_JSLT | BPF_K:\n\tcase BPF_JMP32 | BPF_JSLE | BPF_K:\n\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\tif (imm) {\n\t\t\tmove_imm(ctx, t1, imm, false);\n\t\t\ttm = t1;\n\t\t} else {\n\t\t\t/* If imm is 0, simply use zero register. */\n\t\t\ttm = LOONGARCH_GPR_ZERO;\n\t\t}\n\t\tmove_reg(ctx, t2, dst);\n\t\tif (is_signed_bpf_cond(BPF_OP(code))) {\n\t\t\temit_sext_32(ctx, tm, is32);\n\t\t\temit_sext_32(ctx, t2, is32);\n\t\t} else {\n\t\t\temit_zext_32(ctx, tm, is32);\n\t\t\temit_zext_32(ctx, t2, is32);\n\t\t}\n\t\tif (emit_cond_jmp(ctx, cond, t2, tm, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* PC += off if dst & src */\n\tcase BPF_JMP | BPF_JSET | BPF_X:\n\tcase BPF_JMP32 | BPF_JSET | BPF_X:\n\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\temit_insn(ctx, and, t1, dst, src);\n\t\temit_zext_32(ctx, t1, is32);\n\t\tif (emit_cond_jmp(ctx, cond, t1, LOONGARCH_GPR_ZERO, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* PC += off if dst & imm */\n\tcase BPF_JMP | BPF_JSET | BPF_K:\n\tcase BPF_JMP32 | BPF_JSET | BPF_K:\n\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\tmove_imm(ctx, t1, imm, is32);\n\t\temit_insn(ctx, and, t1, dst, t1);\n\t\temit_zext_32(ctx, t1, is32);\n\t\tif (emit_cond_jmp(ctx, cond, t1, LOONGARCH_GPR_ZERO, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* PC += off */\n\tcase BPF_JMP | BPF_JA:\n\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\tif (emit_uncond_jmp(ctx, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* function call */\n\tcase BPF_JMP | BPF_CALL:\n\t\tmark_call(ctx);\n\t\tret = bpf_jit_get_func_addr(ctx->prog, insn, extra_pass,\n\t\t\t\t\t    &func_addr, &func_addr_fixed);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmove_addr(ctx, t1, func_addr);\n\t\temit_insn(ctx, jirl, t1, LOONGARCH_GPR_RA, 0);\n\t\tmove_reg(ctx, regmap[BPF_REG_0], LOONGARCH_GPR_A0);\n\t\tbreak;\n\n\t/* tail call */\n\tcase BPF_JMP | BPF_TAIL_CALL:\n\t\tmark_tail_call(ctx);\n\t\tif (emit_bpf_tail_call(ctx) < 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\t/* function return */\n\tcase BPF_JMP | BPF_EXIT:\n\t\tif (i == ctx->prog->len - 1)\n\t\t\tbreak;\n\n\t\tjmp_offset = epilogue_offset(ctx);\n\t\tif (emit_uncond_jmp(ctx, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* dst = imm64 */\n\tcase BPF_LD | BPF_IMM | BPF_DW:\n\t\tmove_imm(ctx, dst, imm64, is32);\n\t\treturn 1;\n\n\t/* dst = *(size *)(src + off) */\n\tcase BPF_LDX | BPF_MEM | BPF_B:\n\tcase BPF_LDX | BPF_MEM | BPF_H:\n\tcase BPF_LDX | BPF_MEM | BPF_W:\n\tcase BPF_LDX | BPF_MEM | BPF_DW:\n\t\tswitch (BPF_SIZE(code)) {\n\t\tcase BPF_B:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, ldbu, dst, src, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, ldxbu, dst, src, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_H:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, ldhu, dst, src, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, ldxhu, dst, src, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_W:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, ldwu, dst, src, off);\n\t\t\t} else if (is_signed_imm14(off)) {\n\t\t\t\temit_insn(ctx, ldptrw, dst, src, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, ldxwu, dst, src, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_DW:\n\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\temit_insn(ctx, ldxd, dst, src, t1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* *(size *)(dst + off) = imm */\n\tcase BPF_ST | BPF_MEM | BPF_B:\n\tcase BPF_ST | BPF_MEM | BPF_H:\n\tcase BPF_ST | BPF_MEM | BPF_W:\n\tcase BPF_ST | BPF_MEM | BPF_DW:\n\t\tswitch (BPF_SIZE(code)) {\n\t\tcase BPF_B:\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, stb, t1, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t2, off, is32);\n\t\t\t\temit_insn(ctx, stxb, t1, dst, t2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_H:\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, sth, t1, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t2, off, is32);\n\t\t\t\temit_insn(ctx, stxh, t1, dst, t2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_W:\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, stw, t1, dst, off);\n\t\t\t} else if (is_signed_imm14(off)) {\n\t\t\t\temit_insn(ctx, stptrw, t1, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t2, off, is32);\n\t\t\t\temit_insn(ctx, stxw, t1, dst, t2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_DW:\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, std, t1, dst, off);\n\t\t\t} else if (is_signed_imm14(off)) {\n\t\t\t\temit_insn(ctx, stptrd, t1, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t2, off, is32);\n\t\t\t\temit_insn(ctx, stxd, t1, dst, t2);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* *(size *)(dst + off) = src */\n\tcase BPF_STX | BPF_MEM | BPF_B:\n\tcase BPF_STX | BPF_MEM | BPF_H:\n\tcase BPF_STX | BPF_MEM | BPF_W:\n\tcase BPF_STX | BPF_MEM | BPF_DW:\n\t\tswitch (BPF_SIZE(code)) {\n\t\tcase BPF_B:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, stb, src, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, stxb, src, dst, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_H:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, sth, src, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, stxh, src, dst, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_W:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, stw, src, dst, off);\n\t\t\t} else if (is_signed_imm14(off)) {\n\t\t\t\temit_insn(ctx, stptrw, src, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, stxw, src, dst, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_DW:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, std, src, dst, off);\n\t\t\t} else if (is_signed_imm14(off)) {\n\t\t\t\temit_insn(ctx, stptrd, src, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, stxd, src, dst, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase BPF_STX | BPF_ATOMIC | BPF_W:\n\tcase BPF_STX | BPF_ATOMIC | BPF_DW:\n\t\temit_atomic(insn, ctx);\n\t\tbreak;\n\n\t/* Speculation barrier */\n\tcase BPF_ST | BPF_NOSPEC:\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"bpf_jit: unknown opcode %02x\\n\", code);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\ntoofar:\n\tpr_info_once(\"bpf_jit: opcode %02x, jump too far\\n\", code);\n\treturn -E2BIG;\n}"}, {"project": "NVD", "target": 1, "code": "#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"codec_internal.h\"\n#include \"decode.h\"\n#include \"internal.h\"\n#define BITSTREAM_READER_LE\n#include \"get_bits.h\"\n#include \"unary.h\"\n\n#define OFFSET 5\n\ntypedef struct OSQChannel {\n    unsigned prediction;\n    unsigned coding_mode;\n    unsigned residue_parameter;\n    unsigned residue_bits;\n    unsigned history[3];\n    unsigned pos, count;\n    double sum;\n    int32_t prev;\n} OSQChannel;\n\ntypedef struct OSQContext {\n    GetBitContext gb;\n    OSQChannel ch[2];\n\n    uint8_t *bitstream;\n    size_t max_framesize;\n    size_t bitstream_size;\n\n    int decorrelate;\n    int frame_samples;\n    int64_t nb_samples;\n\n    int32_t *decode_buffer[2];\n\n    AVPacket *pkt;\n    int pkt_offset;\n} OSQContext;\n\nstatic av_cold int osq_close(AVCodecContext *avctx)\n{\n    OSQContext *s = avctx->priv_data;\n\n    av_freep(&s->bitstream);\n    s->bitstream_size = 0;\n\n    for (int ch = 0; ch < FF_ARRAY_ELEMS(s->decode_buffer); ch++)\n        av_freep(&s->decode_buffer[ch]);\n\n    return 0;\n}\n\nstatic av_cold int osq_init(AVCodecContext *avctx)\n{\n    OSQContext *s = avctx->priv_data;\n\n    if (avctx->extradata_size < 48)\n        return AVERROR(EINVAL);\n\n    if (avctx->extradata[0] != 1) {\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported version.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avctx->sample_rate = AV_RL32(avctx->extradata + 4);\n    if (avctx->sample_rate < 1)\n        return AVERROR_INVALIDDATA;\n\n    av_channel_layout_uninit(&avctx->ch_layout);\n    avctx->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;\n    avctx->ch_layout.nb_channels = avctx->extradata[3];\n    if (avctx->ch_layout.nb_channels < 1)\n        return AVERROR_INVALIDDATA;\n    if (avctx->ch_layout.nb_channels > FF_ARRAY_ELEMS(s->decode_buffer))\n        return AVERROR_INVALIDDATA;\n\n    switch (avctx->extradata[2]) {\n    case  8: avctx->sample_fmt = AV_SAMPLE_FMT_U8P; break;\n    case 16: avctx->sample_fmt = AV_SAMPLE_FMT_S16P; break;\n    case 20:\n    case 24:\n    case 28:\n    case 32: avctx->sample_fmt = AV_SAMPLE_FMT_S32P; break;\n    default: return AVERROR_INVALIDDATA;\n    }\n\n    s->nb_samples = AV_RL64(avctx->extradata + 16);\n    s->frame_samples = AV_RL16(avctx->extradata + 8);\n    s->max_framesize = (s->frame_samples * 16 + 1024) * avctx->ch_layout.nb_channels;\n\n    s->bitstream = av_calloc(s->max_framesize + AV_INPUT_BUFFER_PADDING_SIZE, sizeof(*s->bitstream));\n    if (!s->bitstream)\n        return AVERROR(ENOMEM);\n\n    for (int ch = 0; ch < avctx->ch_layout.nb_channels; ch++) {\n        s->decode_buffer[ch] = av_calloc(s->frame_samples + OFFSET,\n                                         sizeof(*s->decode_buffer[ch]));\n        if (!s->decode_buffer[ch])\n            return AVERROR(ENOMEM);\n    }\n\n    s->pkt = avctx->internal->in_pkt;\n\n    return 0;\n}\n\nstatic void reset_stats(OSQChannel *cb)\n{\n    memset(cb->history, 0, sizeof(cb->history));\n    cb->pos = cb->count = cb->sum = 0;\n}\n\nstatic void update_stats(OSQChannel *cb, int val)\n{\n    cb->sum += FFABS(val) - cb->history[cb->pos];\n    cb->history[cb->pos] = FFABS(val);\n    cb->pos++;\n    cb->count++;\n    if (cb->pos >= FF_ARRAY_ELEMS(cb->history))\n        cb->pos = 0;\n}\n\nstatic int update_residue_parameter(OSQChannel *cb)\n{\n    double sum, x;\n    int rice_k;\n\n    sum = cb->sum;\n    x = sum / cb->count;\n    rice_k = av_ceil_log2(x);\n    if (rice_k >= 30) {\n        rice_k = floor(sum / 1.4426952 + 0.5);\n        if (rice_k < 1)\n            rice_k = 1;\n    }\n\n    return rice_k;\n}\n\nstatic uint32_t get_urice(GetBitContext *gb, int k)\n{\n    uint32_t z, x, b;\n\n    x = get_unary(gb, 1, 512);\n    b = get_bits_long(gb, k);\n    z = b | x << k;\n\n    return z;\n}\n\nstatic int32_t get_srice(GetBitContext *gb, int x)\n{\n    int32_t y = get_urice(gb, x);\n    return get_bits1(gb) ? -y : y;\n}\n\nstatic int osq_channel_parameters(AVCodecContext *avctx, int ch)\n{\n    OSQContext *s = avctx->priv_data;\n    OSQChannel *cb = &s->ch[ch];\n    GetBitContext *gb = &s->gb;\n\n    cb->prev = 0;\n    cb->prediction = get_urice(gb, 5);\n    cb->coding_mode = get_urice(gb, 3);\n    if (cb->prediction >= 15)\n        return AVERROR_INVALIDDATA;\n    if (cb->coding_mode > 0 && cb->coding_mode < 3) {\n        cb->residue_parameter = get_urice(gb, 4);\n        if (!cb->residue_parameter || cb->residue_parameter >= 31)\n            return AVERROR_INVALIDDATA;\n    } else if (cb->coding_mode == 3) {\n        cb->residue_bits = get_urice(gb, 4);\n        if (!cb->residue_bits || cb->residue_bits >= 31)\n            return AVERROR_INVALIDDATA;\n    } else if (cb->coding_mode) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (cb->coding_mode == 2)\n        reset_stats(cb);\n\n    return 0;\n}\n\n#define A (-1)\n#define B (-2)\n#define C (-3)\n#define D (-4)\n#define E (-5)\n#define P2 ((dst[A] + dst[A]) - dst[B])\n#define P3 ((dst[A] - dst[B]) * 3 + dst[C])\n\nstatic int do_decode(AVCodecContext *avctx, AVFrame *frame, int decorrelate, int downsample)\n{\n    OSQContext *s = avctx->priv_data;\n    const int nb_channels = avctx->ch_layout.nb_channels;\n    const int nb_samples = frame->nb_samples;\n    GetBitContext *gb = &s->gb;\n\n    for (int n = 0; n < nb_samples; n++) {\n        for (int ch = 0; ch < nb_channels; ch++) {\n            OSQChannel *cb = &s->ch[ch];\n            int32_t *dst = s->decode_buffer[ch] + OFFSET;\n            int32_t p, prev = cb->prev;\n\n            if (nb_channels == 2 && ch == 1 && decorrelate != s->decorrelate) {\n                if (!decorrelate) {\n                    s->decode_buffer[1][OFFSET+A] += s->decode_buffer[0][OFFSET+B];\n                    s->decode_buffer[1][OFFSET+B] += s->decode_buffer[0][OFFSET+C];\n                    s->decode_buffer[1][OFFSET+C] += s->decode_buffer[0][OFFSET+D];\n                    s->decode_buffer[1][OFFSET+D] += s->decode_buffer[0][OFFSET+E];\n                } else {\n                    s->decode_buffer[1][OFFSET+A] -= s->decode_buffer[0][OFFSET+B];\n                    s->decode_buffer[1][OFFSET+B] -= s->decode_buffer[0][OFFSET+C];\n                    s->decode_buffer[1][OFFSET+C] -= s->decode_buffer[0][OFFSET+D];\n                    s->decode_buffer[1][OFFSET+D] -= s->decode_buffer[0][OFFSET+E];\n                }\n                s->decorrelate = decorrelate;\n            }\n\n            if (!cb->coding_mode) {\n                dst[n] = 0;\n            } else if (cb->coding_mode == 3) {\n                dst[n] = get_sbits_long(gb, cb->residue_bits);\n            } else {\n                dst[n] = get_srice(gb, cb->residue_parameter);\n            }\n\n            if (get_bits_left(gb) < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"overread!\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            p = prev / 2;\n            prev = dst[n];\n\n            switch (cb->prediction) {\n            case 0:\n                break;\n            case 1:\n                dst[n] += dst[A];\n                break;\n            case 2:\n                dst[n] += dst[A] + p;\n                break;\n            case 3:\n                dst[n] += P2;\n                break;\n            case 4:\n                dst[n] += P2 + p;\n                break;\n            case 5:\n                dst[n] += P3;\n                break;\n            case 6:\n                dst[n] += P3 + p;\n                break;\n            case 7:\n                dst[n] += (P2 + P3) / 2 + p;\n                break;\n            case 8:\n                dst[n] += (P2 + P3) / 2;\n                break;\n            case 9:\n                dst[n] += (P2 * 2 + P3) / 3 + p;\n                break;\n            case 10:\n                dst[n] += (P2 + P3 * 2) / 3 + p;\n                break;\n            case 11:\n                dst[n] += (dst[A] + dst[B]) / 2;\n                break;\n            case 12:\n                dst[n] += dst[B];\n                break;\n            case 13:\n                dst[n] += (dst[D] + dst[B]) / 2;\n                break;\n            case 14:\n                dst[n] += (P2 + dst[A]) / 2 + p;\n                break;\n            default:\n                return AVERROR_INVALIDDATA;\n            }\n\n            cb->prev = prev;\n\n            if (downsample)\n                dst[n] *= 256;\n\n            dst[E] = dst[D];\n            dst[D] = dst[C];\n            dst[C] = dst[B];\n            dst[B] = dst[A];\n            dst[A] = dst[n];\n\n            if (cb->coding_mode == 2) {\n                update_stats(cb, dst[n]);\n                cb->residue_parameter = update_residue_parameter(cb);\n            }\n\n            if (nb_channels == 2 && ch == 1) {\n                if (decorrelate)\n                    dst[n] += s->decode_buffer[0][OFFSET+n];\n            }\n\n            if (downsample)\n                dst[A] /= 256;\n        }\n    }\n\n    return 0;\n}\n\nstatic int osq_decode_block(AVCodecContext *avctx, AVFrame *frame)\n{\n    const int nb_channels = avctx->ch_layout.nb_channels;\n    OSQContext *s = avctx->priv_data;\n    int ret, decorrelate, downsample;\n    GetBitContext *gb = &s->gb;\n\n    skip_bits1(gb);\n    decorrelate = get_bits1(gb);\n    downsample = get_bits1(gb);\n\n    for (int ch = 0; ch < nb_channels; ch++) {\n        if ((ret = osq_channel_parameters(avctx, ch)) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid channel parameters\\n\");\n            return ret;\n        }\n    }\n\n    if ((ret = do_decode(avctx, frame, decorrelate, downsample)) < 0)\n        return ret;\n\n    align_get_bits(gb);\n\n    switch (avctx->sample_fmt) {\n    case AV_SAMPLE_FMT_U8P:\n        for (int ch = 0; ch < nb_channels; ch++) {\n            uint8_t *dst = (uint8_t *)frame->extended_data[ch];\n            int32_t *src = s->decode_buffer[ch] + OFFSET;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = av_clip_uint8(src[n] + 0x80);\n        }\n        break;\n    case AV_SAMPLE_FMT_S16P:\n        for (int ch = 0; ch < nb_channels; ch++) {\n            int16_t *dst = (int16_t *)frame->extended_data[ch];\n            int32_t *src = s->decode_buffer[ch] + OFFSET;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = (int16_t)src[n];\n        }\n        break;\n    case AV_SAMPLE_FMT_S32P:\n        for (int ch = 0; ch < nb_channels; ch++) {\n            int32_t *dst = (int32_t *)frame->extended_data[ch];\n            int32_t *src = s->decode_buffer[ch] + OFFSET;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = src[n];\n        }\n        break;\n    default:\n        return AVERROR_BUG;\n    }\n\n    return 0;\n}\n\nstatic int osq_receive_frame(AVCodecContext *avctx, AVFrame *frame)\n{\n    OSQContext *s = avctx->priv_data;\n    GetBitContext *gb = &s->gb;\n    int ret, n;\n\n    while (s->bitstream_size < s->max_framesize) {\n        int size;\n\n        if (!s->pkt->data) {\n            ret = ff_decode_get_packet(avctx, s->pkt);\n            if (ret == AVERROR_EOF && s->bitstream_size > 0)\n                break;\n            if (ret < 0)\n                return ret;\n        }\n\n        size = FFMIN(s->pkt->size - s->pkt_offset, s->max_framesize - s->bitstream_size);\n        memcpy(s->bitstream + s->bitstream_size, s->pkt->data + s->pkt_offset, size);\n        s->bitstream_size += size;\n        s->pkt_offset += size;\n\n        if (s->pkt_offset == s->pkt->size) {\n            av_packet_unref(s->pkt);\n            s->pkt_offset = 0;\n        }\n    }\n\n    frame->nb_samples = FFMIN(s->frame_samples, s->nb_samples);\n    if (frame->nb_samples <= 0)\n        return AVERROR_EOF;\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        goto fail;\n\n    if ((ret = init_get_bits8(gb, s->bitstream, s->bitstream_size)) < 0)\n        goto fail;\n\n    if ((ret = osq_decode_block(avctx, frame)) < 0)\n        goto fail;\n\n    s->nb_samples -= frame->nb_samples;\n\n    n = get_bits_count(gb) / 8;\n    if (n > s->bitstream_size) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    memmove(s->bitstream, &s->bitstream[n], s->bitstream_size - n);\n    s->bitstream_size -= n;\n\n    return 0;\n\nfail:\n    s->bitstream_size = 0;\n    s->pkt_offset = 0;\n    av_packet_unref(s->pkt);\n\n    return ret;\n}\n\nconst FFCodec ff_osq_decoder = {\n    .p.name           = \"osq\",\n    CODEC_LONG_NAME(\"OSQ (Original Sound Quality)\"),\n    .p.type           = AVMEDIA_TYPE_AUDIO,\n    .p.id             = AV_CODEC_ID_OSQ,\n    .priv_data_size   = sizeof(OSQContext),\n    .init             = osq_init,\n    FF_CODEC_RECEIVE_FRAME_CB(osq_receive_frame),\n    .close            = osq_close,\n    .p.capabilities   = AV_CODEC_CAP_CHANNEL_CONF |\n                        AV_CODEC_CAP_DR1,\n    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,\n    .p.sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,\n                                                        AV_SAMPLE_FMT_S16P,\n                                                        AV_SAMPLE_FMT_S32P,\n                                                        AV_SAMPLE_FMT_NONE },\n};"}, {"project": "NVD", "target": 1, "code": "#include <net/sock.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netdevice.h>\n#include \"rmnet_config.h\"\n#include \"rmnet_handlers.h\"\n#include \"rmnet_vnd.h\"\n#include \"rmnet_private.h\"\n\n/* Local Definitions and Declarations */\n\nstatic const struct nla_policy rmnet_policy[IFLA_RMNET_MAX + 1] = {\n\t[IFLA_RMNET_MUX_ID]\t= { .type = NLA_U16 },\n\t[IFLA_RMNET_FLAGS]\t= { .len = sizeof(struct ifla_rmnet_flags) },\n};\n\nstatic int rmnet_is_real_dev_registered(const struct net_device *real_dev)\n{\n\treturn rcu_access_pointer(real_dev->rx_handler) == rmnet_rx_handler;\n}\n\n/* Needs rtnl lock */\nstatic struct rmnet_port*\nrmnet_get_port_rtnl(const struct net_device *real_dev)\n{\n\treturn rtnl_dereference(real_dev->rx_handler_data);\n}\n\nstatic int rmnet_unregister_real_device(struct net_device *real_dev)\n{\n\tstruct rmnet_port *port = rmnet_get_port_rtnl(real_dev);\n\n\tif (port->nr_rmnet_devs)\n\t\treturn -EINVAL;\n\n\tnetdev_rx_handler_unregister(real_dev);\n\n\tkfree(port);\n\n\tnetdev_dbg(real_dev, \"Removed from rmnet\\n\");\n\treturn 0;\n}\n\nstatic int rmnet_register_real_device(struct net_device *real_dev,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct rmnet_port *port;\n\tint rc, entry;\n\n\tASSERT_RTNL();\n\n\tif (rmnet_is_real_dev_registered(real_dev)) {\n\t\tport = rmnet_get_port_rtnl(real_dev);\n\t\tif (port->rmnet_mode != RMNET_EPMODE_VND) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"bridge device already exists\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tport = kzalloc(sizeof(*port), GFP_ATOMIC);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->dev = real_dev;\n\trc = netdev_rx_handler_register(real_dev, rmnet_rx_handler, port);\n\tif (rc) {\n\t\tkfree(port);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (entry = 0; entry < RMNET_MAX_LOGICAL_EP; entry++)\n\t\tINIT_HLIST_HEAD(&port->muxed_ep[entry]);\n\n\tnetdev_dbg(real_dev, \"registered with rmnet\\n\");\n\treturn 0;\n}\n\nstatic void rmnet_unregister_bridge(struct rmnet_port *port)\n{\n\tstruct net_device *bridge_dev, *real_dev, *rmnet_dev;\n\tstruct rmnet_port *real_port;\n\n\tif (port->rmnet_mode != RMNET_EPMODE_BRIDGE)\n\t\treturn;\n\n\trmnet_dev = port->rmnet_dev;\n\tif (!port->nr_rmnet_devs) {\n\t\t/* bridge device */\n\t\treal_dev = port->bridge_ep;\n\t\tbridge_dev = port->dev;\n\n\t\treal_port = rmnet_get_port_rtnl(real_dev);\n\t\treal_port->bridge_ep = NULL;\n\t\treal_port->rmnet_mode = RMNET_EPMODE_VND;\n\t} else {\n\t\t/* real device */\n\t\tbridge_dev = port->bridge_ep;\n\n\t\tport->bridge_ep = NULL;\n\t\tport->rmnet_mode = RMNET_EPMODE_VND;\n\t}\n\n\tnetdev_upper_dev_unlink(bridge_dev, rmnet_dev);\n\trmnet_unregister_real_device(bridge_dev);\n}\n\nstatic int rmnet_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tu32 data_format = RMNET_FLAGS_INGRESS_DEAGGREGATION;\n\tstruct net_device *real_dev;\n\tint mode = RMNET_EPMODE_VND;\n\tstruct rmnet_endpoint *ep;\n\tstruct rmnet_port *port;\n\tint err = 0;\n\tu16 mux_id;\n\n\tif (!tb[IFLA_LINK]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"link not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\treal_dev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\n\tif (!real_dev || !dev)\n\t\treturn -ENODEV;\n\n\tif (!data[IFLA_RMNET_MUX_ID])\n\t\treturn -EINVAL;\n\n\tep = kzalloc(sizeof(*ep), GFP_ATOMIC);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tmux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);\n\n\terr = rmnet_register_real_device(real_dev, extack);\n\tif (err)\n\t\tgoto err0;\n\n\tport = rmnet_get_port_rtnl(real_dev);\n\terr = rmnet_vnd_newlink(mux_id, dev, port, real_dev, ep);\n\tif (err)\n\t\tgoto err1;\n\n\terr = netdev_upper_dev_link(real_dev, dev, extack);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tport->rmnet_mode = mode;\n\tport->rmnet_dev = dev;\n\n\thlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);\n\n\tif (data[IFLA_RMNET_FLAGS]) {\n\t\tstruct ifla_rmnet_flags *flags;\n\n\t\tflags = nla_data(data[IFLA_RMNET_FLAGS]);\n\t\tdata_format = flags->flags & flags->mask;\n\t}\n\n\tnetdev_dbg(dev, \"data format [0x%08X]\\n\", data_format);\n\tport->data_format = data_format;\n\n\treturn 0;\n\nerr2:\n\tunregister_netdevice(dev);\n\trmnet_vnd_dellink(mux_id, port, ep);\nerr1:\n\trmnet_unregister_real_device(real_dev);\nerr0:\n\tkfree(ep);\n\treturn err;\n}\n\nstatic void rmnet_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct net_device *real_dev, *bridge_dev;\n\tstruct rmnet_port *real_port, *bridge_port;\n\tstruct rmnet_endpoint *ep;\n\tu8 mux_id = priv->mux_id;\n\n\treal_dev = priv->real_dev;\n\n\tif (!rmnet_is_real_dev_registered(real_dev))\n\t\treturn;\n\n\treal_port = rmnet_get_port_rtnl(real_dev);\n\tbridge_dev = real_port->bridge_ep;\n\tif (bridge_dev) {\n\t\tbridge_port = rmnet_get_port_rtnl(bridge_dev);\n\t\trmnet_unregister_bridge(bridge_port);\n\t}\n\n\tep = rmnet_get_endpoint(real_port, mux_id);\n\tif (ep) {\n\t\thlist_del_init_rcu(&ep->hlnode);\n\t\trmnet_vnd_dellink(mux_id, real_port, ep);\n\t\tkfree(ep);\n\t}\n\n\tnetdev_upper_dev_unlink(real_dev, dev);\n\trmnet_unregister_real_device(real_dev);\n\tunregister_netdevice_queue(dev, head);\n}\n\nstatic void rmnet_force_unassociate_device(struct net_device *real_dev)\n{\n\tstruct hlist_node *tmp_ep;\n\tstruct rmnet_endpoint *ep;\n\tstruct rmnet_port *port;\n\tunsigned long bkt_ep;\n\tLIST_HEAD(list);\n\n\tport = rmnet_get_port_rtnl(real_dev);\n\n\tif (port->nr_rmnet_devs) {\n\t\t/* real device */\n\t\trmnet_unregister_bridge(port);\n\t\thash_for_each_safe(port->muxed_ep, bkt_ep, tmp_ep, ep, hlnode) {\n\t\t\tunregister_netdevice_queue(ep->egress_dev, &list);\n\t\t\tnetdev_upper_dev_unlink(real_dev, ep->egress_dev);\n\t\t\trmnet_vnd_dellink(ep->mux_id, port, ep);\n\t\t\thlist_del_init_rcu(&ep->hlnode);\n\t\t\tkfree(ep);\n\t\t}\n\t\trmnet_unregister_real_device(real_dev);\n\t\tunregister_netdevice_many(&list);\n\t} else {\n\t\trmnet_unregister_bridge(port);\n\t}\n}\n\nstatic int rmnet_config_notify_cb(struct notifier_block *nb,\n\t\t\t\t  unsigned long event, void *data)\n{\n\tstruct net_device *real_dev = netdev_notifier_info_to_dev(data);\n\n\tif (!rmnet_is_real_dev_registered(real_dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tnetdev_dbg(real_dev, \"Kernel unregister\\n\");\n\t\trmnet_force_unassociate_device(real_dev);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rmnet_dev_notifier __read_mostly = {\n\t.notifier_call = rmnet_config_notify_cb,\n};\n\nstatic int rmnet_rtnl_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tu16 mux_id;\n\n\tif (!data || !data[IFLA_RMNET_MUX_ID])\n\t\treturn -EINVAL;\n\n\tmux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);\n\tif (mux_id > (RMNET_MAX_LOGICAL_EP - 1))\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nstatic int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t    struct nlattr *data[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct net_device *real_dev;\n\tstruct rmnet_port *port;\n\tu16 mux_id;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\treal_dev = priv->real_dev;\n\tif (!rmnet_is_real_dev_registered(real_dev))\n\t\treturn -ENODEV;\n\n\tport = rmnet_get_port_rtnl(real_dev);\n\n\tif (data[IFLA_RMNET_MUX_ID]) {\n\t\tmux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);\n\n\t\tif (mux_id != priv->mux_id) {\n\t\t\tstruct rmnet_endpoint *ep;\n\n\t\t\tep = rmnet_get_endpoint(port, priv->mux_id);\n\t\t\tif (!ep)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tif (rmnet_get_endpoint(port, mux_id)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"MUX ID already exists\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\thlist_del_init_rcu(&ep->hlnode);\n\t\t\thlist_add_head_rcu(&ep->hlnode,\n\t\t\t\t\t   &port->muxed_ep[mux_id]);\n\n\t\t\tep->mux_id = mux_id;\n\t\t\tpriv->mux_id = mux_id;\n\t\t}\n\t}\n\n\tif (data[IFLA_RMNET_FLAGS]) {\n\t\tstruct ifla_rmnet_flags *flags;\n\n\t\tflags = nla_data(data[IFLA_RMNET_FLAGS]);\n\t\tport->data_format = flags->flags & flags->mask;\n\t}\n\n\treturn 0;\n}\n\nstatic size_t rmnet_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t/* IFLA_RMNET_MUX_ID */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_RMNET_FLAGS */\n\t\tnla_total_size(sizeof(struct ifla_rmnet_flags));\n}\n\nstatic int rmnet_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct net_device *real_dev;\n\tstruct ifla_rmnet_flags f;\n\tstruct rmnet_port *port;\n\n\treal_dev = priv->real_dev;\n\n\tif (nla_put_u16(skb, IFLA_RMNET_MUX_ID, priv->mux_id))\n\t\tgoto nla_put_failure;\n\n\tif (rmnet_is_real_dev_registered(real_dev)) {\n\t\tport = rmnet_get_port_rtnl(real_dev);\n\t\tf.flags = port->data_format;\n\t} else {\n\t\tf.flags = 0;\n\t}\n\n\tf.mask  = ~0;\n\n\tif (nla_put(skb, IFLA_RMNET_FLAGS, sizeof(f), &f))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstruct rtnl_link_ops rmnet_link_ops __read_mostly = {\n\t.kind\t\t= \"rmnet\",\n\t.maxtype\t= __IFLA_RMNET_MAX,\n\t.priv_size\t= sizeof(struct rmnet_priv),\n\t.setup\t\t= rmnet_vnd_setup,\n\t.validate\t= rmnet_rtnl_validate,\n\t.newlink\t= rmnet_newlink,\n\t.dellink\t= rmnet_dellink,\n\t.get_size\t= rmnet_get_size,\n\t.changelink     = rmnet_changelink,\n\t.policy\t\t= rmnet_policy,\n\t.fill_info\t= rmnet_fill_info,\n};\n\nstruct rmnet_port *rmnet_get_port_rcu(struct net_device *real_dev)\n{\n\tif (rmnet_is_real_dev_registered(real_dev))\n\t\treturn rcu_dereference_bh(real_dev->rx_handler_data);\n\telse\n\t\treturn NULL;\n}\n\nstruct rmnet_endpoint *rmnet_get_endpoint(struct rmnet_port *port, u8 mux_id)\n{\n\tstruct rmnet_endpoint *ep;\n\n\thlist_for_each_entry_rcu(ep, &port->muxed_ep[mux_id], hlnode) {\n\t\tif (ep->mux_id == mux_id)\n\t\t\treturn ep;\n\t}\n\n\treturn NULL;\n}\n\nint rmnet_add_bridge(struct net_device *rmnet_dev,\n\t\t     struct net_device *slave_dev,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct rmnet_priv *priv = netdev_priv(rmnet_dev);\n\tstruct net_device *real_dev = priv->real_dev;\n\tstruct rmnet_port *port, *slave_port;\n\tint err;\n\n\tport = rmnet_get_port_rtnl(real_dev);\n\n\t/* If there is more than one rmnet dev attached, its probably being\n\t * used for muxing. Skip the briding in that case\n\t */\n\tif (port->nr_rmnet_devs > 1)\n\t\treturn -EINVAL;\n\n\tif (rmnet_is_real_dev_registered(slave_dev))\n\t\treturn -EBUSY;\n\n\terr = rmnet_register_real_device(slave_dev, extack);\n\tif (err)\n\t\treturn -EBUSY;\n\n\terr = netdev_master_upper_dev_link(slave_dev, rmnet_dev, NULL, NULL,\n\t\t\t\t\t   extack);\n\tif (err) {\n\t\trmnet_unregister_real_device(slave_dev);\n\t\treturn err;\n\t}\n\n\tslave_port = rmnet_get_port_rtnl(slave_dev);\n\tslave_port->rmnet_mode = RMNET_EPMODE_BRIDGE;\n\tslave_port->bridge_ep = real_dev;\n\tslave_port->rmnet_dev = rmnet_dev;\n\n\tport->rmnet_mode = RMNET_EPMODE_BRIDGE;\n\tport->bridge_ep = slave_dev;\n\n\tnetdev_dbg(slave_dev, \"registered with rmnet as slave\\n\");\n\treturn 0;\n}\n\nint rmnet_del_bridge(struct net_device *rmnet_dev,\n\t\t     struct net_device *slave_dev)\n{\n\tstruct rmnet_port *port = rmnet_get_port_rtnl(slave_dev);\n\n\trmnet_unregister_bridge(port);\n\n\tnetdev_dbg(slave_dev, \"removed from rmnet as slave\\n\");\n\treturn 0;\n}\n\n/* Startup/Shutdown */\n\nstatic int __init rmnet_init(void)\n{\n\tint rc;\n\n\trc = register_netdevice_notifier(&rmnet_dev_notifier);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = rtnl_link_register(&rmnet_link_ops);\n\tif (rc != 0) {\n\t\tunregister_netdevice_notifier(&rmnet_dev_notifier);\n\t\treturn rc;\n\t}\n\treturn rc;\n}\n\nstatic void __exit rmnet_exit(void)\n{\n\trtnl_link_unregister(&rmnet_link_ops);\n\tunregister_netdevice_notifier(&rmnet_dev_notifier);\n}\n\nmodule_init(rmnet_init)\nmodule_exit(rmnet_exit)\nMODULE_LICENSE(\"GPL v2\");"}, {"project": "NVD", "target": 1, "code": "#include <stdint.h>\n#include <string.h>\n\n#include \"libavcodec/jpegxl.h\"\n#include \"libavcodec/jpegxl_parse.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/opt.h\"\n\n#include \"avformat.h\"\n#include \"internal.h\"\n\ntypedef struct JXLAnimDemuxContext {\n    AVBufferRef *initial;\n} JXLAnimDemuxContext;\n\nstatic int jpegxl_anim_probe(const AVProbeData *p)\n{\n    uint8_t buffer[4096 + AV_INPUT_BUFFER_PADDING_SIZE];\n    int copied = 0, ret;\n    FFJXLMetadata meta = { 0 };\n\n    /* this is a raw codestream */\n    if (AV_RL16(p->buf) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE) {\n        ret = ff_jpegxl_parse_codestream_header(p->buf, p->buf_size, &meta, 5);\n        if (ret >= 0 && meta.animation_offset > 0)\n            return AVPROBE_SCORE_MAX;\n\n        return 0;\n    }\n\n    /* not a JPEG XL file at all */\n    if (AV_RL64(p->buf) != FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n        return 0;\n\n    if (ff_jpegxl_collect_codestream_header(p->buf, p->buf_size, buffer,\n            sizeof(buffer) - AV_INPUT_BUFFER_PADDING_SIZE, &copied) <= 0\n            || copied <= 0)\n        return 0;\n\n    ret = ff_jpegxl_parse_codestream_header(buffer, copied, &meta, 10);\n    if (ret >= 0 && meta.animation_offset > 0)\n        return AVPROBE_SCORE_MAX;\n\n    return 0;\n}\n\nstatic int jpegxl_anim_read_header(AVFormatContext *s)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint8_t head[256 + AV_INPUT_BUFFER_PADDING_SIZE];\n    const int sizeofhead = sizeof(head) - AV_INPUT_BUFFER_PADDING_SIZE;\n    int headsize = 0, ret;\n    FFJXLMetadata meta = { 0 };\n\n    uint64_t sig16 = avio_rl16(pb);\n    if (sig16 == FF_JPEGXL_CODESTREAM_SIGNATURE_LE) {\n        AV_WL16(head, sig16);\n        headsize = avio_read(s->pb, head + 2, sizeofhead - 2);\n        if (headsize < 0)\n            return headsize;\n        headsize += 2;\n        ctx->initial = av_buffer_alloc(headsize);\n        if (!ctx->initial)\n            return AVERROR(ENOMEM);\n        memcpy(ctx->initial->data, head, headsize);\n    } else {\n        uint64_t sig64 = avio_rl64(pb);\n        sig64 = (sig64 << 16) | sig16;\n        if (sig64 != FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 2); // first box always 12 bytes\n        while (1) {\n            int copied = 0;\n            uint8_t buf[4096];\n            int read = avio_read(pb, buf, sizeof(buf));\n            if (read < 0)\n                return read;\n            if (!ctx->initial) {\n                ctx->initial = av_buffer_alloc(read + 12);\n                if (!ctx->initial)\n                    return AVERROR(ENOMEM);\n                AV_WL64(ctx->initial->data, FF_JPEGXL_CONTAINER_SIGNATURE_LE);\n                AV_WL32(ctx->initial->data + 8, 0x0a870a0d);\n            } else {\n                /* this only should be happening zero or one times in practice */\n                if (av_buffer_realloc(&ctx->initial, ctx->initial->size + read) < 0)\n                    return AVERROR(ENOMEM);\n            }\n            ff_jpegxl_collect_codestream_header(buf, read, head + headsize, sizeofhead - headsize, &copied);\n            memcpy(ctx->initial->data + (ctx->initial->size - read), buf, read);\n            headsize += copied;\n            if (headsize >= sizeofhead || read < sizeof(buf))\n                break;\n        }\n    }\n\n    /* offset in bits of the animation header */\n    ret = ff_jpegxl_parse_codestream_header(head, headsize, &meta, 0);\n    if (ret < 0 || meta.animation_offset <= 0)\n        return AVERROR_INVALIDDATA;\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_JPEGXL;\n    avpriv_set_pts_info(st, 1, meta.timebase.num, meta.timebase.den);\n    ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;\n\n    return 0;\n}\n\n/* the decoder requires the full input file as a single packet */\nstatic int jpegxl_anim_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret;\n    int64_t size;\n    size_t offset = 0;\n\n    size = avio_size(pb);\n    if (size < 0)\n        return size;\n    if (size == 0)\n        size = 4096;\n\n    if (ctx->initial && size < ctx->initial->size)\n        size = ctx->initial->size;\n\n    ret = av_new_packet(pkt, size);\n    if (ret < 0)\n        return ret;\n\n    if (ctx->initial) {\n        offset = ctx->initial->size;\n        memcpy(pkt->data, ctx->initial->data, offset);\n        av_buffer_unref(&ctx->initial);\n    }\n\n    ret = avio_read(pb, pkt->data + offset, size - offset);\n    if (ret < 0)\n        return ret;\n    if (ret < size - offset)\n        pkt->size = ret + offset;\n\n    return 0;\n}\n\nstatic int jpegxl_anim_close(AVFormatContext *s)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    if (ctx->initial)\n        av_buffer_unref(&ctx->initial);\n\n    return 0;\n}\n\nconst AVInputFormat ff_jpegxl_anim_demuxer = {\n    .name           = \"jpegxl_anim\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Animated JPEG XL\"),\n    .priv_data_size = sizeof(JXLAnimDemuxContext),\n    .read_probe     = jpegxl_anim_probe,\n    .read_header    = jpegxl_anim_read_header,\n    .read_packet    = jpegxl_anim_read_packet,\n    .read_close     = jpegxl_anim_close,\n    .flags_internal = FF_FMT_INIT_CLEANUP,\n    .flags          = AVFMT_GENERIC_INDEX | AVFMT_NOTIMESTAMPS,\n    .mime_type      = \"image/jxl\",\n    .extensions     = \"jxl\",\n};"}, {"project": "NVD", "target": 1, "code": "static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        /* invalid ISOBMFF size */\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    return 0;\n}\n\nstatic int jpegxl_parse(AVCodecParserContext *s, AVCodecContext *avctx,\n                        const uint8_t **poutbuf, int *poutbuf_size,\n                        const uint8_t *buf, int buf_size)\n{\n    JXLParseContext *ctx = s->priv_data;\n    int next = END_NOT_FOUND, ret;\n\n    *poutbuf_size = 0;\n    *poutbuf = NULL;\n\n    if (!ctx->pc.index)\n        goto flush;\n\n    if ((!ctx->container || !ctx->codestream_length) && !ctx->next) {\n        ret = try_parse(s, avctx, ctx, ctx->pc.buffer, ctx->pc.index);\n        if (ret < 0)\n            goto flush;\n        ctx->next = ret;\n        if (ctx->container)\n            ctx->skip += ctx->next;\n    }\n\n    if (ctx->container && ctx->next >= 0) {\n        ret = skip_boxes(ctx, ctx->pc.buffer, ctx->pc.index);\n        if (ret < 0) {\n            if (ret == AVERROR_INVALIDDATA)\n                ctx->next = -1;\n            goto flush;\n        }\n        ctx->next = ret + ctx->skip;\n    }\n\n    if (ctx->next >= 0)\n        next = ctx->next - ctx->pc.index;\n\nflush:\n    if (next > buf_size)\n        next = END_NOT_FOUND;\n\n    ret = ff_combine_frame(&ctx->pc, next, &buf, &buf_size);\n    if (ret < 0)\n        return buf_size;\n\n    *poutbuf      = buf;\n    *poutbuf_size = buf_size;\n\n    ctx->codestream_length = 0;\n    ctx->collected_size = 0;\n    ctx->container = 0;\n    ctx->copied = 0;\n    ctx->skip = 0;\n    ctx->skipped_icc = 0;\n    ctx->next = 0;\n    memset(&ctx->codestream, 0, sizeof(ctx->codestream));\n\n    return next;\n}\n\nconst AVCodecParser ff_jpegxl_parser = {\n    .codec_ids      = { AV_CODEC_ID_JPEGXL },\n    .priv_data_size = sizeof(JXLParseContext),\n    .parser_parse   = jpegxl_parse,\n    .parser_close   = ff_parse_close,\n};"}, {"project": "NVD", "target": 1, "code": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n\n    if (ctx->internal->source_frames) {\n        /* A derived frame context is already initialised. */\n        return 0;\n    }\n\n    /* validate the pixel format */\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n\n    /* validate the dimensions */\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n\n    /* format-specific init */\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            goto fail;\n    }\n\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n\n    /* preallocate the frames in the pool, if requested */\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            goto fail;\n    }\n\n    return 0;\nfail:\n    if (ctx->internal->hw_type->frames_uninit)\n        ctx->internal->hw_type->frames_uninit(ctx);\n    return ret;\n}"}, {"project": "NVD", "target": 1, "code": "static int FUNC(pps) (CodedBitstreamContext *ctx, RWContext *rw,\n                      H266RawPPS *current)\n{\n    CodedBitstreamH266Context *h266 = ctx->priv_data;\n    const H266RawSPS *sps;\n    int err, i;\n    unsigned int min_cb_size_y, divisor, ctb_size_y,\n        pic_width_in_ctbs_y, pic_height_in_ctbs_y;\n    uint8_t sub_width_c, sub_height_c, qp_bd_offset;\n\n    static const uint8_t h266_sub_width_c[] = {\n        1, 2, 2, 1\n    };\n    static const uint8_t h266_sub_height_c[] = {\n        1, 2, 1, 1\n    };\n\n    HEADER(\"Picture Parameter Set\");\n\n    CHECK(FUNC(nal_unit_header) (ctx, rw,\n                                 &current->nal_unit_header, VVC_PPS_NUT));\n\n    ub(6, pps_pic_parameter_set_id);\n    ub(4, pps_seq_parameter_set_id);\n    sps = h266->sps[current->pps_seq_parameter_set_id];\n    if (!sps) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"SPS id %d not available.\\n\",\n               current->pps_seq_parameter_set_id);\n        return AVERROR_INVALIDDATA;\n    }\n\n    flag(pps_mixed_nalu_types_in_pic_flag);\n    ue(pps_pic_width_in_luma_samples,\n       1, sps->sps_pic_width_max_in_luma_samples);\n    ue(pps_pic_height_in_luma_samples,\n       1, sps->sps_pic_height_max_in_luma_samples);\n\n    min_cb_size_y = 1 << (sps->sps_log2_min_luma_coding_block_size_minus2 + 2);\n    divisor = FFMAX(min_cb_size_y, 8);\n    if (current->pps_pic_width_in_luma_samples % divisor ||\n        current->pps_pic_height_in_luma_samples % divisor) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR,\n               \"Invalid dimensions: %ux%u not divisible \"\n               \"by %u, MinCbSizeY = %u.\\n\",\n               current->pps_pic_width_in_luma_samples,\n               current->pps_pic_height_in_luma_samples, divisor, min_cb_size_y);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!sps->sps_res_change_in_clvs_allowed_flag &&\n        (current->pps_pic_width_in_luma_samples !=\n         sps->sps_pic_width_max_in_luma_samples ||\n         current->pps_pic_height_in_luma_samples !=\n         sps->sps_pic_height_max_in_luma_samples)) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR,\n               \"Resoltuion change is not allowed, \"\n               \"in max resolution (%ux%u) mismatched with pps(%ux%u).\\n\",\n               sps->sps_pic_width_max_in_luma_samples,\n               sps->sps_pic_height_max_in_luma_samples,\n               current->pps_pic_width_in_luma_samples,\n               current->pps_pic_height_in_luma_samples);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctb_size_y = 1 << (sps->sps_log2_ctu_size_minus5 + 5);\n    if (sps->sps_ref_wraparound_enabled_flag) {\n        if ((ctb_size_y / min_cb_size_y + 1) >\n            (current->pps_pic_width_in_luma_samples / min_cb_size_y - 1)) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"Invalid width(%u), ctb_size_y = %u, min_cb_size_y = %u.\\n\",\n                   current->pps_pic_width_in_luma_samples,\n                   ctb_size_y, min_cb_size_y);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    flag(pps_conformance_window_flag);\n    if (current->pps_pic_width_in_luma_samples ==\n        sps->sps_pic_width_max_in_luma_samples &&\n        current->pps_pic_height_in_luma_samples ==\n        sps->sps_pic_height_max_in_luma_samples &&\n        current->pps_conformance_window_flag) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR,\n               \"Conformance window flag should not true.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sub_width_c = h266_sub_width_c[sps->sps_chroma_format_idc];\n    sub_height_c = h266_sub_height_c[sps->sps_chroma_format_idc];\n    if (current->pps_conformance_window_flag) {\n        ue(pps_conf_win_left_offset, 0, current->pps_pic_width_in_luma_samples);\n        ue(pps_conf_win_right_offset,\n           0, current->pps_pic_width_in_luma_samples);\n        ue(pps_conf_win_top_offset, 0, current->pps_pic_height_in_luma_samples);\n        ue(pps_conf_win_bottom_offset,\n           0, current->pps_pic_height_in_luma_samples);\n        if (sub_width_c *\n            (current->pps_conf_win_left_offset +\n             current->pps_conf_win_right_offset) >=\n            current->pps_pic_width_in_luma_samples ||\n            sub_height_c *\n            (current->pps_conf_win_top_offset +\n             current->pps_conf_win_bottom_offset) >=\n            current->pps_pic_height_in_luma_samples) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"Invalid pps conformance window: (%u, %u, %u, %u), \"\n                   \"resolution is %ux%u, sub wxh is %ux%u.\\n\",\n                   current->pps_conf_win_left_offset,\n                   current->pps_conf_win_right_offset,\n                   current->pps_conf_win_top_offset,\n                   current->pps_conf_win_bottom_offset,\n                   current->pps_pic_width_in_luma_samples,\n                   current->pps_pic_height_in_luma_samples,\n                   sub_width_c, sub_height_c);\n            return AVERROR_INVALIDDATA;\n        }\n    } else {\n        if (current->pps_pic_width_in_luma_samples ==\n            sps->sps_pic_width_max_in_luma_samples &&\n            current->pps_pic_height_in_luma_samples ==\n            sps->sps_pic_height_max_in_luma_samples) {\n            infer(pps_conf_win_left_offset, sps->sps_conf_win_left_offset);\n            infer(pps_conf_win_right_offset, sps->sps_conf_win_right_offset);\n            infer(pps_conf_win_top_offset, sps->sps_conf_win_top_offset);\n            infer(pps_conf_win_bottom_offset, sps->sps_conf_win_bottom_offset);\n        } else {\n            infer(pps_conf_win_left_offset, 0);\n            infer(pps_conf_win_right_offset, 0);\n            infer(pps_conf_win_top_offset, 0);\n            infer(pps_conf_win_bottom_offset, 0);\n        }\n\n    }\n\n    flag(pps_scaling_window_explicit_signalling_flag);\n    if (!sps->sps_ref_pic_resampling_enabled_flag &&\n        current->pps_scaling_window_explicit_signalling_flag) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR,\n               \"Invalid data: sps_ref_pic_resampling_enabled_flag is false, \"\n               \"but pps_scaling_window_explicit_signalling_flag is true.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (current->pps_scaling_window_explicit_signalling_flag) {\n        se(pps_scaling_win_left_offset,\n           -current->pps_pic_width_in_luma_samples * 15 / sub_width_c,\n           current->pps_pic_width_in_luma_samples / sub_width_c);\n        se(pps_scaling_win_right_offset,\n           -current->pps_pic_width_in_luma_samples * 15 / sub_width_c,\n           current->pps_pic_width_in_luma_samples / sub_width_c);\n        se(pps_scaling_win_top_offset,\n           -current->pps_pic_height_in_luma_samples * 15 / sub_height_c,\n           current->pps_pic_height_in_luma_samples / sub_height_c);\n        se(pps_scaling_win_bottom_offset,\n           -current->pps_pic_height_in_luma_samples * 15 / sub_height_c,\n           current->pps_pic_height_in_luma_samples / sub_height_c);\n    } else {\n        infer(pps_scaling_win_left_offset, current->pps_conf_win_left_offset);\n        infer(pps_scaling_win_right_offset, current->pps_conf_win_right_offset);\n        infer(pps_scaling_win_top_offset, current->pps_conf_win_top_offset);\n        infer(pps_scaling_win_bottom_offset, current->pps_conf_win_bottom_offset);\n    }\n\n    flag(pps_output_flag_present_flag);\n    flag(pps_no_pic_partition_flag);\n    flag(pps_subpic_id_mapping_present_flag);\n\n    if (current->pps_subpic_id_mapping_present_flag) {\n        if (!current->pps_no_pic_partition_flag) {\n            ue(pps_num_subpics_minus1,\n               sps->sps_num_subpics_minus1, sps->sps_num_subpics_minus1);\n        } else {\n            infer(pps_num_subpics_minus1, 0);\n        }\n        ue(pps_subpic_id_len_minus1, sps->sps_subpic_id_len_minus1,\n           sps->sps_subpic_id_len_minus1);\n        for (i = 0; i <= current->pps_num_subpics_minus1; i++) {\n            ubs(sps->sps_subpic_id_len_minus1 + 1, pps_subpic_id[i], 1, i);\n        }\n    }\n\n    for (i = 0; i <= sps->sps_num_subpics_minus1; i++) {\n        if (sps->sps_subpic_id_mapping_explicitly_signalled_flag)\n            current->sub_pic_id_val[i] = current->pps_subpic_id_mapping_present_flag\n                                       ? current->pps_subpic_id[i]\n                                       : sps->sps_subpic_id[i];\n        else\n            current->sub_pic_id_val[i] = i;\n    }\n\n    pic_width_in_ctbs_y = AV_CEIL_RSHIFT\n        (current->pps_pic_width_in_luma_samples, (sps->sps_log2_ctu_size_minus5 + 5));\n    pic_height_in_ctbs_y = AV_CEIL_RSHIFT(\n        current->pps_pic_height_in_luma_samples,(sps->sps_log2_ctu_size_minus5 + 5));\n    if (!current->pps_no_pic_partition_flag) {\n        unsigned int exp_tile_width = 0, exp_tile_height = 0;\n        unsigned int unified_size, remaining_size;\n\n        u(2, pps_log2_ctu_size_minus5,\n          sps->sps_log2_ctu_size_minus5, sps->sps_log2_ctu_size_minus5);\n        ue(pps_num_exp_tile_columns_minus1,\n           0, FFMIN(pic_width_in_ctbs_y - 1, VVC_MAX_TILE_COLUMNS - 1));\n        ue(pps_num_exp_tile_rows_minus1,\n           0, FFMIN(pic_height_in_ctbs_y - 1, VVC_MAX_TILE_ROWS - 1));\n\n        for (i = 0; i <= current->pps_num_exp_tile_columns_minus1; i++) {\n            ues(pps_tile_column_width_minus1[i],\n                0, pic_width_in_ctbs_y - exp_tile_width - 1, 1, i);\n            exp_tile_width += current->pps_tile_column_width_minus1[i] + 1;\n        }\n        for (i = 0; i <= current->pps_num_exp_tile_rows_minus1; i++) {\n            ues(pps_tile_row_height_minus1[i],\n                0, pic_height_in_ctbs_y - exp_tile_height - 1, 1, i);\n            exp_tile_height += current->pps_tile_row_height_minus1[i] + 1;\n        }\n\n        remaining_size = pic_width_in_ctbs_y;\n        for (i = 0; i <= current->pps_num_exp_tile_columns_minus1; i++) {\n          if (current->pps_tile_column_width_minus1[i] >= remaining_size) {\n              av_log(ctx->log_ctx, AV_LOG_ERROR,\n                     \"Tile column width(%d) exceeds picture width\\n\",i);\n              return AVERROR_INVALIDDATA;\n          }\n          current->col_width_val[i] = current->pps_tile_column_width_minus1[i] + 1;\n          remaining_size -= (current->pps_tile_column_width_minus1[i] + 1);\n        }\n        unified_size = current->pps_tile_column_width_minus1[i - 1] + 1;\n        while (remaining_size > 0) {\n            if (current->num_tile_columns > VVC_MAX_TILE_COLUMNS) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR,\n                       \"NumTileColumns(%d) > than VVC_MAX_TILE_COLUMNS(%d)\\n\",\n                       current->num_tile_columns, VVC_MAX_TILE_COLUMNS);\n                return AVERROR_INVALIDDATA;\n            }\n            unified_size = FFMIN(remaining_size, unified_size);\n            current->col_width_val[i] = unified_size;\n            remaining_size -= unified_size;\n            i++;\n        }\n        current->num_tile_columns = i;\n        if (current->num_tile_columns > VVC_MAX_TILE_COLUMNS) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"NumTileColumns(%d) > than VVC_MAX_TILE_COLUMNS(%d)\\n\",\n                   current->num_tile_columns, VVC_MAX_TILE_COLUMNS);\n            return AVERROR_INVALIDDATA;\n        }\n\n        remaining_size = pic_height_in_ctbs_y;\n        for (i = 0; i <= current->pps_num_exp_tile_rows_minus1; i++) {\n          if (current->pps_tile_row_height_minus1[i] >= remaining_size) {\n              av_log(ctx->log_ctx, AV_LOG_ERROR,\n                     \"Tile row height(%d) exceeds picture height\\n\",i);\n              return AVERROR_INVALIDDATA;\n          }\n          current->row_height_val[i] = current->pps_tile_row_height_minus1[i] + 1;\n          remaining_size -= (current->pps_tile_row_height_minus1[i] + 1);\n        }\n        unified_size = current->pps_tile_row_height_minus1[i - 1] + 1;\n\n        while (remaining_size > 0) {\n            unified_size = FFMIN(remaining_size, unified_size);\n            current->row_height_val[i] = unified_size;\n            remaining_size -= unified_size;\n            i++;\n        }\n        current->num_tile_rows=i;\n        if (current->num_tile_rows > VVC_MAX_TILE_ROWS) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"NumTileRows(%d) > than VVC_MAX_TILE_ROWS(%d)\\n\",\n                   current->num_tile_rows, VVC_MAX_TILE_ROWS);\n            return AVERROR_INVALIDDATA;\n        }\n\n        current->num_tiles_in_pic = current->num_tile_columns *\n                                    current->num_tile_rows;\n        if (current->num_tiles_in_pic > VVC_MAX_TILES_PER_AU) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"NumTilesInPic(%d) > than VVC_MAX_TILES_PER_AU(%d)\\n\",\n                   current->num_tiles_in_pic, VVC_MAX_TILES_PER_AU);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (current->num_tiles_in_pic > 1) {\n            flag(pps_loop_filter_across_tiles_enabled_flag);\n            flag(pps_rect_slice_flag);\n        } else {\n            infer(pps_loop_filter_across_tiles_enabled_flag, 0);\n            infer(pps_rect_slice_flag, 1);\n        }\n        if (current->pps_rect_slice_flag)\n            flag(pps_single_slice_per_subpic_flag);\n        else\n            infer(pps_single_slice_per_subpic_flag, 1);\n        if (current->pps_rect_slice_flag &&\n            !current->pps_single_slice_per_subpic_flag) {\n            int j;\n            uint16_t tile_idx = 0, tile_x, tile_y, ctu_x, ctu_y;\n            uint16_t slice_top_left_ctu_x[VVC_MAX_SLICES];\n            uint16_t slice_top_left_ctu_y[VVC_MAX_SLICES];\n            ue(pps_num_slices_in_pic_minus1, 0, VVC_MAX_SLICES - 1);\n            if (current->pps_num_slices_in_pic_minus1 > 1)\n                flag(pps_tile_idx_delta_present_flag);\n            else\n                infer(pps_tile_idx_delta_present_flag, 0);\n            for (i = 0; i < current->pps_num_slices_in_pic_minus1; i++) {\n                tile_x = tile_idx % current->num_tile_columns;\n                tile_y = tile_idx / current->num_tile_columns;\n                if (tile_x != current->num_tile_columns - 1) {\n                    ues(pps_slice_width_in_tiles_minus1[i],\n                        0, current->num_tile_columns - 1, 1, i);\n                } else {\n                    infer(pps_slice_width_in_tiles_minus1[i], 0);\n                }\n                if (tile_y != current->num_tile_rows - 1 &&\n                    (current->pps_tile_idx_delta_present_flag || tile_x == 0)) {\n                    ues(pps_slice_height_in_tiles_minus1[i],\n                        0, current->num_tile_rows - 1, 1, i);\n                } else {\n                    if (tile_y == current->num_tile_rows - 1)\n                        infer(pps_slice_height_in_tiles_minus1[i], 0);\n                    else\n                        infer(pps_slice_height_in_tiles_minus1[i],\n                              current->pps_slice_height_in_tiles_minus1[i - 1]);\n                }\n\n                ctu_x = ctu_y = 0;\n                for (j = 0; j < tile_x; j++) {\n                    ctu_x += current->col_width_val[j];\n                }\n                for (j = 0; j < tile_y; j++) {\n                    ctu_y += current->row_height_val[j];\n                }\n                if (current->pps_slice_width_in_tiles_minus1[i] == 0 &&\n                    current->pps_slice_height_in_tiles_minus1[i] == 0 &&\n                    current->row_height_val[tile_y] > 1) {\n                    int num_slices_in_tile,\n                        uniform_slice_height, remaining_height_in_ctbs_y;\n                    remaining_height_in_ctbs_y =\n                        current->row_height_val[tile_y];\n                    ues(pps_num_exp_slices_in_tile[i],\n                        0, current->row_height_val[tile_y] - 1, 1, i);\n                    if (current->pps_num_exp_slices_in_tile[i] == 0) {\n                        num_slices_in_tile = 1;\n                        current->slice_height_in_ctus[i] = current->row_height_val[tile_y];\n                        slice_top_left_ctu_x[i] = ctu_x;\n                        slice_top_left_ctu_y[i] = ctu_y;\n                    } else {\n                        uint16_t slice_height_in_ctus;\n                        for (j = 0; j < current->pps_num_exp_slices_in_tile[i];\n                             j++) {\n                            ues(pps_exp_slice_height_in_ctus_minus1[i][j], 0,\n                                current->row_height_val[tile_y] - 1, 2,\n                                i, j);\n                            slice_height_in_ctus =\n                                current->\n                                pps_exp_slice_height_in_ctus_minus1[i][j] + 1;\n\n                            current->slice_height_in_ctus[i + j] =\n                                slice_height_in_ctus;\n                            slice_top_left_ctu_x[i + j] = ctu_x;\n                            slice_top_left_ctu_y[i + j] = ctu_y;\n                            ctu_y += slice_height_in_ctus;\n\n                            remaining_height_in_ctbs_y -= slice_height_in_ctus;\n                        }\n                        uniform_slice_height = 1 +\n                            (j == 0 ? current->row_height_val[tile_y] - 1:\n                            current->pps_exp_slice_height_in_ctus_minus1[i][j-1]);\n                        while (remaining_height_in_ctbs_y > uniform_slice_height) {\n                            current->slice_height_in_ctus[i + j] =\n                                                          uniform_slice_height;\n                            slice_top_left_ctu_x[i + j] = ctu_x;\n                            slice_top_left_ctu_y[i + j] = ctu_y;\n                            ctu_y += uniform_slice_height;\n\n                            remaining_height_in_ctbs_y -= uniform_slice_height;\n                            j++;\n                        }\n                        if (remaining_height_in_ctbs_y > 0) {\n                            current->slice_height_in_ctus[i + j] =\n                                remaining_height_in_ctbs_y;\n                            slice_top_left_ctu_x[i + j] = ctu_x;\n                            slice_top_left_ctu_y[i + j] = ctu_y;\n                            j++;\n                        }\n                        num_slices_in_tile = j;\n                    }\n                    i += num_slices_in_tile - 1;\n                } else {\n                    uint16_t height = 0;\n                    infer(pps_num_exp_slices_in_tile[i], 0);\n                    for (j = 0;\n                         j <= current->pps_slice_height_in_tiles_minus1[i];\n                         j++) {\n                        height +=\n                           current->row_height_val[tile_y + j];\n                    }\n                    current->slice_height_in_ctus[i] = height;\n\n                    slice_top_left_ctu_x[i] = ctu_x;\n                    slice_top_left_ctu_y[i] = ctu_y;\n                }\n                if (i < current->pps_num_slices_in_pic_minus1) {\n                    if (current->pps_tile_idx_delta_present_flag) {\n                        ses(pps_tile_idx_delta_val[i],\n                            -current->num_tiles_in_pic + 1,\n                            current->num_tiles_in_pic - 1, 1, i);\n                        if (current->pps_tile_idx_delta_val[i] == 0) {\n                            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                                   \"pps_tile_idx_delta_val[i] shall not be equal to 0.\\n\");\n                        }\n                        tile_idx += current->pps_tile_idx_delta_val[i];\n                    } else {\n                        infer(pps_tile_idx_delta_val[i], 0);\n                        tile_idx +=\n                            current->pps_slice_width_in_tiles_minus1[i] + 1;\n                        if (tile_idx % current->num_tile_columns == 0) {\n                            tile_idx +=\n                                current->pps_slice_height_in_tiles_minus1[i] *\n                                current->num_tile_columns;\n                        }\n                    }\n                }\n            }\n            if (i == current->pps_num_slices_in_pic_minus1) {\n                uint16_t height = 0;\n\n                tile_x = tile_idx % current->num_tile_columns;\n                tile_y = tile_idx / current->num_tile_columns;\n\n                ctu_x = 0, ctu_y = 0;\n                for (j = 0; j < tile_x; j++) {\n                    ctu_x += current->col_width_val[j];\n                }\n                for (j = 0; j < tile_y; j++) {\n                    ctu_y += current->row_height_val[j];\n                }\n                slice_top_left_ctu_x[i] = ctu_x;\n                slice_top_left_ctu_y[i] = ctu_y;\n\n                current->pps_slice_width_in_tiles_minus1[i] =\n                    current->num_tile_columns - tile_x - 1;\n                current->pps_slice_height_in_tiles_minus1[i] =\n                    current->num_tile_rows - tile_y - 1;\n\n                for (j = 0; j <= current->pps_slice_height_in_tiles_minus1[i];\n                     j++) {\n                    height +=\n                        current->row_height_val[tile_y + j];\n                }\n                current->slice_height_in_ctus[i] = height;\n\n                infer(pps_num_exp_slices_in_tile[i], 0);\n            }\n            //now, we got all slice information, let's resolve NumSlicesInSubpic\n            for (i = 0; i <= sps->sps_num_subpics_minus1; i++) {\n                current->num_slices_in_subpic[i] = 0;\n                for (j = 0; j <= current->pps_num_slices_in_pic_minus1; j++) {\n                    uint16_t pos_x = 0, pos_y = 0;\n                    pos_x = slice_top_left_ctu_x[j];\n                    pos_y = slice_top_left_ctu_y[j];\n                    if ((pos_x >= sps->sps_subpic_ctu_top_left_x[i]) &&\n                        (pos_x <\n                         sps->sps_subpic_ctu_top_left_x[i] +\n                         sps->sps_subpic_width_minus1[i] + 1) &&\n                         (pos_y >= sps->sps_subpic_ctu_top_left_y[i]) &&\n                         (pos_y < sps->sps_subpic_ctu_top_left_y[i] +\n                            sps->sps_subpic_height_minus1[i] + 1)) {\n                        current->num_slices_in_subpic[i]++;\n                    }\n                }\n            }\n        } else {\n            if (current->pps_no_pic_partition_flag)\n                infer(pps_num_slices_in_pic_minus1, 0);\n            else if (current->pps_single_slice_per_subpic_flag)\n                infer(pps_num_slices_in_pic_minus1,\n                      sps->sps_num_subpics_minus1);\n            // else?\n        }\n        if (!current->pps_rect_slice_flag ||\n            current->pps_single_slice_per_subpic_flag ||\n            current->pps_num_slices_in_pic_minus1 > 0)\n            flag(pps_loop_filter_across_slices_enabled_flag);\n        else\n            infer(pps_loop_filter_across_slices_enabled_flag, 0);\n    } else {\n        infer(pps_num_exp_tile_columns_minus1, 0);\n        infer(pps_tile_column_width_minus1[0], pic_width_in_ctbs_y - 1);\n        infer(pps_num_exp_tile_rows_minus1, 0);\n        infer(pps_tile_row_height_minus1[0], pic_height_in_ctbs_y - 1);\n        current->col_width_val[0] = pic_width_in_ctbs_y;\n        current->row_height_val[0] = pic_height_in_ctbs_y;\n        current->num_tile_columns = 1;\n        current->num_tile_rows = 1;\n        current->num_tiles_in_pic = 1;\n    }\n\n    flag(pps_cabac_init_present_flag);\n    for (i = 0; i < 2; i++)\n        ues(pps_num_ref_idx_default_active_minus1[i], 0, 14, 1, i);\n    flag(pps_rpl1_idx_present_flag);\n    flag(pps_weighted_pred_flag);\n    flag(pps_weighted_bipred_flag);\n    flag(pps_ref_wraparound_enabled_flag);\n    if (current->pps_ref_wraparound_enabled_flag) {\n        ue(pps_pic_width_minus_wraparound_offset,\n           0, (current->pps_pic_width_in_luma_samples / min_cb_size_y)\n           - (ctb_size_y / min_cb_size_y) - 2);\n    }\n\n    qp_bd_offset = 6 * sps->sps_bitdepth_minus8;\n    se(pps_init_qp_minus26, -(26 + qp_bd_offset), 37);\n    flag(pps_cu_qp_delta_enabled_flag);\n    flag(pps_chroma_tool_offsets_present_flag);\n    if (current->pps_chroma_tool_offsets_present_flag) {\n        se(pps_cb_qp_offset, -12, 12);\n        se(pps_cr_qp_offset, -12, 12);\n        flag(pps_joint_cbcr_qp_offset_present_flag);\n        if (current->pps_joint_cbcr_qp_offset_present_flag)\n            se(pps_joint_cbcr_qp_offset_value, -12, 12);\n        else\n            infer(pps_joint_cbcr_qp_offset_value, 0);\n        flag(pps_slice_chroma_qp_offsets_present_flag);\n        flag(pps_cu_chroma_qp_offset_list_enabled_flag);\n        if (current->pps_cu_chroma_qp_offset_list_enabled_flag) {\n            ue(pps_chroma_qp_offset_list_len_minus1, 0, 5);\n            for (i = 0; i <= current->pps_chroma_qp_offset_list_len_minus1; i++) {\n                ses(pps_cb_qp_offset_list[i], -12, 12, 1, i);\n                ses(pps_cr_qp_offset_list[i], -12, 12, 1, i);\n                if (current->pps_joint_cbcr_qp_offset_present_flag)\n                    ses(pps_joint_cbcr_qp_offset_list[i], -12, 12, 1, i);\n                else\n                    infer(pps_joint_cbcr_qp_offset_list[i], 0);\n            }\n        }\n    } else {\n        infer(pps_cb_qp_offset, 0);\n        infer(pps_cr_qp_offset, 0);\n        infer(pps_joint_cbcr_qp_offset_present_flag, 0);\n        infer(pps_joint_cbcr_qp_offset_value, 0);\n        infer(pps_slice_chroma_qp_offsets_present_flag, 0);\n        infer(pps_cu_chroma_qp_offset_list_enabled_flag, 0);\n    }\n    flag(pps_deblocking_filter_control_present_flag);\n    if (current->pps_deblocking_filter_control_present_flag) {\n        flag(pps_deblocking_filter_override_enabled_flag);\n        flag(pps_deblocking_filter_disabled_flag);\n        if (!current->pps_no_pic_partition_flag &&\n            current->pps_deblocking_filter_override_enabled_flag)\n            flag(pps_dbf_info_in_ph_flag);\n        else\n            infer(pps_dbf_info_in_ph_flag, 0);\n        if (!current->pps_deblocking_filter_disabled_flag) {\n            se(pps_luma_beta_offset_div2, -12, 12);\n            se(pps_luma_tc_offset_div2, -12, 12);\n            if (current->pps_chroma_tool_offsets_present_flag) {\n                se(pps_cb_beta_offset_div2, -12, 12);\n                se(pps_cb_tc_offset_div2, -12, 12);\n                se(pps_cr_beta_offset_div2, -12, 12);\n                se(pps_cr_tc_offset_div2, -12, 12);\n            } else {\n                infer(pps_cb_beta_offset_div2,\n                      current->pps_luma_beta_offset_div2);\n                infer(pps_cb_tc_offset_div2, current->pps_luma_tc_offset_div2);\n                infer(pps_cr_beta_offset_div2,\n                      current->pps_luma_beta_offset_div2);\n                infer(pps_cr_tc_offset_div2, current->pps_luma_tc_offset_div2);\n            }\n        } else {\n            infer(pps_luma_beta_offset_div2, 0);\n            infer(pps_luma_tc_offset_div2, 0);\n            infer(pps_cb_beta_offset_div2, 0);\n            infer(pps_cb_tc_offset_div2, 0);\n            infer(pps_cr_beta_offset_div2, 0);\n            infer(pps_cr_tc_offset_div2, 0);\n        }\n    } else {\n        infer(pps_deblocking_filter_override_enabled_flag, 0);\n        infer(pps_deblocking_filter_disabled_flag, 0);\n        infer(pps_dbf_info_in_ph_flag, 0);\n        infer(pps_luma_beta_offset_div2, 0);\n        infer(pps_luma_tc_offset_div2, 0);\n        infer(pps_cb_beta_offset_div2, 0);\n        infer(pps_cb_tc_offset_div2, 0);\n        infer(pps_cr_beta_offset_div2, 0);\n        infer(pps_cr_tc_offset_div2, 0);\n    }\n\n    if (!current->pps_no_pic_partition_flag) {\n        flag(pps_rpl_info_in_ph_flag);\n        flag(pps_sao_info_in_ph_flag);\n        flag(pps_alf_info_in_ph_flag);\n        if ((current->pps_weighted_pred_flag ||\n             current->pps_weighted_bipred_flag) &&\n            current->pps_rpl_info_in_ph_flag)\n            flag(pps_wp_info_in_ph_flag);\n        flag(pps_qp_delta_info_in_ph_flag);\n    }\n    flag(pps_picture_header_extension_present_flag);\n    flag(pps_slice_header_extension_present_flag);\n\n    flag(pps_extension_flag);\n    if (current->pps_extension_flag)\n        CHECK(FUNC(extension_data) (ctx, rw, &current->extension_data));\n\n    CHECK(FUNC(rbsp_trailing_bits) (ctx, rw));\n    return 0;\n}"}, {"project": "NVD", "target": 1, "code": "static void draw_block_rectangle(uint8_t *buf, int sx, int sy, int w, int h, ptrdiff_t stride, int color)\n{\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n\n    for (int y = sy; y < sy + h; y++) {\n        buf[sx] = color;\n        buf[sx + w - 1] = color;\n        buf += stride;\n    }\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n}\n\nstatic int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext *ctx = inlink->dst;\n    CodecViewContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    if (s->qp) {\n        enum AVVideoEncParamsType qp_type;\n        int qstride, ret;\n        int8_t *qp_table;\n\n        ret = ff_qp_table_extract(frame, &qp_table, &qstride, NULL, &qp_type);\n        if (ret < 0) {\n            av_frame_free(&frame);\n            return ret;\n        }\n\n        if (qp_table) {\n            int x, y;\n            const int w = AV_CEIL_RSHIFT(frame->width,  s->hsub);\n            const int h = AV_CEIL_RSHIFT(frame->height, s->vsub);\n            uint8_t *pu = frame->data[1];\n            uint8_t *pv = frame->data[2];\n            const ptrdiff_t lzu = frame->linesize[1];\n            const ptrdiff_t lzv = frame->linesize[2];\n\n            for (y = 0; y < h; y++) {\n                for (x = 0; x < w; x++) {\n                    const int qp = ff_norm_qscale(qp_table[(y >> 3) * qstride + (x >> 3)], qp_type) * 128/31;\n                    pu[x] = pv[x] = qp;\n                }\n                pu += lzu;\n                pv += lzv;\n            }\n        }\n        av_freep(&qp_table);\n    }\n\n    if (s->block) {\n        AVFrameSideData *sd = av_frame_get_side_data(frame, AV_FRAME_DATA_VIDEO_ENC_PARAMS);\n        if (sd) {\n            AVVideoEncParams *par = (AVVideoEncParams*)sd->data;\n            const ptrdiff_t stride = frame->linesize[0];\n\n            if (par->nb_blocks) {\n                for (int block_idx = 0; block_idx < par->nb_blocks; block_idx++) {\n                    AVVideoBlockParams *b = av_video_enc_params_block(par, block_idx);\n                    uint8_t *buf = frame->data[0] + b->src_y * stride;\n\n                    draw_block_rectangle(buf, b->src_x, b->src_y, b->w, b->h, stride, 100);\n                }\n            }\n        }\n    }\n\n    if (s->mv || s->mv_type) {\n        AVFrameSideData *sd = av_frame_get_side_data(frame, AV_FRAME_DATA_MOTION_VECTORS);\n        if (sd) {\n            int i;\n            const AVMotionVector *mvs = (const AVMotionVector *)sd->data;\n            const int is_iframe = (s->frame_type & FRAME_TYPE_I) && frame->pict_type == AV_PICTURE_TYPE_I;\n            const int is_pframe = (s->frame_type & FRAME_TYPE_P) && frame->pict_type == AV_PICTURE_TYPE_P;\n            const int is_bframe = (s->frame_type & FRAME_TYPE_B) && frame->pict_type == AV_PICTURE_TYPE_B;\n\n            for (i = 0; i < sd->size / sizeof(*mvs); i++) {\n                const AVMotionVector *mv = &mvs[i];\n                const int direction = mv->source > 0;\n\n                if (s->mv_type) {\n                    const int is_fp = direction == 0 && (s->mv_type & MV_TYPE_FOR);\n                    const int is_bp = direction == 1 && (s->mv_type & MV_TYPE_BACK);\n\n                    if ((!s->frame_type && (is_fp || is_bp)) ||\n                        is_iframe && is_fp || is_iframe && is_bp ||\n                        is_pframe && is_fp ||\n                        is_bframe && is_fp || is_bframe && is_bp)\n                        draw_arrow(frame->data[0], mv->dst_x, mv->dst_y, mv->src_x, mv->src_y,\n                                   frame->width, frame->height, frame->linesize[0],\n                                   100, 0, direction);\n                } else if (s->mv)\n                    if ((direction == 0 && (s->mv & MV_P_FOR)  && frame->pict_type == AV_PICTURE_TYPE_P) ||\n                        (direction == 0 && (s->mv & MV_B_FOR)  && frame->pict_type == AV_PICTURE_TYPE_B) ||\n                        (direction == 1 && (s->mv & MV_B_BACK) && frame->pict_type == AV_PICTURE_TYPE_B))\n                        draw_arrow(frame->data[0], mv->dst_x, mv->dst_y, mv->src_x, mv->src_y,\n                                   frame->width, frame->height, frame->linesize[0],\n                                   100, 0, direction);\n            }\n        }\n    }\n\n    return ff_filter_frame(outlink, frame);\n}"}, {"project": "NVD", "target": 1, "code": "static int showspectrumpic_request_frame(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    ShowSpectrumContext *s = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    int ret;\n\n    ret = ff_request_frame(inlink);\n    if (ret == AVERROR_EOF && s->outpicref && s->samples > 0) {\n        int consumed = 0;\n        int x = 0, sz = s->orientation == VERTICAL ? s->w : s->h;\n        unsigned int nb_frame = 0;\n        int ch, spf, spb;\n        int src_offset = 0;\n        AVFrame *fin;\n\n        spf = s->win_size * (s->samples / ((s->win_size * sz) * ceil(s->samples / (float)(s->win_size * sz))));\n        spf = FFMAX(1, spf);\n        s->hop_size = spf;\n\n        spb = (s->samples / (spf * sz)) * spf;\n\n        fin = ff_get_audio_buffer(inlink, spf);\n        if (!fin)\n            return AVERROR(ENOMEM);\n\n        while (x < sz) {\n            int acc_samples = 0;\n            int dst_offset = 0;\n\n            while (nb_frame <= s->nb_frames) {\n                AVFrame *cur_frame = s->frames[nb_frame];\n                int cur_frame_samples = cur_frame->nb_samples;\n                int nb_samples = 0;\n\n                if (acc_samples < spf) {\n                    nb_samples = FFMIN(spf - acc_samples, cur_frame_samples - src_offset);\n                    acc_samples += nb_samples;\n                    av_samples_copy(fin->extended_data, cur_frame->extended_data,\n                                    dst_offset, src_offset, nb_samples,\n                                    cur_frame->ch_layout.nb_channels, AV_SAMPLE_FMT_FLTP);\n                }\n\n                src_offset += nb_samples;\n                dst_offset += nb_samples;\n                if (cur_frame_samples <= src_offset) {\n                    av_frame_free(&s->frames[nb_frame]);\n                    nb_frame++;\n                    src_offset = 0;\n                }\n\n                if (acc_samples == spf)\n                    break;\n            }\n\n            ff_filter_execute(ctx, run_channel_fft, fin, NULL, s->nb_display_channels);\n            acalc_magnitudes(s);\n\n            consumed += spf;\n            if (consumed >= spb) {\n                int h = s->orientation == VERTICAL ? s->h : s->w;\n\n                scale_magnitudes(s, 1.f / (consumed / spf));\n                plot_spectrum_column(inlink, fin);\n                consumed = 0;\n                x++;\n                for (ch = 0; ch < s->nb_display_channels; ch++)\n                    memset(s->magnitudes[ch], 0, h * sizeof(float));\n            }\n        }\n\n        av_frame_free(&fin);\n        s->outpicref->pts = 0;\n\n        if (s->legend)\n            draw_legend(ctx, s->samples);\n\n        ret = ff_filter_frame(outlink, s->outpicref);\n        s->outpicref = NULL;\n    }\n\n    return ret;\n}"}, {"project": "NVD", "target": 1, "code": "static int parse_options(struct sbg_parser *p)\n{\n    struct sbg_string ostr, oarg;\n    char mode = 0;\n    int r;\n    char *tptr;\n    double v;\n\n    if (p->cursor == p->end || *p->cursor != '-')\n        return 0;\n    while (lex_char(p, '-') && lex_wsword(p, &ostr)) {\n        for (; ostr.s < ostr.e; ostr.s++) {\n            char opt = *ostr.s;\n            switch (opt) {\n                case 'S':\n                    p->scs.opt_start_at_first = 1;\n                    break;\n                case 'E':\n                    p->scs.opt_end_at_last = 1;\n                    break;\n                case 'i':\n                    mode = 'i';\n                    break;\n                case 'p':\n                    mode = 'p';\n                    break;\n                case 'F':\n                    FORWARD_ERROR(parse_optarg(p, opt, &oarg));\n                    v = strtod(oarg.s, &tptr);\n                    if (oarg.e != tptr) {\n                        snprintf(p->err_msg, sizeof(p->err_msg),\n                                 \"syntax error for option -F\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    p->scs.opt_fade_time = v * AV_TIME_BASE / 1000;\n                    break;\n                case 'L':\n                    FORWARD_ERROR(parse_optarg(p, opt, &oarg));\n                    r = str_to_time(oarg.s, &p->scs.opt_duration);\n                    if (oarg.e != oarg.s + r) {\n                    if (oarg.e != oarg.s + r || p->scs.opt_duration < 0) {\n                        snprintf(p->err_msg, sizeof(p->err_msg),\n                                 \"syntax error for option -L\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    break;\n                case 'T':\n                    FORWARD_ERROR(parse_optarg(p, opt, &oarg));\n                    r = str_to_time(oarg.s, &p->scs.start_ts);\n                    if (oarg.e != oarg.s + r) {\n                        snprintf(p->err_msg, sizeof(p->err_msg),\n                                 \"syntax error for option -T\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    break;\n                case 'm':\n                    FORWARD_ERROR(parse_optarg(p, opt, &oarg));\n                    tptr = av_malloc(oarg.e - oarg.s + 1);\n                    if (!tptr)\n                        return AVERROR(ENOMEM);\n                    memcpy(tptr, oarg.s, oarg.e - oarg.s);\n                    tptr[oarg.e - oarg.s] = 0;\n                    av_free(p->scs.opt_mix);\n                    p->scs.opt_mix = tptr;\n                    break;\n                case 'q':\n                    FORWARD_ERROR(parse_optarg(p, opt, &oarg));\n                    v = strtod(oarg.s, &tptr);\n                    if (oarg.e != tptr) {\n                        snprintf(p->err_msg, sizeof(p->err_msg),\n                                 \"syntax error for option -q\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    if (v != 1) {\n                        snprintf(p->err_msg, sizeof(p->err_msg),\n                                 \"speed factor other than 1 not supported\");\n                        return AVERROR_PATCHWELCOME;\n                    }\n                    break;\n                case 'r':\n                    FORWARD_ERROR(parse_optarg(p, opt, &oarg));\n                    r = strtol(oarg.s, &tptr, 10);\n                    if (oarg.e != tptr) {\n                        snprintf(p->err_msg, sizeof(p->err_msg),\n                                 \"syntax error for option -r\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    if (r < 40) {\n                        snprintf(p->err_msg, sizeof(p->err_msg),\n                                 \"invalid sample rate\");\n                        return AVERROR_PATCHWELCOME;\n                    }\n                    p->scs.sample_rate = r;\n                    break;\n                default:\n                    snprintf(p->err_msg, sizeof(p->err_msg),\n                             \"unknown option: '%c'\", *ostr.s);\n                    return AVERROR_INVALIDDATA;\n            }\n        }\n    }\n    switch (mode) {\n        case 'i':\n            return parse_immediate(p);\n        case 'p':\n            return parse_preprogrammed(p);\n        case 0:\n            if (!lex_line_end(p))\n                return AVERROR_INVALIDDATA;\n            return 1;\n    }\n    return AVERROR_BUG;\n}"}]