[{"type": "no factor", "target": "1", "code": "static AVStream *init_stream(AVFormatContext *s) {    BinDemuxContext *bin = s->priv_data;    AVStream *st = avformat_new_stream(s, NULL);    if (!st)        return NULL;    st->codec->codec_tag = 0;    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    if (!bin->width) {        st->codec->width = (80 << 3);        st->codec->height = (25 << 4);    }    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);    /* simulate tty display speed */    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);    return st;}"}, {"type": "no factor", "target": "1", "code": "static int writev_f(int argc, char **argv) {    struct timeval t1, t2;    int Cflag = 0, qflag = 0;    int c, cnt;    char *buf;    int64_t offset;    /* Some compilers get confused and warn if this is not initialized.  */    int total = 0;    int nr_iov;    int pattern = 0xcd;    QEMUIOVector qiov;    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {        switch (c) {            case 'C':                Cflag = 1;                break;            case 'q':                qflag = 1;                break;            case 'P':                pattern = parse_pattern(optarg);                if (pattern < 0) {                    return 0;                }                break;            default:                return command_usage(&writev_cmd);        }    }    if (optind > argc - 2) {        return command_usage(&writev_cmd);    }    offset = cvtnum(argv[optind]);    if (offset < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    optind++;    if (offset & 0x1ff) {        printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset);        return 0;    }    nr_iov = argc - optind;    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);    if (buf == NULL) {        return 0;    }    gettimeofday(&t1, NULL);    cnt = do_aio_writev(&qiov, offset, &total);    gettimeofday(&t2, NULL);    if (cnt < 0) {        printf(\"writev failed: %s\\n\", strerror(-cnt));        goto out;    }    if (qflag) {        goto out;    }    /* Finally, report back -- -C gives a parsable format */    t2 = tsub(t2, t1);    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);out:    qemu_io_free(buf);    return 0;}"}, {"type": "no factor", "target": "1", "code": "static void virtio_queue_notify_vq(VirtQueue *vq) {    if (vq->vring.desc && vq->handle_output) {        VirtIODevice *vdev = vq->vdev;        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);        vq->handle_output(vdev, vq);    }}"}, {"type": "no factor", "target": "1", "code": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,                                 unsigned long offset) {    const unsigned long *p = addr + BITOP_WORD(offset);    unsigned long result = offset & ~(BITS_PER_LONG - 1);    unsigned long tmp;    if (offset >= size) {        return size;    }    size -= result;    offset %= BITS_PER_LONG;    if (offset) {        tmp = *(p++);        tmp |= ~0UL >> (BITS_PER_LONG - offset);        if (size < BITS_PER_LONG) {            goto found_first;        }        if (~tmp) {            goto found_middle;        }        size -= BITS_PER_LONG;        result += BITS_PER_LONG;    }    while (size & ~(BITS_PER_LONG - 1)) {        if (~(tmp = *(p++))) {            goto found_middle;        }        result += BITS_PER_LONG;        size -= BITS_PER_LONG;    }    if (!size) {        return result;    }    tmp = *p;found_first:    tmp |= ~0UL << size;    if (tmp == ~0UL) { /* Are any bits zero? */        return result + size; /* Nope. */    }found_middle:    return result + ffz(tmp);}"}, {"type": "no factor", "target": "1", "code": "static int parse_adaptation_sets(AVFormatContext *s) {    WebMDashMuxContext *w = s->priv_data;    char *p = w->adaptation_sets;    char *q;    enum { new_set, parsed_id, parsing_streams } state;    if (!w->adaptation_sets) {        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");        return AVERROR(EINVAL);    }    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on    state = new_set;    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {        if (*p == ' ')            continue;        else if (state == new_set && !strncmp(p, \"id=\", 3)) {            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));            if (mem == NULL)                return AVERROR(ENOMEM);            w->as = mem;            ++w->nb_as;            w->as[w->nb_as - 1].nb_streams = 0;            w->as[w->nb_as - 1].streams = NULL;            p += 3; // consume \"id=\"            q = w->as[w->nb_as - 1].id;            while (*p != ',')                *q++ = *p++;            *q = 0;            p++;            state = parsed_id;        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {            p += 8; // consume \"streams=\"            state = parsing_streams;        } else if (state == parsing_streams) {            struct AdaptationSet *as = &w->as[w->nb_as - 1];            q = p;            while (*q != '\\0' && *q != ',' && *q != ' ')                q++;            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);            if (as->streams == NULL)                return AVERROR(ENOMEM);            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);            if (as->streams[as->nb_streams - 1] < 0)                return -1;            if (*q == '\\0')                break;            if (*q == ' ')                state = new_set;            p = ++q;        } else {            return -1;        }    }    return 0;}"}, {"type": "no factor", "target": "1", "code": "static void netfilter_finalize(Object *obj) {    NetFilterState *nf = NETFILTER(obj);    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);    if (nfc->cleanup) {        nfc->cleanup(nf);    }    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);    }}"}, {"type": "no factor", "target": "1", "code": "static int jazz_led_init(SysBusDevice *dev){    LedState *s = FROM_SYSBUS(LedState, dev);    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);    sysbus_init_mmio(dev, &s->iomem);    s->ds = graphic_console_init(        jazz_led_update_display,        jazz_led_invalidate_display,        jazz_led_screen_dump,        jazz_led_text_update,        s    );    return 0;}"}, {"type": "no factor", "target": "1", "code": "PCIBus *pci_prep_init(qemu_irq *pic) {    PREPPCIState *s;    PCIDevice *d;    int PPC_io_memory;    s = qemu_mallocz(sizeof(PREPPCIState));    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read, PPC_PCIIO_write, s);    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);    /* PCI host bridge */    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\", sizeof(PCIDevice), 0, NULL, NULL);    d->config[0x00] = 0x57; // vendor_id : Motorola    d->config[0x01] = 0x10;    d->config[0x02] = 0x01; // device_id : Raven    d->config[0x03] = 0x48;    d->config[0x08] = 0x00; // revision    d->config[0x0A] = 0x00; // class_sub = pci host    d->config[0x0B] = 0x06; // class_base = PCI_bridge    d->config[0x0C] = 0x08; // cache_line_size    d->config[0x0D] = 0x10; // latency_timer    d->config[0x0E] = 0x00; // header_type    d->config[0x34] = 0x00; // capabilities_pointer    return s->bus;}"}, {"type": "no factor", "target": "1", "code": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,                        AVFilterInOut **open_outputs, AVClass *log_ctx) {    int pad = 0;    while (**buf == '[') {        char *name = parse_link_name(buf, log_ctx);        AVFilterInOut *match;        if (!name)            return AVERROR(EINVAL);        /* First check if the label is not in the open_outputs list */        match = extract_inout(name, open_outputs);        if (match) {            av_free(name);        } else {            /* Not in the list, so add it as an input */            match = av_mallocz(sizeof(AVFilterInOut));            match->name = name;            match->pad_idx = pad;        }        insert_inout(curr_inputs, match);        *buf += strspn(*buf, WHITESPACES);        pad++;    }    return pad;}"}, {"type": "no factor", "target": "1", "code": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    struct nbd_request request;    struct nbd_reply reply;    ssize_t ret;    request.type = NBD_CMD_READ;    request.from = sector_num * 512;    request.len = nb_sectors * 512;    nbd_coroutine_start(client, &request);    ret = nbd_co_send_request(client, &request, NULL, 0);    if (ret < 0) {        reply.error = -ret;    } else {        nbd_co_receive_reply(client, &request, &reply, qiov, offset);    }    nbd_coroutine_end(client, &request);    return -reply.error;}"}, {"type": "no factor", "target": "1", "code": "static void debug_print_fis(uint8_t *fis, int cmd_len) {#ifdef DEBUG_AHCI    int i;    fprintf(stderr, \"fis:\");    for (i = 0; i < cmd_len; i++) {        if ((i & 0xf) == 0) {            fprintf(stderr, \"\\n%02x:\", i);        }        fprintf(stderr, \"%02x \", fis[i]);    }    fprintf(stderr, \"\\n\");#endif}"}, {"type": "no factor", "target": "1", "code": "static int bt_hid_in(struct bt_hid_device_s *s) {    USBPacket p;    p.pid = USB_TOKEN_IN;    p.devep = 1;    p.data = s->datain.buffer;    p.len = sizeof(s->datain.buffer);    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);    return s->datain.len;}"}, {"type": "no factor", "target": "1", "code": "static void continue_after_map_failure(void *opaque) {    DMAAIOCB *dbs = (DMAAIOCB *)opaque;    dbs->bh = qemu_bh_new(reschedule_dma, dbs);    qemu_bh_schedule(dbs->bh);}"}, {"type": "no factor", "target": "1", "code": "static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track) {    int64_t pos = avio_tell(pb);    avio_wb32(pb, 0); /* size */    ffio_wfourcc(pb, \"stbl\");    mov_write_stsd_tag(pb, track);    mov_write_stts_tag(pb, track);    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||         track->enc->codec_tag == MKTAG('r', 't', 'p', ' ')) &&        track->has_keyframes && track->has_keyframes < track->entry) {        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);    }    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS) {        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);    }    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&        track->flags & MOV_TRACK_CTTS && track->entry) {        mov_write_ctts_tag(pb, track);    }    mov_write_stsc_tag(pb, track);    mov_write_stsz_tag(pb, track);    mov_write_stco_tag(pb, track);    return update_size(pb, pos);}"}, {"type": "no factor", "target": "1", "code": "static int read_ffserver_streams(AVFormatContext *s, const char *filename) {    int i, err;    AVFormatContext *ic;    int nopts = 0;    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);    if (err < 0)        return err;    /* copy stream format */    s->nb_streams = ic->nb_streams;    for (i = 0; i < ic->nb_streams; i++) {        AVStream *st;        AVCodec *codec;        // FIXME: a more elegant solution is needed        st = av_mallocz(sizeof(AVStream));        memcpy(st, ic->streams[i], sizeof(AVStream));        st->codec = avcodec_alloc_context();        if (!st->codec) {            print_error(filename, AVERROR(ENOMEM));            ffmpeg_exit(1);        }        avcodec_copy_context(st->codec, ic->streams[i]->codec);        s->streams[i] = st;        codec = avcodec_find_encoder(st->codec->codec_id);        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {            if (audio_stream_copy) {                st->stream_copy = 1;            } else                choose_sample_fmt(st, codec);        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {            if (video_stream_copy) {                st->stream_copy = 1;            } else                choose_pixel_fmt(st, codec);        }        if (!st->codec->thread_count)            st->codec->thread_count = 1;        if (st->codec->thread_count > 1)            avcodec_thread_init(st->codec, st->codec->thread_count);        if (st->codec->flags & CODEC_FLAG_BITEXACT)            nopts = 1;    }    if (!nopts)        s->timestamp = av_gettime();    av_close_input_file(ic);    return 0;}"}, {"type": "no factor", "target": "1", "code": "void stream_start(BlockDriverState *bs, BlockDriverState *base,                  const char *base_id, int64_t speed,                  BlockDriverCompletionFunc *cb,                  void *opaque, Error **errp) {    StreamBlockJob *s;    Coroutine *co;    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);    if (!s) {        return;    }    s->base = base;    if (base_id) {        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);    }    co = qemu_coroutine_create(stream_run);    trace_stream_start(bs, base, s, co, opaque);    qemu_coroutine_enter(co, s);}"}, {"type": "no factor", "target": "1", "code": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,                                       int16_t *src2,                                       int height, int denom, int wx0, int wx1,                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width) {    int x, y;    pixel *src = (pixel *)_src;    ptrdiff_t srcstride = _srcstride / sizeof(pixel);    pixel *dst = (pixel *)_dst;    ptrdiff_t dststride = _dststride / sizeof(pixel);    const int8_t *filter = ff_hevc_epel_filters[mx - 1];    int shift = 14 + 1 - BIT_DEPTH;    int log2Wd = denom + shift - 1;    ox0 = ox0 * (1 << (BIT_DEPTH - 8));    ox1 = ox1 * (1 << (BIT_DEPTH - 8));    for (y = 0; y < height; y++) {        for (x = 0; x < width; x++)            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));        src += srcstride;        dst += dststride;        src2 += MAX_PB_SIZE;    }}"}, {"type": "no factor", "target": "1", "code": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size) {    unsigned i;    /* Check that there is free space left in a buffer */    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");        return;    }    for (i = 0; i < size; i++) {        s->fifo_buffer[s->data_count] = value & 0xFF;        s->data_count++;        value >>= 8;        if (s->data_count >= (s->blksize & 0x0fff)) {            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\", s->data_count);            s->data_count = 0;            s->prnsts &= ~SDHC_SPACE_AVAILABLE;            if (s->prnsts & SDHC_DOING_WRITE) {                sdhci_write_block_to_card(s);            }        }    }}"}, {"type": "no factor", "target": "1", "code": "static void test_ide_drive_cd_0(void) {    char *argv[256];    int argc, ide_idx;    Backend i;    argc = setup_common(argv, ARRAY_SIZE(argv));    for (i = 0; i <= backend_empty; i++) {        ide_idx = backend_empty - i;        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),                         ide_idx, NULL, i, mbr_blank, \"\");    }    qtest_start(g_strjoinv(\" \", argv));    test_cmos();    qtest_end();}"}, {"type": "no factor", "target": "1", "code": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run,                      int *x, int *y, int *plane, int bits_per_plane) {    uint8_t *d;    int shift = *plane * bits_per_plane;    int mask = ((1 << bits_per_plane) - 1) << shift;    value <<= shift;    while (run > 0) {        int j;        for (j = 8 - bits_per_plane; j >= 0; j -= bits_per_plane) {            d = frame->data[0] + *y * frame->linesize[0];            d[*x] |= (value >> j) & mask;            *x += 1;            if (*x == s->width) {                *y -= 1;                *x = 0;                if (*y < 0) {                    *y = s->height - 1;                    *plane += 1;                    if (*plane >= s->nb_planes)                        return;                    value <<= bits_per_plane;                    mask <<= bits_per_plane;                }            }        }        run--;    }}"}, {"type": "no factor", "target": "1", "code": "static void test_flush_nodev(void) {    QPCIDevice *dev;    QPCIBar bmdma_bar, ide_bar;    ide_test_start(\"\");    dev = get_pci_device(&bmdma_bar, &ide_bar);    /* FLUSH CACHE command on device 0 */    qpci_io_writeb(dev, ide_bar, reg_device, 0);    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);    /* Just testing that qemu doesn't crash... */    ide_test_quit();}"}, {"type": "no factor", "target": "1", "code": "static int qemu_signalfd_compat(const sigset_t *mask) {    pthread_attr_t attr;    pthread_t tid;    struct sigfd_compat_info *info;    int fds[2];    info = malloc(sizeof(*info));    if (info == NULL) {        errno = ENOMEM;        return -1;    }    if (pipe(fds) == -1) {        free(info);        return -1;    }    memcpy(&info->mask, mask, sizeof(*mask));    info->fd = fds[1];    pthread_attr_init(&attr);    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);    pthread_create(&tid, &attr, sigwait_compat, info);    pthread_attr_destroy(&attr);    return fds[0];}"}, {"type": "no factor", "target": "1", "code": "static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) {    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;    ByteIOContext *pb = &s->pb;    int ret;    ret = process_ipmovie_chunk(ipmovie, pb, pkt);    if (ret == CHUNK_BAD)        ret = AVERROR_INVALIDDATA;    else if (ret == CHUNK_EOF)        ret = AVERROR_IO;    else if (ret == CHUNK_NOMEM)        ret = AVERROR_NOMEM;    else        ret = 0;    return ret;}"}, {"type": "no factor", "target": "1", "code": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size) {    buf[0] = 0;    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);    AV_WB16(&buf[4], s->w);    AV_WB16(&buf[6], s->h);    AV_WB16(&buf[8], num_strips);    return CVID_HEADER_SIZE;}"}, {"type": "no factor", "target": "1", "code": "static void pc_fw_add_pflash_drv(void) {    QemuOpts *opts;    QEMUMachine *machine;    char *filename;    if (bios_name == NULL) {        bios_name = BIOS_FILENAME;    }    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");    g_free(filename);    if (opts == NULL) {        return;    }    machine = find_default_machine();    if (machine == NULL) {        return;    }    drive_init(opts, machine->use_scsi);}"}, {"type": "no factor", "target": "1", "code": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow) {    TCGv_i64 tmp;    TCGv tmp2;    /* Load value and extend to 64 bits.  */    tmp = tcg_temp_new_i64();    tmp2 = load_reg(s, rlow);    tcg_gen_extu_i32_i64(tmp, tmp2);    dead_tmp(tmp2);    tcg_gen_add_i64(val, val, tmp);    tcg_temp_free_i64(tmp);}"}, {"type": "no factor", "target": "1", "code": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr) {    const char *file_out = qemu_opt_get(opts, \"path\");    HANDLE fd_out;    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);    if (fd_out == INVALID_HANDLE_VALUE) {        return -EIO;    }    return qemu_chr_open_win_file(fd_out, _chr);}"}, {"type": "no factor", "target": "1", "code": "static int dynticks_start_timer(struct qemu_alarm_timer *t) {    struct sigevent ev;    timer_t host_timer;    struct sigaction act;    sigfillset(&act.sa_mask);    act.sa_flags = 0;    act.sa_handler = host_alarm_handler;    sigaction(SIGALRM, &act, NULL);    ev.sigev_value.sival_int = 0;    ev.sigev_notify = SIGEV_SIGNAL;    ev.sigev_signo = SIGALRM;    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {        perror(\"timer_create\");        /* disable dynticks */        fprintf(stderr, \"Dynamic Ticks disabled\\n\");        return -1;    }    t->priv = (void *)(long)host_timer;    return 0;}"}, {"type": "no factor", "target": "1", "code": "static int minimum_frame_bits(VC2EncContext *s) {    int slice_x, slice_y, bits = 0;    s->size_scaler = 64;    for (slice_y = 0; slice_y < s->num_y; slice_y++) {        for (slice_x = 0; slice_x < s->num_x; slice_x++) {            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);        }    }    return bits;}"}, {"type": "no factor", "target": "1", "code": "static av_cold int hevc_init_context(AVCodecContext *avctx) {    HEVCContext *s = avctx->priv_data;    int i;    s->avctx = avctx;    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));    if (!s->HEVClc)        goto fail;    s->HEVClcList[0] = s->HEVClc;    s->sList[0] = s;    s->cabac_state = av_malloc(HEVC_CONTEXTS);    if (!s->cabac_state)        goto fail;    s->output_frame = av_frame_alloc();    if (!s->output_frame)        goto fail;    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {        s->DPB[i].frame = av_frame_alloc();        if (!s->DPB[i].frame)            goto fail;        s->DPB[i].tf.f = s->DPB[i].frame;    }    s->max_ra = INT_MAX;    s->md5_ctx = av_md5_alloc();    if (!s->md5_ctx)        goto fail;    ff_bswapdsp_init(&s->bdsp);    s->context_initialized = 1;    s->eos = 0;    return 0;fail:    hevc_decode_free(avctx);    return AVERROR(ENOMEM);}"}, {"type": "no factor", "target": "1", "code": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp) {    MSDState *s = DO_UPCAST(MSDState, dev, dev);    usb_desc_create_serial(dev);    usb_desc_init(dev);    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev), &usb_msd_scsi_info_bot, NULL);    s->bus.qbus.allow_hotplug = 0;    usb_msd_handle_reset(dev);}"}, {"type": "no factor", "target": "1", "code": "static av_cold int qsv_decode_close(AVCodecContext *avctx) {    QSVOtherContext *s = avctx->priv_data;    ff_qsv_decode_close(&s->qsv);    qsv_clear_buffers(s);    av_fifo_free(s->packet_fifo);    return 0;}"}, {"type": "no factor", "target": "1", "code": "static void show_packets(AVFormatContext *fmt_ctx) {    AVPacket pkt;    av_init_packet(&pkt);    probe_array_header(\"packets\", 0);    while (!av_read_frame(fmt_ctx, &pkt)) {        show_packet(fmt_ctx, &pkt);    }    probe_array_footer(\"packets\", 0);}"}, {"type": "no factor", "target": "1", "code": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) {    BDRVBlkverifyState *s = bs->opaque;    QemuOpts *opts;    Error *local_err = NULL;    int ret;    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);    qemu_opts_absorb_qdict(opts, options, &local_err);    if (local_err) {        error_propagate(errp, local_err);        ret = -EINVAL;        goto fail;    }    /* Open the raw file */    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\", bs, &child_file, false, &local_err);    if (local_err) {        ret = -EINVAL;        error_propagate(errp, local_err);        goto fail;    }    /* Open the test file */    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"test\", bs, &child_format, false, &local_err);    if (local_err) {        ret = -EINVAL;        error_propagate(errp, local_err);        goto fail;    }    ret = 0;fail:    qemu_opts_del(opts);    return ret;}"}, {"type": "no factor", "target": "1", "code": "static void virtio_rng_class_init(ObjectClass *klass, void *data) {    DeviceClass *dc = DEVICE_CLASS(klass);    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);    dc->props = virtio_rng_properties;    set_bit(DEVICE_CATEGORY_MISC, dc->categories);    vdc->realize = virtio_rng_device_realize;    vdc->unrealize = virtio_rng_device_unrealize;    vdc->get_features = get_features;    vdc->load = virtio_rng_load_device;}"}, {"type": "no factor", "target": "1", "code": "int ppc_find_by_pvr(uint32_t pvr, ppc_def_t **def) {    int i, ret;    ret = -1;    *def = NULL;    for (i = 0; ppc_defs[i].name != NULL; i++) {        if ((pvr & ppc_defs[i].pvr_mask) == (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {            *def = &ppc_defs[i];            ret = 0;            break;        }    }    return ret;}"}, {"type": "no factor", "target": "1", "code": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx) {    SeqVideoContext *seq = avctx->priv_data;        seq->avctx = avctx;    avctx->pix_fmt = AV_PIX_FMT_PAL8;        seq->frame = av_frame_alloc();    if (!seq->frame)        return AVERROR(ENOMEM);    return 0;}"}, {"type": "no factor", "target": "1", "code": "static BufferPoolEntry *get_pool(AVBufferPool *pool) {    BufferPoolEntry *cur = NULL, *last = NULL;    do {        FFSWAP(BufferPoolEntry*, cur, last);        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);        if (!cur)            return NULL;    } while (cur != last);    return cur;}"}, {"type": "no factor", "target": "1", "code": "static int64_t read_ts(char **line, int *duration) {    int64_t start, end;    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {        *line += strcspn(*line, \"\\\"\") + 1;        *duration = end - start;        return start;    }    return AV_NOPTS_VALUE;}"}, {"type": "no factor", "target": "1", "code": "av_cold int ffv1_common_init(AVCodecContext *avctx) {    FFV1Context *s = avctx->priv_data;    if (!avctx->width || !avctx->height)        return AVERROR_INVALIDDATA;    s->avctx = avctx;    s->flags = avctx->flags;    s->picture.f = avcodec_alloc_frame();    s->last_picture.f = av_frame_alloc();    ff_dsputil_init(&s->dsp, avctx);    s->width  = avctx->width;    s->height = avctx->height;    // defaults    s->num_h_slices = 1;    s->num_v_slices = 1;    return 0;}"}, {"type": "no factor", "target": "1", "code": "void vnc_sasl_client_cleanup(VncState *vs) {    if (vs->sasl.conn) {        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;        vs->sasl.encoded = NULL;                g_free(vs->sasl.username);        free(vs->sasl.mechlist);                vs->sasl.username = NULL;        vs->sasl.mechlist = NULL;                sasl_dispose(&vs->sasl.conn);        vs->sasl.conn = NULL;    }}"}, {"type": "no factor", "target": "1", "code": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info) {    info->magic = (unsigned short)get_be16(f);    info->rle = get_byte(f);    info->bytes_per_channel = get_byte(f);    info->dimension = (unsigned short)get_be16(f);    info->xsize = (unsigned short)get_be16(f);    info->ysize = (unsigned short)get_be16(f);    info->zsize = (unsigned short)get_be16(f);#ifdef DEBUG    printf(\"sgi header fields:\\n\");    printf(\"  magic: %d\\n\", info->magic);    printf(\"    rle: %d\\n\", info->rle);    printf(\"    bpc: %d\\n\", info->bytes_per_channel);    printf(\"    dim: %d\\n\", info->dimension);    printf(\"  xsize: %d\\n\", info->xsize);    printf(\"  ysize: %d\\n\", info->ysize);    printf(\"  zsize: %d\\n\", info->zsize);#endif    return;}"}, {"type": "no factor", "target": "1", "code": "static void i440fx_update_memory_mappings(PCII440FXState *d) {    int i, r;    uint32_t smram;    bool smram_enabled;    memory_region_transaction_begin();    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3, &d->pam_regions[0]);    for (i = 0; i < 12; i++) {        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r, &d->pam_regions[i + 1]);    }    smram = d->dev.config[I440FX_SMRAM];    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);    memory_region_set_enabled(&d->smram_region, !smram_enabled);    memory_region_transaction_commit();}"}, {"type": "no factor", "target": "1", "code": "inline static void RENAME(hcscale)(    SwsContext* c,    uint16_t* dst,    int dstWidth,    const uint8_t* src1,    const uint8_t* src2,    int srcW,    int xInc,    const int16_t* hChrFilter,    const int16_t* hChrFilterPos,    int hChrFilterSize,    uint8_t* formatConvBuffer,    uint32_t* pal) {    src1 += c->chrSrcOffset;    src2 += c->chrSrcOffset;    if (c->chrToYV12) {        c->chrToYV12(formatConvBuffer, formatConvBuffer + VOFW, src1, src2, srcW, pal);        src1 = formatConvBuffer;        src2 = formatConvBuffer + VOFW;    }    if (!c->hcscale_fast) {        c->hScale(dst, dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);        c->hScale(dst + VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);    } else {        // fast bilinear upscale / crap downscale        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);    }    if (c->chrConvertRange)        c->chrConvertRange(dst, dstWidth);}"}, {"type": "no factor", "target": "1", "code": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from) {    NetPacket *packet, *next;    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {        if (packet->sender == from) {            QTAILQ_REMOVE(&queue->packets, packet, entry);            g_free(packet);        }    }}"}, {"type": "no factor", "target": "1", "code": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size) {    c->high = 255;    c->bits = -16;    c->buffer = buf;    c->end = buf + buf_size;    c->code_word = bytestream_get_be24(&c->buffer);}"}, {"type": "no factor", "target": "1", "code": "static int no_init_in(HWVoiceIn *hw, struct audsettings *as) {    audio_pcm_init_info(&hw->info, as);    hw->samples = 1024;    return 0;}"}, {"type": "no factor", "target": "1", "code": "static void ehci_writeback_async_complete_packet(EHCIPacket *p) {    EHCIQueue *q = p->queue;    int state;    state = ehci_get_state(q->ehci, q->async);    ehci_state_executing(q);    ehci_state_writeback(q); /* Frees the packet! */    if (!(q->qh.token & QTD_TOKEN_HALT)) {        ehci_state_advqueue(q);    }    ehci_set_state(q->ehci, q->async, state);}"}, {"type": "no factor", "target": "1", "code": "static void type_initialize_interface(TypeImpl *ti, const char *parent) {    InterfaceClass *new_iface;    TypeInfo info = { };    TypeImpl *iface_impl;    info.parent = parent;    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);    info.abstract = true;    iface_impl = type_register(&info);    type_initialize(iface_impl);    g_free((char *)info.name);    new_iface = (InterfaceClass *)iface_impl->class;    new_iface->concrete_class = ti->class;    ti->class->interfaces = g_slist_append(ti->class->interfaces,                                           iface_impl->class);}"}, {"type": "no factor", "target": "1", "code": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width) {    int i;    for (i = 0; i < width; i++) {        int r = ((uint32_t*)src)[i] & 0xFF;        int g = (((uint32_t*)src)[i] >> 8) & 0xFF;        int b = (((uint32_t*)src)[i] >> 16) & 0xFF;        dst[i] = ((RY * r + GY * g + BY * b + (33 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT);    }}"}, {"type": "no factor", "target": "1", "code": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time) {    char buffer[32];    if (time) {        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time));        av_metadata_set2(metadata, \"creation_time\", buffer, 0);    }}"}, {"type": "no factor", "target": "1", "code": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source) {    int i;    assert(dest->niov == source->niov);    assert(dest->size == source->size);    for (i = 0; i < source->niov; i++) {        assert(dest->iov[i].iov_len == source->iov[i].iov_len);        memcpy(dest->iov[i].iov_base,               source->iov[i].iov_base,               source->iov[i].iov_len);    }}"}, {"type": "no factor", "target": "1", "code": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,                                               VirtQueue *vq,                                               EventNotifierHandler *handler,                                               int n){    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);    int rc;    /* Set up virtqueue notify */    rc = k->set_host_notifier(qbus->parent, n, true);    if (rc != 0) {        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\", rc);        exit(1);    }    r->host_notifier = *virtio_queue_get_host_notifier(vq);    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);    r->parent = s;    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");        exit(1);    }    return r;}"}, {"type": "no factor", "target": "1", "code": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr){    KVMState *s = kvm_state;    unsigned long size, allocated_size = 0;    KVMDirtyLog d;    KVMSlot *mem;    int ret = 0;    d.dirty_bitmap = NULL;    while (start_addr < end_addr) {        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);        if (mem == NULL) {            break;        }        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;        if (!d.dirty_bitmap) {            d.dirty_bitmap = qemu_malloc(size);        } else if (size > allocated_size) {            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);        }        allocated_size = size;        memset(d.dirty_bitmap, 0, allocated_size);        d.slot = mem->slot;        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {            DPRINTF(\"ioctl failed %d\\n\", errno);            ret = -1;            break;        }        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,                                      mem->start_addr, mem->memory_size);        start_addr = mem->start_addr + mem->memory_size;    }    qemu_free(d.dirty_bitmap);    return ret;}"}, {"type": "no factor", "target": "1", "code": "void do_POWER_maskg(void){    uint32_t ret;    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {        ret = -1;    } else {        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^              (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);        if ((uint32_t)T0 > (uint32_t)T1)            ret = ~ret;    }    T0 = ret;}"}, {"type": "no factor", "target": "1", "code": "static void start_tco(const TestData *d){    uint32_t val;    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);    val &= ~TCO_TMR_HLT;    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);}"}, {"type": "no factor", "target": "1", "code": "static void wdt_diag288_class_init(ObjectClass *klass, void *data){    DeviceClass *dc = DEVICE_CLASS(klass);    DIAG288Class *diag288 = DIAG288_CLASS(klass);    dc->realize = wdt_diag288_realize;    dc->unrealize = wdt_diag288_unrealize;    dc->reset = wdt_diag288_reset;    set_bit(DEVICE_CATEGORY_MISC, dc->categories);    dc->vmsd = &vmstate_diag288;    diag288->handle_timer = wdt_diag288_handle_timer;}"}, {"type": "no factor", "target": "1", "code": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val){    IDEBus *bus = opaque;    IDEState *s = idebus_active_if(bus);    uint8_t *p;    /* PIO data access allowed only when DRQ bit is set */    if (!(s->status & DRQ_STAT))        return;    p = s->data_ptr;    *(uint16_t *)p = le16_to_cpu(val);    p += 2;    s->data_ptr = p;    if (p >= s->data_end)        s->end_transfer_func(s);}"}, {"type": "no factor", "target": "1", "code": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,                                      const uint8_t *buf, int nb_sectors){    int ret;    BDRVVmdkState *s = bs->opaque;    qemu_co_mutex_lock(&s->lock);    ret = vmdk_write(bs, sector_num, buf, nb_sectors);    qemu_co_mutex_unlock(&s->lock);    return ret;}"}, {"type": "no factor", "target": "1", "code": "static void pm_update_sci(VT686PMState *s){    int sci_level, pmsts;    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);    sci_level = (((pmsts & s->ar.pm1.evt.en) &                  (ACPI_BITMASK_RT_CLOCK_ENABLE |                   ACPI_BITMASK_POWER_BUTTON_ENABLE |                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |                   ACPI_BITMASK_TIMER_ENABLE)) != 0);    qemu_set_irq(s->dev.irq[0], sci_level);    /* schedule a timer interruption if needed */    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&                               !(pmsts & ACPI_BITMASK_TIMER_STATUS));}"}, {"type": "no factor", "target": "1", "code": "static int qmp_tmp105_get_temperature(const char *id){    QDict *response;    int ret;    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"                   \"'property': 'temperature' } }\", id);    g_assert(qdict_haskey(response, \"return\"));    ret = qdict_get_int(response, \"return\");    QDECREF(response);    return ret;}"}, {"type": "no factor", "target": "1", "code": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr, unsigned size){    BostonState *s = opaque;    uint32_t gic_freq, val;    if (size != 4) {        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);        return 0;    }    switch (addr & 0xffff) {    case PLAT_FPGA_BUILD:    case PLAT_CORE_CL:    case PLAT_WRAPPER_CL:        return 0;    case PLAT_DDR3_STATUS:        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;    case PLAT_MMCM_DIV:        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;        return val;    case PLAT_BUILD_CFG:        val = PLAT_BUILD_CFG_PCIE0_EN;        val |= PLAT_BUILD_CFG_PCIE1_EN;        val |= PLAT_BUILD_CFG_PCIE2_EN;        return val;    case PLAT_DDR_CFG:        val = s->mach->ram_size / G_BYTE;        assert(!(val & ~PLAT_DDR_CFG_SIZE));        val |= PLAT_DDR_CFG_MHZ;        return val;    default:        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,                      addr & 0xffff);        return 0;    }}"}, {"type": "no factor", "target": "1", "code": "static int decodeTonalComponents(GetBitContext *gb, tonal_component *pComponent, int numBands){    int i, j, k, cnt;    int components, coding_mode_selector, coding_mode, coded_values_per_component;    int sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;    int band_flags[4], mantissa[8];    float *pCoef;    float scalefactor;    int component_count = 0;    components = get_bits(gb, 5);    /* no tonal components */    if (components == 0)        return 0;    coding_mode_selector = get_bits(gb, 2);    if (coding_mode_selector == 2)        coding_mode = coding_mode_selector & 1;    for (i = 0; i < components; i++) {        for (cnt = 0; cnt <= numBands; cnt++)            band_flags[cnt] = get_bits1(gb);        coded_values_per_component = get_bits(gb, 3);        quant_step_index = get_bits(gb, 3);        if (quant_step_index <= 1)            if (coding_mode_selector == 3)                coding_mode = get_bits1(gb);        for (j = 0; j < (numBands + 1) * 4; j++) {            if (band_flags[j >> 2] == 0)                continue;            coded_components = get_bits(gb, 3);            for (k = 0; k < coded_components; k++) {                sfIndx = get_bits(gb, 6);                pComponent[component_count].pos = j * 64 + (get_bits(gb, 6));                max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;                coded_values = coded_values_per_component + 1;                coded_values = FFMIN(max_coded_values, coded_values);                scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index];                readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values);                pComponent[component_count].numCoefs = coded_values;                /* inverse quant */                pCoef = pComponent[component_count].coef;                for (cnt = 0; cnt < coded_values; cnt++)                    pCoef[cnt] = mantissa[cnt] * scalefactor;                component_count++;            }        }    }    return component_count;}"}, {"type": "no factor", "target": "1", "code": "static av_cold int svq1_encode_init(AVCodecContext *avctx){    SVQ1Context *const s = avctx->priv_data;    dsputil_init(&s->dsp, avctx);    avctx->coded_frame = (AVFrame*)&s->picture;    s->frame_width = avctx->width;    s->frame_height = avctx->height;    s->y_block_width = (s->frame_width + 15) / 16;    s->y_block_height = (s->frame_height + 15) / 16;    s->c_block_width = (s->frame_width / 4 + 15) / 16;    s->c_block_height = (s->frame_height / 4 + 15) / 16;    s->avctx = avctx;    s->m.avctx = avctx;    s->m.me.scratchpad = av_mallocz((avctx->width + 64) * 2 * 16 * 2 * sizeof(uint8_t));    s->m.me.map = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t));    s->m.me.score_map = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t));    s->mb_type = av_mallocz((s->y_block_width + 1) * s->y_block_height * sizeof(int16_t));    s->dummy = av_mallocz((s->y_block_width + 1) * s->y_block_height * sizeof(int32_t));    h263_encode_init(&s->m); // mv_penalty    return 0;}"}, {"type": "no factor", "target": "1", "code": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels){    int iomemtype;    pl080_state *s;    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));    iomemtype = cpu_register_io_memory(0, pl080_readfn, pl080_writefn, s);    cpu_register_physical_memory(base, 0x00000fff, iomemtype);    s->base = base;    s->irq = irq;    s->nchannels = nchannels;    /* ??? Save/restore. */    return s;}"}, {"type": "no factor", "target": "1", "code": "static int decode_5(SANMVideoContext *ctx){#if HAVE_BIGENDIAN    uint16_t *frm;    int npixels;#endif    uint8_t *dst = (uint8_t*)ctx->frm0;    if (rle_decode(ctx, dst, ctx->buf_size))        return AVERROR_INVALIDDATA;#if HAVE_BIGENDIAN    npixels = ctx->npixels;    frm = ctx->frm0;    while (npixels--)        *frm++ = av_bswap16(*frm);#endif    return 0;}"}, {"type": "no factor", "target": "1", "code": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp){    StreamBlockJob *s = container_of(job, StreamBlockJob, common);    if (speed < 0) {        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");        return;    }    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);}"}, {"type": "no factor", "target": "1", "code": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length){    CPUArchState *env;    int mmu_idx;    assert_cpu_is_self(cpu);    env = cpu->env_ptr;    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {        unsigned int i;        for (i = 0; i < CPU_TLB_SIZE; i++) {            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i], start1, length);        }        for (i = 0; i < CPU_VTLB_SIZE; i++) {            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i], start1, length);        }    }}"}, {"type": "no factor", "target": "1", "code": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){    int i;    int dc0;    dc0 = 0;    for (i = 0; i < 8; i++)        dc0 += src[i - stride];    dc0 = 0x01010101 * ((dc0 + 4) >> 3);    for (i = 0; i < 8; i++) {        ((uint32_t *)(src + i * stride))[0] = dc0;        ((uint32_t *)(src + i * stride))[1] = dc0;    }}"}, {"type": "no factor", "target": "1", "code": "static void do_send_key(const char *string){    char keybuf[16], *q;    uint8_t keycodes[16];    const char *p;    int nb_keycodes, keycode, i;    nb_keycodes = 0;    p = string;    while (*p != '\\0') {        q = keybuf;        while (*p != '\\0' && *p != '-') {            if ((q - keybuf) < sizeof(keybuf) - 1) {                *q++ = *p;            }            p++;        }        *q = '\\0';        keycode = get_keycode(keybuf);        if (keycode < 0) {            term_printf(\"unknown key: '%s'\\n\", keybuf);            return;        }        keycodes[nb_keycodes++] = keycode;        if (*p == '\\0')            break;        p++;    }    /* key down events */    for (i = 0; i < nb_keycodes; i++) {        keycode = keycodes[i];        if (keycode & 0x80)            kbd_put_keycode(0xe0);        kbd_put_keycode(keycode & 0x7f);    }    /* key up events */    for (i = nb_keycodes - 1; i >= 0; i--) {        keycode = keycodes[i];        if (keycode & 0x80)            kbd_put_keycode(0xe0);        kbd_put_keycode(keycode | 0x80);    }}"}, {"type": "no factor", "target": "1", "code": "static int sd_snapshot_delete(BlockDriverState *bs,                              const char *snapshot_id,                              const char *name,                              Error **errp){    unsigned long snap_id = 0;    char snap_tag[SD_MAX_VDI_TAG_LEN];    Error *local_err = NULL;    int fd, ret;    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];    BDRVSheepdogState *s = bs->opaque;    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;    uint32_t vid;    SheepdogVdiReq hdr = {        .opcode = SD_OP_DEL_VDI,        .data_length = wlen,        .flags = SD_FLAG_CMD_WRITE,    };    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;    if (!remove_objects(s)) {        return -1;    }    memset(buf, 0, sizeof(buf));    memset(snap_tag, 0, sizeof(snap_tag));    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);    if (ret || snap_id > UINT32_MAX) {        error_setg(errp, \"Invalid snapshot ID: %s\",                   snapshot_id ? snapshot_id : \"<null>\");        return -EINVAL;    }    if (snap_id) {        hdr.snapid = (uint32_t)snap_id;    } else {        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);    }    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true, &local_err);    if (ret) {        return ret;    }    fd = connect_to_sdog(s, &local_err);    if (fd < 0) {        error_report_err(local_err);        return -1;    }    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr, buf, &wlen, &rlen);    closesocket(fd);    if (ret) {        return ret;    }    switch (rsp->result) {    case SD_RES_NO_VDI:        error_report(\"%s was already deleted\", s->name);    case SD_RES_SUCCESS:        break;    default:        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);        return -1;    }    return ret;}"}, {"type": "no factor", "target": "1", "code": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp){    MOVContext *mov = s->priv_data;    int i, j;    if (!mov->fragment_index_complete)        return 0;    for (i = 0; i < mov->fragment_index_count; i++) {        if (mov->fragment_index_data[i]->track_id == st->id) {            MOVFragmentIndex *index = mov->fragment_index_data[i];            for (j = index->item_count - 1; j >= 0; j--) {                if (index->items[j].time <= timestamp) {                    if (index->items[j].headers_read)                        return 0;                    return mov_switch_root(s, index->items[j].moof_offset);                }            }        }    }    return 0;}"}, {"type": "no factor", "target": "1", "code": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx){    NvencContext *ctx = avctx->priv_data;    if (avctx->bit_rate > 0) {        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;    }    if (avctx->rc_max_rate > 0)        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;    if (ctx->rc < 0) {        if (ctx->flags & NVENC_ONE_PASS)            ctx->twopass = 0;        if (ctx->flags & NVENC_TWO_PASSES)            ctx->twopass = 1;        if (ctx->twopass < 0)            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;        if (ctx->cbr) {            if (ctx->twopass) {                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;            } else {                ctx->rc = NV_ENC_PARAMS_RC_CBR;            }        } else if (avctx->global_quality > 0) {            ctx->rc = NV_ENC_PARAMS_RC_CONSTQP;        } else if (ctx->twopass) {            ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR;        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {            ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP;        }    }    if (ctx->flags & NVENC_LOSSLESS) {        set_lossless(avctx);    } else if (ctx->rc > 0) {        nvenc_override_rate_control(avctx);    } else {        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;        set_vbr(avctx);    }    if (avctx->rc_buffer_size > 0) {        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;    }}"}, {"type": "no factor", "target": "1", "code": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err){    if (err == 0) {        v9fs_string_copy(&vs->fidp->path, &vs->fullname);        stat_to_qid(&vs->stbuf, &vs->qid);        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid, &vs->iounit);        err = vs->offset;    } else {        vs->fidp->fid_type = P9_FID_NONE;        close(vs->fidp->fs.fd);        err = -errno;    }    complete_pdu(s, vs->pdu, err);    v9fs_string_free(&vs->name);    v9fs_string_free(&vs->fullname);    qemu_free(vs);}"}, {"type": "no factor", "target": "1", "code": "static int img_write_packet(AVFormatContext *s, int stream_index,                            UINT8 *buf, int size){    VideoData *img = s->priv_data;    AVStream *st = s->streams[stream_index];    ByteIOContext pb1, *pb;    AVPicture picture;    int width, height, ret, size1;    char filename[1024];    width = st->codec.width;    height = st->codec.height;    switch (st->codec.pix_fmt) {    case PIX_FMT_YUV420P:        size1 = (width * height * 3) / 2;        if (size != size1)            return -EIO;        picture.data[0] = buf;        picture.data[1] = picture.data[0] + width * height;        picture.data[2] = picture.data[1] + (width * height) / 4;        picture.linesize[0] = width;        picture.linesize[1] = width >> 1;        picture.linesize[2] = width >> 1;        break;    case PIX_FMT_RGB24:        size1 = (width * height * 3);        if (size != size1)            return -EIO;        picture.data[0] = buf;        picture.linesize[0] = width * 3;        break;    default:        return -EIO;    }    if (get_frame_filename(filename, sizeof(filename), img->path, img->img_number) < 0)        return -EIO;    if (!img->is_pipe) {        pb = &pb1;        if (url_fopen(pb, filename, URL_WRONLY) < 0)            return -EIO;    } else {        pb = &s->pb;    }    switch (img->img_fmt) {    case IMGFMT_PGMYUV:        ret = pgm_save(&picture, width, height, pb, 1);        break;    case IMGFMT_PGM:        ret = pgm_save(&picture, width, height, pb, 0);        break;    case IMGFMT_YUV:        ret = yuv_save(&picture, width, height, filename);        break;    case IMGFMT_PPM:        ret = ppm_save(&picture, width, height, pb);        break;    }    if (!img->is_pipe) {        url_fclose(pb);    }    img->img_number++;    return 0;}"}, {"type": "no factor", "target": "1", "code": "static void usbredir_bulk_packet(void *priv, uint32_t id,                                 struct usb_redir_bulk_packet_header *bulk_packet,                                 uint8_t *data, int data_len){    USBRedirDevice *dev = priv;    uint8_t ep = bulk_packet->endpoint;    int len = bulk_packet->length;    AsyncURB *aurb;    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,            ep, len, id);    aurb = async_find(dev, id);    if (!aurb) {        free(data);        return;    }    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||        aurb->bulk_packet.stream_id != bulk_packet->stream_id) {        ERROR(\"return bulk packet mismatch, please report this!\\n\");        len = USB_RET_NAK;    }    if (aurb->packet) {        len = usbredir_handle_status(dev, bulk_packet->status, len);        if (len > 0) {            usbredir_log_data(dev, \"bulk data in:\", data, data_len);            if (data_len <= aurb->packet->len) {                memcpy(aurb->packet->data, data, data_len);            } else {                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,                      aurb->packet->len);                len = USB_RET_STALL;            }        }        aurb->packet->len = len;        usb_packet_complete(&dev->dev, aurb->packet);    }    async_free(dev, aurb);    free(data);}"}, {"type": "no factor", "target": "1", "code": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,                                               abi_ulong target_addr){    struct target_timespec *target_ts;    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))        return -TARGET_EFAULT;    host_ts->tv_sec = tswapal(target_ts->tv_sec);    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);    unlock_user_struct(target_ts, target_addr, 0);    return 0;}"}, {"type": "no factor", "target": "1", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val){    EHCIState *s = ptr;    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);    uint32_t old = *mmio;    int i;    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);    /* Only aligned reads are allowed on OHCI */    if (addr & 3) {        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {        handle_port_status_write(s, (addr - PORTSC) / 4, val);        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);        return;    }    if (addr < OPREGBASE) {        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    /* Do any register specific pre-write processing here.  */    switch (addr) {    case USBCMD:        if (val & USBCMD_HCRESET) {            ehci_reset(s);            val = s->usbcmd;            break;        }        /* not supporting dynamic frame list size at the moment */        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",                    val & USBCMD_FLS);            val &= ~USBCMD_FLS;        }        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {            if (s->pstate == EST_INACTIVE) {                SET_LAST_RUN_CLOCK(s);            }            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */            ehci_update_halt(s);            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));        }        break;    case USBSTS:        val &= USBSTS_RO_MASK; /* bits 6 through 31 are RO */        ehci_clear_usbsts(s, val); /* bits 0 through 5 are R/WC */        val = s->usbsts;        ehci_update_irq(s);        break;    case USBINTR:        val &= USBINTR_MASK;        break;    case FRINDEX:        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */        break;    case CONFIGFLAG:        val &= 0x1;        if (val) {            for (i = 0; i < NB_PORTS; i++)                handle_port_owner_write(s, i, 0);        }        break;    case PERIODICLISTBASE:        if (ehci_periodic_enabled(s)) {            fprintf(stderr,                    \"ehci: PERIODIC list base register set while periodic schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    case ASYNCLISTADDR:        if (ehci_async_enabled(s)) {            fprintf(stderr,                    \"ehci: ASYNC list address register set while async schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    }    *mmio = val;    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);}"}, {"type": "no factor", "target": "1", "code": "static const char *keyval_parse_one(QDict *qdict, const char *params,                                    const char *implied_key, Error **errp){    const char *key, *key_end, *s;    size_t len;    char key_in_cur[128];    QDict *cur;    int ret;    QObject *next;    QString *val;    key = params;    len = strcspn(params, \"=,\");    if (implied_key && len && key[len] != '=') {        /* Desugar implied key */        key = implied_key;        len = strlen(implied_key);    }    key_end = key + len;    /*     * Loop over key fragments: @s points to current fragment, it     * applies to @cur.  @key_in_cur[] holds the previous fragment.     */    cur = qdict;    s = key;    for (;;) {        ret = parse_qapi_name(s, false);        len = ret < 0 ? 0 : ret;        assert(s + len <= key_end);        if (!len || (s + len < key_end && s[len] != '.')) {            assert(key != implied_key);            error_setg(errp, \"Invalid parameter '%.*s'\",                       (int)(key_end - key), key);            return NULL;        }        if (len >= sizeof(key_in_cur)) {            assert(key != implied_key);            error_setg(errp, \"Parameter%s '%.*s' is too long\",                       s != key || s + len != key_end ? \" fragment\" : \"\",                       (int)len, s);            return NULL;        }        if (s != key) {            next = keyval_parse_put(cur, key_in_cur, NULL, key, s - 1, errp);            if (!next) {                return NULL;            }            cur = qobject_to_qdict(next);            assert(cur);        }        memcpy(key_in_cur, s, len);        key_in_cur[len] = 0;        s += len;        if (*s != '.') {            break;        }        s++;    }    if (key == implied_key) {        assert(!*s);        s = params;    } else {        if (*s != '=') {            error_setg(errp, \"Expected '=' after parameter '%.*s'\",                       (int)(s - key), key);            return NULL;        }        s++;    }    val = qstring_new();    for (;;) {        if (!*s) {            break;        } else if (*s == ',') {            s++;            if (*s != ',') {                break;            }        }        qstring_append_chr(val, *s++);    }    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {        return NULL;    }    return s;}"}, {"type": "no factor", "target": "1", "code": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,                            int compressed_size, int uncompressed_size,                            EXRThreadData *td){    unsigned long dest_len, expected_len = 0;    const uint8_t *in = td->tmp;    uint8_t *out;    int c, i, j;    for (i = 0; i < s->nb_channels; i++) {        if (s->channels[i].pixel_type == EXR_FLOAT) {            expected_len += (td->xsize * td->ysize * 3); /* PRX 24 store float in 24 bit instead of 32 */        } else if (s->channels[i].pixel_type == EXR_HALF) {            expected_len += (td->xsize * td->ysize * 2);        } else { // UINT 32            expected_len += (td->xsize * td->ysize * 4);        }    }    dest_len = expected_len;    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {        return AVERROR_INVALIDDATA;    } else if (dest_len != expected_len) {        return AVERROR_INVALIDDATA;    }    out = td->uncompressed_data;    for (i = 0; i < td->ysize; i++) {        for (c = 0; c < s->nb_channels; c++) {            EXRChannel *channel = &s->channels[c];            const uint8_t *ptr[4];            uint32_t pixel = 0;            switch (channel->pixel_type) {            case EXR_FLOAT:                ptr[0] = in;                ptr[1] = ptr[0] + td->xsize;                ptr[2] = ptr[1] + td->xsize;                in = ptr[2] + td->xsize;                for (j = 0; j < td->xsize; ++j) {                    uint32_t diff = (*(ptr[0]++) << 24) |                                    (*(ptr[1]++) << 16) |                                    (*(ptr[2]++) << 8);                    pixel += diff;                    bytestream_put_le32(&out, pixel);                }                break;            case EXR_HALF:                ptr[0] = in;                ptr[1] = ptr[0] + td->xsize;                in = ptr[1] + td->xsize;                for (j = 0; j < td->xsize; j++) {                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);                    pixel += diff;                    bytestream_put_le16(&out, pixel);                }                break;            case EXR_UINT:                ptr[0] = in;                ptr[1] = ptr[0] + s->xdelta;                ptr[2] = ptr[1] + s->xdelta;                ptr[3] = ptr[2] + s->xdelta;                in = ptr[3] + s->xdelta;                for (j = 0; j < s->xdelta; ++j) {                    uint32_t diff = (*(ptr[0]++) << 24) |                                    (*(ptr[1]++) << 16) |                                    (*(ptr[2]++) << 8) |                                    (*(ptr[3]++));                    pixel += diff;                    bytestream_put_le32(&out, pixel);                }                break;            default:                return AVERROR_INVALIDDATA;            }        }    }    return 0;}"}, {"type": "no factor", "target": "1", "code": "static int vfio_start_eventfd_injection(VFIOINTp *intp){    int ret;    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);    if (ret) {        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");    }    return ret;}"}, {"type": "no factor", "target": "1", "code": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,                         uint8_t *dst, int dlen){    uint32_t zrun_len = 0, nzrun_len = 0;    int d = 0, i = 0;    long res, xor;    uint8_t *nzrun_start = NULL;    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) % sizeof(long)));    while (i < slen) {        /* overflow */        if (d + 2 > dlen) {            return -1;        }        /* not aligned to sizeof(long) */        res = (slen - i) % sizeof(long);        while (res && old_buf[i] == new_buf[i]) {            zrun_len++;            i++;            res--;        }        /* word at a time for speed */        if (!res) {            while (i < slen &&                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {                i += sizeof(long);                zrun_len += sizeof(long);            }            /* go over the rest */            while (i < slen && old_buf[i] == new_buf[i]) {                zrun_len++;                i++;            }        }        /* buffer unchanged */        if (zrun_len == slen) {            return 0;        }        /* skip last zero run */        if (i == slen) {            return d;        }        d += uleb128_encode_small(dst + d, zrun_len);        zrun_len = 0;        nzrun_start = new_buf + i;        /* overflow */        if (d + 2 > dlen) {            return -1;        }        /* not aligned to sizeof(long) */        res = (slen - i) % sizeof(long);        while (res && old_buf[i] != new_buf[i]) {            i++;            nzrun_len++;            res--;        }        /* word at a time for speed, use of 32-bit long okay */        if (!res) {            /* truncation to 32-bit long okay */            long mask = (long)0x0101010101010101ULL;            while (i < slen) {                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);                if ((xor - mask) & ~xor & (mask << 7)) {                    /* found the end of an nzrun within the current long */                    while (old_buf[i] != new_buf[i]) {                        nzrun_len++;                        i++;                    }                    break;                } else {                    i += sizeof(long);                    nzrun_len += sizeof(long);                }            }        }        d += uleb128_encode_small(dst + d, nzrun_len);        /* overflow */        if (d + nzrun_len > dlen) {            return -1;        }        memcpy(dst + d, nzrun_start, nzrun_len);        d += nzrun_len;        nzrun_len = 0;    }    return d;}"}, {"type": "no factor", "target": "1", "code": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,                               BdrvCheckMode fix, bool *rebuild,                               uint16_t **refcount_table, int64_t *nb_clusters){    BDRVQcowState *s = bs->opaque;    int64_t i;    QCowSnapshot *sn;    int ret;    if (!*refcount_table) {        int64_t old_size = 0;        ret = realloc_refcount_array(s, refcount_table, &old_size, *nb_clusters);        if (ret < 0) {            res->check_errors++;            return ret;        }    }    /* header */    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,                        0, s->cluster_size);    if (ret < 0) {        return ret;    }    /* current L1 table */    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);    if (ret < 0) {        return ret;    }    /* snapshots */    for (i = 0; i < s->nb_snapshots; i++) {        sn = s->snapshots + i;        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,                                 sn->l1_table_offset, sn->l1_size, 0);        if (ret < 0) {            return ret;        }    }    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,                        s->snapshots_offset, s->snapshots_size);    if (ret < 0) {        return ret;    }    /* refcount data */    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,                        s->refcount_table_offset,                        s->refcount_table_size * sizeof(uint64_t));    if (ret < 0) {        return ret;    }    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);}"}, {"type": "no factor", "target": "1", "code": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len){    OpenPICState *opp = opaque;    uint32_t retval = -1;    int idx;    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);    if (addr & 0xF) {        goto out;    }    idx = (addr >> 6) & 0x3;    if (addr == 0x0) {        /* TIFR (TFRR) */        retval = opp->tifr;        goto out;    }    switch (addr & 0x30) {    case 0x00: /* TICC (GTCCR) */        retval = opp->timers[idx].ticc;        break;    case 0x10: /* TIBC (GTBCR) */        retval = opp->timers[idx].tibc;        break;    case 0x20: /* TIPV (TIPV) */        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);        break;    case 0x30: /* TIDE (TIDR) */        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);        break;    }out:    DPRINTF(\"%s: => %08x\\n\", __func__, retval);    return retval;}"}, {"type": "no factor", "target": "1", "code": "int64_t qmp_guest_fsfreeze_freeze(Error **err){    int ret = 0, i = 0;    FsMountList mounts;    struct FsMount *mount;    Error *local_err = NULL;    int fd;    slog(\"guest-fsfreeze called\");    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);    if (error_is_set(&local_err)) {        error_propagate(err, local_err);        return -1;    }    QTAILQ_INIT(&mounts);    build_fs_mount_list(&mounts, &local_err);    if (error_is_set(&local_err)) {        error_propagate(err, local_err);        return -1;    }    /* cannot risk guest agent blocking itself on a write in this state */    ga_set_frozen(ga_state);    QTAILQ_FOREACH(mount, &mounts, next) {        fd = qemu_open(mount->dirname, O_RDONLY);        if (fd == -1) {            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);            goto error;        }        /* we try to cull filesystems we know won't work in advance, but other         * filesystems may not implement fsfreeze for less obvious reasons.         * these will report EOPNOTSUPP. we simply ignore these when tallying         * the number of frozen filesystems.         *         * any other error means a failure to freeze a filesystem we         * expect to be freezable, so return an error in those cases         * and return system to thawed state.         */        ret = ioctl(fd, FIFREEZE);        if (ret == -1) {            if (errno != EOPNOTSUPP) {                error_setg_errno(err, errno, \"failed to freeze %s\", mount->dirname);                close(fd);                goto error;            }        } else {            i++;        }        close(fd);    }    free_fs_mount_list(&mounts);    return i;error:    free_fs_mount_list(&mounts);    qmp_guest_fsfreeze_thaw(NULL);    return 0;}"}, {"type": "no factor", "target": "1", "code": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp){    int ret;    const char *type;    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);    if (ret <= 0) {        return ret;    }    be32_to_cpus(&reply->magic);    switch (reply->magic) {    case NBD_SIMPLE_REPLY_MAGIC:        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);        if (ret < 0) {            break;        }        trace_nbd_receive_simple_reply(reply->simple.error,                                       nbd_err_lookup(reply->simple.error),                                       reply->handle);        if (reply->simple.error == NBD_ESHUTDOWN) {            /* This works even on mingw which lacks a native ESHUTDOWN */            error_setg(errp, \"server shutting down\");            return -EINVAL;        }        break;    case NBD_STRUCTURED_REPLY_MAGIC:        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);        if (ret < 0) {            break;        }        type = nbd_reply_type_lookup(reply->structured.type);        trace_nbd_receive_structured_reply_chunk(reply->structured.flags,                                                 reply->structured.type, type,                                                 reply->structured.handle,                                                 reply->structured.length);        break;    default:        error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic);        return -EINVAL;    }    if (ret < 0) {        return ret;    }    return 1;}"}, {"type": "no factor", "target": "1", "code": "static int srt_probe(AVProbeData *p){    const unsigned char *ptr = p->buf;    int i, v, num = 0;    if (AV_RB24(ptr) == 0xEFBBBF)        ptr += 3; /* skip UTF-8 BOM */    while (*ptr == '\\r' || *ptr == '\\n')        ptr++;    for (i = 0; i < 2; i++) {        if ((num == i || num + 1 == i) &&            sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)            return AVPROBE_SCORE_MAX;        num = atoi(ptr);        ptr += strcspn(ptr, \"\\n\") + 1;    }    return 0;}"}, {"type": "no factor", "target": "1", "code": "void aio_context_setup(AioContext *ctx, Error **errp) {#ifdef CONFIG_EPOLL    assert(!ctx->epollfd);    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);    if (ctx->epollfd == -1) {        ctx->epoll_available = false;    } else {        ctx->epoll_available = true;    }#endif}"}, {"type": "no factor", "target": "1", "code": "static int check_refcounts_l1(BlockDriverState *bs,                              BdrvCheckResult *res,                              uint16_t **refcount_table,                              int64_t *refcount_table_size,                              int64_t l1_table_offset,                              int l1_size,                              int flags) {    BDRVQcowState *s = bs->opaque;    uint64_t *l1_table = NULL, l2_offset, l1_size2;    int i, ret;    l1_size2 = l1_size * sizeof(uint64_t);    /* Mark L1 table as used */    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,                        l1_table_offset, l1_size2);    if (ret < 0) {        goto fail;    }    /* Read L1 table entries from disk */    if (l1_size2 > 0) {        l1_table = g_try_malloc(l1_size2);        if (l1_table == NULL) {            ret = -ENOMEM;            res->check_errors++;            goto fail;        }        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);        if (ret < 0) {            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");            res->check_errors++;            goto fail;        }        for (i = 0; i < l1_size; i++) {            be64_to_cpus(&l1_table[i]);        }    }    /* Do the actual checks */    for (i = 0; i < l1_size; i++) {        l2_offset = l1_table[i];        if (l2_offset) {            /* Mark L2 table as used */            l2_offset &= L1E_OFFSET_MASK;            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,                                l2_offset, s->cluster_size);            if (ret < 0) {                goto fail;            }            /* L2 tables are cluster aligned */            if (offset_into_cluster(s, l2_offset)) {                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"                        \"cluster aligned; L1 entry corrupted\\n\", l2_offset);                res->corruptions++;            }            /* Process and check L2 entries */            ret = check_refcounts_l2(bs, res, refcount_table,                                     refcount_table_size, l2_offset, flags);            if (ret < 0) {                goto fail;            }        }    }    g_free(l1_table);    return 0;fail:    g_free(l1_table);    return ret;}"}, {"type": "no factor", "target": "1", "code": "int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush) {    do {        int nb_output = 0;        int min_poc = INT_MAX;        int i, min_idx, ret;        if (s->sh.no_output_of_prior_pics_flag == 1) {            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {                HEVCFrame *frame = &s->DPB[i];                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&                    frame->sequence == s->seq_output) {                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);                }            }        }        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {            HEVCFrame *frame = &s->DPB[i];            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&                frame->sequence == s->seq_output) {                nb_output++;                if (frame->poc < min_poc) {                    min_poc = frame->poc;                    min_idx = i;                }            }        }        /* wait for more frames before output */        if (!flush && s->seq_output == s->seq_decode && s->sps &&            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics) {            return 0;        }        if (nb_output) {            HEVCFrame *frame = &s->DPB[min_idx];            AVFrame *dst = out;            AVFrame *src = frame->frame;            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);            ret = av_frame_ref(out, src);            if (frame->flags & HEVC_FRAME_FLAG_BUMPING) {                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);            } else {                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);            }            if (ret < 0) {                return ret;            }            for (i = 0; i < 3; i++) {                int hshift = (i > 0) ? desc->log2_chroma_w : 0;                int vshift = (i > 0) ? desc->log2_chroma_h : 0;                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +                          (frame->window.top_offset >> vshift) * dst->linesize[i];                dst->data[i] += off;            }            av_log(s->avctx, AV_LOG_DEBUG, \"Output frame with POC %d.\\n\", frame->poc);            return 1;        }        if (s->seq_output != s->seq_decode) {            s->seq_output = (s->seq_output + 1) & 0xff;        } else {            break;        }    } while (1);    return 0;}"}, {"type": "no factor", "target": "1", "code": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr) {    IRQMP *irqmp = opaque;    IRQMPState *state;    assert(irqmp != NULL);    state = irqmp->state;    assert(state != NULL);    addr &= 0xff;    /* global registers */    switch (addr) {    case LEVEL_OFFSET:        return state->level;    case PENDING_OFFSET:        return state->pending;    case FORCE0_OFFSET:        /* This register is an \"alias\" for the force register of CPU 0 */        return state->force[0];    case CLEAR_OFFSET:    case MP_STATUS_OFFSET:        /* Always read as 0 */        return 0;    case BROADCAST_OFFSET:        return state->broadcast;    default:        break;    }    /* mask registers */    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {        int cpu = (addr - MASK_OFFSET) / 4;        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);        return state->mask[cpu];    }    /* force registers */    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {        int cpu = (addr - FORCE_OFFSET) / 4;        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);        return state->force[cpu];    }    /* extended (not supported) */    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {        int cpu = (addr - EXTENDED_OFFSET) / 4;        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);        return state->extended[cpu];    }    trace_grlib_irqmp_unknown_register(\"read\", addr);    return 0;}"}, {"type": "no factor", "target": "1", "code": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,                          AVFilterBufferRef *picref,                          int flags) {    BufferSourceContext *c = buffer_filter->priv;    AVFilterBufferRef *buf;    int ret;    if (!picref) {        c->eof = 1;        return 0;    } else if (c->eof) {        return AVERROR(EINVAL);    }    if (!av_fifo_space(c->fifo) &&         (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) + sizeof(buf))) < 0) {        return ret;    }    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {        ret = check_format_change(buffer_filter, picref);        if (ret < 0) {            return ret;        }    }    if (flags & AV_BUFFERSRC_FLAG_NO_COPY) {        buf = picref;    } else {        buf = copy_buffer_ref(buffer_filter, picref);    }    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {        if (buf != picref) {            avfilter_unref_buffer(buf);        }        return ret;    }    c->nb_failed_requests = 0;    return 0;}"}, {"type": "no factor", "target": "1", "code": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat) {    // FIXME Optimize (just quickly written, not optimized)    int i;    for (i = 0; i < dstW; i++) {        int val = 1 << 18;        int j;        for (j = 0; j < lumFilterSize; j++) {            val += lumSrc[j][i] * lumFilter[j];        }        dest[i] = av_clip_uint8(val >> 19);    }    if (!uDest) {        return;    }    if (dstFormat == PIX_FMT_NV12) {        for (i = 0; i < chrDstW; i++) {            int u = 1 << 18;            int v = 1 << 18;            int j;            for (j = 0; j < chrFilterSize; j++) {                u += chrSrc[j][i] * chrFilter[j];                v += chrSrc[j][i + 2048] * chrFilter[j];            }            uDest[2 * i] = av_clip_uint8(u >> 19);            uDest[2 * i + 1] = av_clip_uint8(v >> 19);        }    } else {        for (i = 0; i < chrDstW; i++) {            int u = 1 << 18;            int v = 1 << 18;            int j;            for (j = 0; j < chrFilterSize; j++) {                u += chrSrc[j][i] * chrFilter[j];                v += chrSrc[j][i + 2048] * chrFilter[j];            }            uDest[2 * i] = av_clip_uint8(v >> 19);            uDest[2 * i + 1] = av_clip_uint8(u >> 19);        }    }}"}, {"type": "no factor", "target": "1", "code": "void gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,                  uint32_t up_shift, CPUTriCoreState *env) {    TCGv temp = tcg_temp_new();    TCGv temp2 = tcg_temp_new();    TCGv temp3 = tcg_temp_new();    TCGv_i64 t1 = tcg_temp_new_i64();    TCGv_i64 t2 = tcg_temp_new_i64();    TCGv_i64 t3 = tcg_temp_new_i64();    TCGv_i64 t4 = tcg_temp_new_i64();    tcg_gen_ext_i32_i64(t2, arg2);    tcg_gen_ext_i32_i64(t3, arg3);    tcg_gen_mul_i64(t2, t2, t3);    tcg_gen_ext_i32_i64(t1, arg1);    /* if we shift part of the fraction out, we need to round up */    tcg_gen_andi_i64(t4, t2, (1LL << (up_shift - n)) - 1);    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);    tcg_gen_sari_i64(t2, t2, up_shift - n);    tcg_gen_add_i64(t2, t2, t4);    tcg_gen_sub_i64(t3, t1, t2);    tcg_gen_trunc_i64_i32(temp3, t3);    /* calc v bit */    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);    tcg_gen_or_i64(t1, t1, t2);    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);    /* We produce an overflow on the host if the mul before was       (0x80000000 * 0x80000000) << 1). If this is the       case, we negate the ovf. */    if (n == 1) {        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);        tcg_gen_and_tl(temp, temp, temp2);        tcg_gen_shli_tl(temp, temp, 31);        /* negate v bit, if special condition */        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);    }    /* Calc SV bit */    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);    /* Calc AV/SAV bits */    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);    /* calc SAV */    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);    /* write back result */    tcg_gen_mov_tl(ret, temp3);    tcg_temp_free(temp);    tcg_temp_free(temp2);    tcg_temp_free(temp3);    tcg_temp_free_i64(t1);    tcg_temp_free_i64(t2);    tcg_temp_free_i64(t3);    tcg_temp_free_i64(t4);}"}, {"type": "no factor", "target": "1", "code": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict) {    BlockDriverState *bs, *bs1;    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;    int nb_sns, i, ret, available;    int total;    int *available_snapshots;    bs = find_vmstate_bs();    if (!bs) {        monitor_printf(mon, \"No available block device supports snapshots\\n\");        return;    }    nb_sns = bdrv_snapshot_list(bs, &sn_tab);    if (nb_sns < 0) {        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);        return;    }    if (nb_sns == 0) {        monitor_printf(mon, \"There is no snapshot available.\\n\");        return;    }    available_snapshots = g_malloc0(sizeof(int) * nb_sns);    total = 0;    for (i = 0; i < nb_sns; i++) {        sn = &sn_tab[i];        available = 1;        bs1 = NULL;        while ((bs1 = bdrv_next(bs1))) {            if (bdrv_can_snapshot(bs1) && bs1 != bs) {                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);                if (ret < 0) {                    available = 0;                    break;                }            }        }        if (available) {            available_snapshots[total] = i;            total++;        }    }    if (total > 0) {        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);        monitor_printf(mon, \"\\n\");        for (i = 0; i < total; i++) {            sn = &sn_tab[available_snapshots[i]];            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);            monitor_printf(mon, \"\\n\");        }    } else {        monitor_printf(mon, \"There is no suitable snapshot available\\n\");    }    g_free(sn_tab);    g_free(available_snapshots);}"}, {"type": "no factor", "target": "1", "code": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska) {    EbmlList *index_list;    MatroskaIndex *index;    int index_scale = 1;    int i, j;    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX) {        return;    }    index_list = &matroska->index;    index = index_list->elem;    if (index_list->nb_elem && index[0].time > 1E14 / matroska->time_scale) {        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");        index_scale = matroska->time_scale;    }    for (i = 0; i < index_list->nb_elem; i++) {        EbmlList *pos_list = &index[i].pos;        MatroskaIndexPos *pos = pos_list->elem;        for (j = 0; j < pos_list->nb_elem; j++) {            MatroskaTrack *track = matroska_find_track_by_num(matroska, pos[j].track);            if (track && track->stream) {                av_add_index_entry(track->stream,                                   pos[j].pos + matroska->segment_start,                                   index[i].time / index_scale,                                    0,                                    0,                                   AVINDEX_KEYFRAME);            }        }    }}"}, {"type": "no factor", "target": "1", "code": "void fw_cfg_add_file_callback(FWCfgState *s, const char *filename,                              FWCfgCallback select_cb,                              FWCfgWriteCallback write_cb,                              void *callback_opaque,                              void *data, size_t len, bool read_only) {    int i, index, count;    size_t dsize;    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());    int order = 0;    if (!s->files) {        dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);        s->files = g_malloc0(dsize);        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);    }    count = be32_to_cpu(s->files->count);    assert(count < fw_cfg_file_slots(s));    /* Find the insertion point. */    if (mc->legacy_fw_cfg_order) {        /*         * Sort by order. For files with the same order, we keep them         * in the sequence in which they were added.         */        order = get_fw_cfg_order(s, filename);        for (index = count;              index > 0 && order < s->entry_order[index - 1];              index--);    } else {        /* Sort by file name. */        for (index = count;              index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0;              index--);    }    /*     * Move all the entries from the index point and after down one     * to create a slot for the new entry. Because calculations are     * being done with the index, make it so that \"i\" is the current     * index and \"i - 1\" is the one being copied from, thus the     * unusual start and end in the for statement.     */    for (i = count + 1; i > index; i--) {        s->files->f[i] = s->files->f[i - 1];        s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);        s->entries[0][FW_CFG_FILE_FIRST + i] = s->entries[0][FW_CFG_FILE_FIRST + i - 1];        s->entry_order[i] = s->entry_order[i - 1];    }    memset(&s->files->f[index], 0, sizeof(FWCfgFile));    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);    for (i = 0; i <= count; i++) {        if (i != index &&             strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {            error_report(\"duplicate fw_cfg file name: %s\",                          s->files->f[index].name);            exit(1);        }    }    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,                              select_cb, write_cb,                              callback_opaque, data, len,                              read_only);    s->files->f[index].size = cpu_to_be32(len);    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);    s->entry_order[index] = order;    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);    s->files->count = cpu_to_be32(count + 1);}"}, {"type": "no factor", "target": "1", "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,                                 const uint8_t *buf,                                 int buf_size) {    ParseContext *pc = &dctx->pc;    uint64_t state = pc->state64;    int pic_found = pc->frame_start_found;    int i = 0;    if (!pic_found) {        for (i = 0; i < buf_size; i++) {            state = (state << 8) | buf[i];            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {                i++;                pic_found = 1;                dctx->cur_byte = 0;                dctx->remaining = 0;                break;            }        }    }    if (pic_found && !dctx->remaining) {        if (!buf_size) { /* EOF considered as end of frame */            return 0;        }        for (; i < buf_size; i++) {            dctx->cur_byte++;            state = (state << 8) | buf[i];            if (dctx->cur_byte == 24) {                dctx->h = (state >> 32) & 0xFFFF;            } else if (dctx->cur_byte == 26) {                dctx->w = (state >> 32) & 0xFFFF;            } else if (dctx->cur_byte == 42) {                int cid = (state >> 32) & 0xFFFFFFFF;                if (cid <= 0) {                    continue;                }                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);                if (dctx->remaining <= 0) {                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);                    if (dctx->remaining <= 0) {                        return dctx->remaining;                    }                }                if (buf_size - i + 47 >= dctx->remaining) {                    int remaining = dctx->remaining;                    pc->frame_start_found = 0;                    pc->state64 = -1;                    dctx->cur_byte = 0;                    dctx->remaining = 0;                    return remaining;                } else {                    dctx->remaining -= buf_size;                }            }        }    } else if (pic_found) {        if (dctx->remaining > buf_size) {            dctx->remaining -= buf_size;        } else {            int remaining = dctx->remaining;            pc->frame_start_found = 0;            pc->state64 = -1;            dctx->cur_byte = 0;            dctx->remaining = 0;            return remaining;        }    }    pc->frame_start_found = pic_found;    pc->state64 = state;    return END_NOT_FOUND;}"}, {"type": "no factor", "target": "1", "code": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,                          const int16_t *filter, const int16_t *filterPos, int filterSize){    int i;    for (i = 0; i < dstW; i++) {        int j;        int srcPos = filterPos[i];        int val = 0;        for (j = 0; j < filterSize; j++) {            val += ((int)src[srcPos + j]) * filter[filterSize * i + j];        }        // filter += hFilterSize;        dst[i] = FFMIN(val >> 7, (1 << 15) - 1); // the cubic equation does overflow ...        // dst[i] = val >> 7;    }}"}, {"type": "no factor", "target": "1", "code": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S) {    int bit;    if (s->extra_bits) {        S <<= s->extra_bits;        if (s->got_extra_bits) {            S |= get_bits(&s->gb_extra_bits, s->extra_bits);            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);        }    }    bit = (S & s->and) | s->or;    return (((S + bit) << s->shift) - bit) << s->post_shift;}"}, {"type": "no factor", "target": "0", "code": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,                                  MMUAccessType access_type, ARMMMUIdx mmu_idx,                                  hwaddr *phys_ptr, int *prot, uint32_t *fsr) {    ARMCPU *cpu = arm_env_get_cpu(env);    bool is_user = regime_is_user(env, mmu_idx);    int n;    int matchregion = -1;    bool hit = false;    *phys_ptr = address;    *prot = 0;    /* Unlike the ARM ARM pseudocode, we don't need to check whether this     * was an exception vector read from the vector table (which is always     * done using the default system address map), because those accesses     * are done in arm_v7m_load_vector(), which always does a direct     * read using address_space_ldl(), rather than going via this function.     */    if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */        hit = true;    } else if (m_is_ppb_region(env, address)) {        hit = true;    } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) {        hit = true;    } else {        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {            /* region search */            /* Note that the base address is bits [31:5] from the register             * with bits [4:0] all zeroes, but the limit address is bits             * [31:5] from the register with bits [4:0] all ones.             */            uint32_t base = env->pmsav8.rbar[n] & ~0x1f;            uint32_t limit = env->pmsav8.rlar[n] | 0x1f;            if (!(env->pmsav8.rlar[n] & 0x1)) {                /* Region disabled */                continue;            }            if (address < base || address > limit) {                continue;            }            if (hit) {                /* Multiple regions match -- always a failure (unlike                 * PMSAv7 where highest-numbered-region wins)                 */                *fsr = 0x00d; /* permission fault */                return true;            }            matchregion = n;            hit = true;            if (base & ~TARGET_PAGE_MASK) {                qemu_log_mask(LOG_UNIMP,                              \"MPU_RBAR[%d]: No support for MPU region base \"                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"                              \"%d\\n\",                              n, base, TARGET_PAGE_BITS);                continue;            }            if ((limit + 1) & ~TARGET_PAGE_MASK) {                qemu_log_mask(LOG_UNIMP,                              \"MPU_RBAR[%d]: No support for MPU region limit \"                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"                              \"%d\\n\",                              n, limit, TARGET_PAGE_BITS);                continue;            }        }    }    if (!hit) {        /* background fault */        *fsr = 0;        return true;    }    if (matchregion == -1) {        /* hit using the background region */        get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);    } else {        uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2);        uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1);        if (m_is_system_region(env, address)) {            /* System space is always execute never */            xn = 1;        }        *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);        if (*prot && !xn) {            *prot |= PAGE_EXEC;        }        /* We don't need to look the attribute up in the MAIR0/MAIR1         * registers because that only tells us about cacheability.         */    }    *fsr = 0x00d; /* Permission fault */    return !(*prot & (1 << access_type));}"}, {"type": "no factor", "target": "0", "code": "static int sd_create_branch(BDRVSheepdogState *s) {    int ret, fd;    uint32_t vid;    char *buf;    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);    buf = g_malloc(SD_INODE_SIZE);    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,                       s->addr, s->port);    if (ret) {        goto out;    }    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);    fd = connect_to_sdog(s->addr, s->port);    if (fd < 0) {        error_report(\"failed to connect\");        ret = fd;        goto out;    }    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,                      SD_INODE_SIZE, 0, s->cache_enabled);    closesocket(fd);    if (ret < 0) {        goto out;    }    memcpy(&s->inode, buf, sizeof(s->inode));    s->is_snapshot = false;    ret = 0;    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);out:    g_free(buf);    return ret;}"}, {"type": "no factor", "target": "0", "code": "uint8_t sd_read_data(SDState *sd) {    /* TODO: Append CRCs */    uint8_t ret;    int io_len;    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {        return 0x00;    }    if (sd->state != sd_sendingdata_state) {        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");        return 0x00;    }    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION)) {        return 0x00;    }    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;    switch (sd->current_cmd) {    case 6: /* CMD6: SWITCH_FUNCTION */        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= 64) {            sd->state = sd_transfer_state;        }        break;    case 9: /* CMD9: SEND_CSD */    case 10: /* CMD10: SEND_CID */        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= 16) {            sd->state = sd_transfer_state;        }        break;    case 11: /* CMD11: READ_DAT_UNTIL_STOP */        if (sd->data_offset == 0) {            BLK_READ_BLOCK(sd->data_start, io_len);        }        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= io_len) {            sd->data_start += io_len;            sd->data_offset = 0;            if (sd->data_start + io_len > sd->size) {                sd->card_status |= ADDRESS_ERROR;                break;            }        }        break;    case 13: /* ACMD13: SD_STATUS */        ret = sd->sd_status[sd->data_offset++];        if (sd->data_offset >= sizeof(sd->sd_status)) {            sd->state = sd_transfer_state;        }        break;    case 17: /* CMD17: READ_SINGLE_BLOCK */        if (sd->data_offset == 0) {            BLK_READ_BLOCK(sd->data_start, io_len);        }        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= io_len) {            sd->state = sd_transfer_state;        }        break;    case 18: /* CMD18: READ_MULTIPLE_BLOCK */        if (sd->data_offset == 0) {            BLK_READ_BLOCK(sd->data_start, io_len);        }        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= io_len) {            sd->data_start += io_len;            sd->data_offset = 0;            if (sd->data_start + io_len > sd->size) {                sd->card_status |= ADDRESS_ERROR;                break;            }        }        break;    case 22: /* ACMD22: SEND_NUM_WR_BLOCKS */        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= 4) {            sd->state = sd_transfer_state;        }        break;    case 30: /* CMD30: SEND_WRITE_PROT */        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= 4) {            sd->state = sd_transfer_state;        }        break;    case 51: /* ACMD51: SEND_SCR */        ret = sd->scr[sd->data_offset++];        if (sd->data_offset >= sizeof(sd->scr)) {            sd->state = sd_transfer_state;        }        break;    case 56: /* CMD56: GEN_CMD */        if (sd->data_offset == 0) {            APP_READ_BLOCK(sd->data_start, sd->blk_len);        }        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= sd->blk_len) {            sd->state = sd_transfer_state;        }        break;    default:        fprintf(stderr, \"sd_read_data: unknown command\\n\");        return 0x00;    }    return ret;}"}, {"type": "no factor", "target": "0", "code": "int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,                         AVFilterInOut *open_inputs, AVFilterInOut *open_outputs,                         AVClass *log_ctx) {    int index = 0, ret;    char chr = 0;    AVFilterInOut *curr_inputs = NULL;    do {        AVFilterContext *filter;        filters += strspn(filters, WHITESPACES);        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0) {            goto fail;        }        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0) {            goto fail;        }        if (filter->input_count == 1 && !curr_inputs && !index) {            /* First input can be omitted if it is \"[in]\" */            const char *tmp = \"[in]\";            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0) {                goto fail;            }        }        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0) {            goto fail;        }        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) < 0) {            goto fail;        }        filters += strspn(filters, WHITESPACES);        chr = *filters++;        if (chr == ';' && curr_inputs) {            av_log(log_ctx, AV_LOG_ERROR,                   \"Could not find a output to link when parsing \\\"%s\\\"\\n\",                   filters - 1);            ret = AVERROR(EINVAL);            goto fail;        }        index++;    } while (chr == ',' || chr == ';');    if (chr) {        av_log(log_ctx, AV_LOG_ERROR,               \"Unable to parse graph description substring: \\\"%s\\\"\\n\",               filters - 1);        ret = AVERROR(EINVAL);        goto fail;    }    if (open_inputs && !strcmp(open_inputs->name, \"out\") && curr_inputs) {        /* Last output can be omitted if it is \"[out]\" */        const char *tmp = \"[out]\";        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) < 0) {            goto fail;        }    }    return 0;fail:    avfilter_graph_free(graph);    free_inout(open_inputs);    free_inout(open_outputs);    free_inout(curr_inputs);    return ret;}"}, {"type": "no factor", "target": "0", "code": "static int movie_request_frame(AVFilterLink *outlink) {    AVFilterBufferRef *outpicref;    MovieContext *movie = outlink->src->priv;    int ret;    if (movie->is_done) {        return AVERROR_EOF;    }    if ((ret = movie_get_frame(outlink)) < 0) {        return ret;    }    outpicref = avfilter_ref_buffer(movie->picref, ~0);    ff_start_frame(outlink, outpicref);    ff_draw_slice(outlink, 0, outlink->h, 1);    ff_end_frame(outlink);    avfilter_unref_buffer(movie->picref);    movie->picref = NULL;    return 0;}"}, {"type": "no factor", "target": "0", "code": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma) {    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };    if (mode > 6U) {        av_log(h->avctx, AV_LOG_ERROR,               \"out of range intra chroma pred mode at %d %d\\n\",               h->mb_x, h->mb_y);        return -1;    }    if (!(h->top_samples_available & 0x8000)) {        mode = top[mode];        if (mode < 0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"top block unavailable for requested intra mode at %d %d\\n\",                   h->mb_x, h->mb_y);            return -1;        }    }    if ((h->left_samples_available & 0x8080) != 0x8080) {        mode = left[mode];        if (is_chroma && (h->left_samples_available & 0x8080)) {            // mad cow disease mode, aka MBAFF + constrained_intra_pred            mode = ALZHEIMER_DC_L0T_PRED8x8 +                   (!(h->left_samples_available & 0x8000)) +                   2 * (mode == DC_128_PRED8x8);        }        if (mode < 0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"left block unavailable for requested intra mode at %d %d\\n\",                   h->mb_x, h->mb_y);            return -1;        }    }    return mode;}"}, {"type": "no factor", "target": "0", "code": "int ff_dxva2_commit_buffer(AVCodecContext *avctx, AVDXVAContext *ctx,                           DECODER_BUFFER_DESC *dsc, unsigned type,                           const void *data, unsigned size, unsigned mb_count) {    void *dxva_data;    unsigned dxva_size;    int result;    HRESULT hr;#if CONFIG_D3D11VA    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {        hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,                                                 D3D11VA_CONTEXT(ctx)->decoder,                                                 type, &dxva_size, &dxva_data);    }#endif#if CONFIG_DXVA2    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {        hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,                                            &dxva_data, &dxva_size);    }#endif    if (FAILED(hr)) {        av_log(avctx, AV_LOG_ERROR, \"Failed to get a buffer for %u: 0x%x\\n\",               type, hr);        return -1;    }    if (size <= dxva_size) {        memcpy(dxva_data, data, size);#if CONFIG_D3D11VA        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;            memset(dsc11, 0, sizeof(*dsc11));            dsc11->BufferType = type;            dsc11->DataSize = size;            dsc11->NumMBsInBuffer = mb_count;        }#endif#if CONFIG_DXVA2        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {            DXVA2_DecodeBufferDesc *dsc2 = dsc;            memset(dsc2, 0, sizeof(*dsc2));            dsc2->CompressedBufferType = type;            dsc2->DataSize = size;            dsc2->NumMBsInBuffer = mb_count;        }#endif        result = 0;    } else {        av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);        result = -1;    }#if CONFIG_D3D11VA    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {        hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,                                                     D3D11VA_CONTEXT(ctx)->decoder,                                                     type);    }#endif#if CONFIG_DXVA2    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {        hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);    }#endif    if (FAILED(hr)) {        av_log(avctx, AV_LOG_ERROR,               \"Failed to release buffer type %u: 0x%x\\n\",               type, hr);        result = -1;    }    return result;}"}, {"type": "no factor", "target": "0", "code": "void if_start(Slirp *slirp) {    uint64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);    bool from_batchq, next_from_batchq;    struct mbuf *ifm, *ifm_next, *ifqt;    DEBUG_CALL(\"if_start\");    if (slirp->if_start_busy) {        return;    }    slirp->if_start_busy = true;    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {        ifm_next = slirp->if_fastq.ifq_next;        next_from_batchq = false;    } else if (slirp->next_m != &slirp->if_batchq) {        /* Nothing on fastq, pick up from batchq via next_m */        ifm_next = slirp->next_m;        next_from_batchq = true;    } else {        ifm_next = NULL;    }    while (ifm_next) {        ifm = ifm_next;        from_batchq = next_from_batchq;        ifm_next = ifm->ifq_next;        if (ifm_next == &slirp->if_fastq) {            /* No more packets in fastq, switch to batchq */            ifm_next = slirp->next_m;            next_from_batchq = true;        }        if (ifm_next == &slirp->if_batchq) {            /* end of batchq */            ifm_next = NULL;        }        /* Try to send packet unless it already expired */        if (ifm->expiration_date >= now && !if_encap(slirp, ifm)) {            /* Packet is delayed due to pending ARP resolution */            continue;        }        if (ifm == slirp->next_m) {            /* Set which packet to send on next iteration */            slirp->next_m = ifm->ifq_next;        }        /* Remove it from the queue */        ifqt = ifm->ifq_prev;        remque(ifm);        /* If there are more packets for this session, re-queue them */        if (ifm->ifs_next != ifm) {            struct mbuf *next = ifm->ifs_next;            insque(next, ifqt);            ifs_remque(ifm);            if (!from_batchq) {                /* Next packet in fastq is from the same session */                ifm_next = next;                next_from_batchq = false;            } else if (slirp->next_m == &slirp->if_batchq) {                /* Set next_m and ifm_next if the session packet is now the                 * only one on batchq */                slirp->next_m = ifm_next = next;            }        }        /* Update so_queued */        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {            /* If there's no more queued, reset nqueued */            ifm->ifq_so->so_nqueued = 0;        }        m_free(ifm);    }    slirp->if_start_busy = false;}"}, {"type": "no factor", "target": "0", "code": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no) {    MpegEncContext *s = &r->s;    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;    int A[2] = {0}, B[2], C[2];    int i, j;    int mx, my;    int avail_index = avail_indexes[subblock_no];    int c_off = part_sizes_w[block_type];    mv_pos += (subblock_no & 1) + (subblock_no >> 1) * s->b8_stride;    if (subblock_no == 3) {        c_off = -1;    }    if (r->avail_cache[avail_index - 1]) {        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];    }    if (r->avail_cache[avail_index - 4]) {        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];    } else {        B[0] = A[0];        B[1] = A[1];    }    if (!r->avail_cache[avail_index - 4 + c_off]) {        if (r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)) {            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];        } else {            C[0] = A[0];            C[1] = A[1];        }    } else {        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + c_off][0];        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + c_off][1];    }    mx = mid_pred(A[0], B[0], C[0]);    my = mid_pred(A[1], B[1], C[1]);    mx += r->dmv[dmv_no][0];    my += r->dmv[dmv_no][1];    for (j = 0; j < part_sizes_h[block_type]; j++) {        for (i = 0; i < part_sizes_w[block_type]; i++) {            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j * s->b8_stride][0] = mx;            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j * s->b8_stride][1] = my;        }    }}"}, {"type": "no factor", "target": "0", "code": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out) {    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);    void *dst;    if (o_out) {        *o_out = o;    }    if (!o || o->offset <= 0) {        return AVERROR_OPTION_NOT_FOUND;    }    if (o->max * den < num * intnum || o->min * den > num * intnum) {        av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);        return AVERROR(ERANGE);    }    dst = ((uint8_t *)obj) + o->offset;    switch (o->type) {    case FF_OPT_TYPE_FLAGS:    case FF_OPT_TYPE_INT:        *(int *)dst = llrint(num / den) * intnum;        break;    case FF_OPT_TYPE_INT64:        *(int64_t *)dst = llrint(num / den) * intnum;        break;    case FF_OPT_TYPE_FLOAT:        *(float *)dst = num * intnum / den;        break;    case FF_OPT_TYPE_DOUBLE:        *(double *)dst = num * intnum / den;        break;    case FF_OPT_TYPE_RATIONAL:        if ((int)num == num) {            *(AVRational *)dst = (AVRational){num * intnum, den};        } else {            *(AVRational *)dst = av_d2q(num * intnum / den, 1 << 24);        }        break;    default:        return AVERROR(EINVAL);    }    return 0;}"}, {"type": "no factor", "target": "0", "code": "static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx) {    VAAPIEncodeContext *ctx = avctx->priv_data;    VAAPIEncodeH264Context *priv = ctx->priv_data;    int hrd_buffer_size;    int hrd_initial_buffer_fullness;    if (avctx->bit_rate > INT32_MAX) {        av_log(avctx, AV_LOG_ERROR,               \"Target bitrate of 2^31 bps or higher is not supported.\\n\");        return AVERROR(EINVAL);    }    if (avctx->rc_buffer_size) {        hrd_buffer_size = avctx->rc_buffer_size;    } else {        hrd_buffer_size = avctx->bit_rate;    }    if (avctx->rc_initial_buffer_occupancy) {        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;    } else {        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;    }    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;    priv->rc_params.rc = (VAEncMiscParameterRateControl) {        .bits_per_second = avctx->bit_rate,        .target_percentage = 66,        .window_size = 1000,        .initial_qp = (avctx->qmax >= 0 ? avctx->qmax : 40),        .min_qp = (avctx->qmin >= 0 ? avctx->qmin : 18),        .basic_unit_size = 0,    };    ctx->global_params[ctx->nb_global_params] = &priv->rc_params.misc;    ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->rc_params);    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {        .initial_buffer_fullness = hrd_initial_buffer_fullness,        .buffer_size = hrd_buffer_size,    };    ctx->global_params[ctx->nb_global_params] = &priv->hrd_params.misc;    ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->hrd_params);    // These still need to be set for pic_init_qp/slice_qp_delta.    priv->fixed_qp_idr = 26;    priv->fixed_qp_p = 26;    priv->fixed_qp_b = 26;    av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\" PRId64 \" bps.\\n\",           avctx->bit_rate);    return 0;}"}, {"type": "no factor", "target": "0", "code": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    BDRVNBDState *s = bs->opaque;    struct nbd_request request;    struct nbd_reply reply;    request.type = NBD_CMD_READ;    request.from = sector_num * 512;    request.len = nb_sectors * 512;    nbd_coroutine_start(s, &request);    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {        reply.error = errno;    } else {        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);    }    nbd_coroutine_end(s, &request);    return -reply.error;}"}, {"type": "no factor", "target": "0", "code": "int usb_device_delete_addr(int busnr, int addr) {    USBBus *bus;    USBPort *port;    USBDevice *dev;    bus = usb_bus_find(busnr);    if (!bus) {        return -1;    }    TAILQ_FOREACH(port, &bus->used, next) {        if (port->dev->addr == addr) {            break;        }    }    if (!port) {        return -1;    }    dev = port->dev;    TAILQ_REMOVE(&bus->used, port, next);    bus->nused--;    usb_attach(port, NULL);    dev->info->handle_destroy(dev);    TAILQ_INSERT_TAIL(&bus->free, port, next);    bus->nfree++;    return 0;}"}, {"type": "no factor", "target": "0", "code": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,                              int element, TCGMemOp memop) {    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);    switch (memop) {    case MO_8:        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);        break;    case MO_16:        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);        break;    case MO_32:        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);        break;    case MO_64:        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);        break;    default:        g_assert_not_reached();    }}"}, {"type": "no factor", "target": "0", "code": "static av_cold int twin_decode_init(AVCodecContext *avctx) {    int ret;    TwinContext *tctx = avctx->priv_data;    int isampf, ibps;    tctx->avctx = avctx;    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;    if (!avctx->extradata || avctx->extradata_size < 12) {        av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");        return AVERROR_INVALIDDATA;    }    avctx->channels = AV_RB32(avctx->extradata) + 1;    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;    isampf = AV_RB32(avctx->extradata + 8);    if (isampf < 8 || isampf > 44) {        av_log(avctx, AV_LOG_ERROR, \"Unsupported sample rate\\n\");        return AVERROR_INVALIDDATA;    }    switch (isampf) {    case 44:        avctx->sample_rate = 44100;        break;    case 22:        avctx->sample_rate = 22050;        break;    case 11:        avctx->sample_rate = 11025;        break;    default:        avctx->sample_rate = isampf * 1000;        break;    }    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\",               avctx->channels);        return -1;    }    avctx->channel_layout = avctx->channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO;    ibps = avctx->bit_rate / (1000 * avctx->channels);    if (ibps > 255) {        av_log(avctx, AV_LOG_ERROR, \"unsupported per channel bitrate %dkbps\\n\", ibps);        return AVERROR_INVALIDDATA;    }    switch ((isampf << 8) + ibps) {    case (8 << 8) + 8:        tctx->mtab = &mode_08_08;        break;    case (11 << 8) + 8:        tctx->mtab = &mode_11_08;        break;    case (11 << 8) + 10:        tctx->mtab = &mode_11_10;        break;    case (16 << 8) + 16:        tctx->mtab = &mode_16_16;        break;    case (22 << 8) + 20:        tctx->mtab = &mode_22_20;        break;    case (22 << 8) + 24:        tctx->mtab = &mode_22_24;        break;    case (22 << 8) + 32:        tctx->mtab = &mode_22_32;        break;    case (44 << 8) + 40:        tctx->mtab = &mode_44_40;        break;    case (44 << 8) + 48:        tctx->mtab = &mode_44_48;        break;    default:        av_log(avctx, AV_LOG_ERROR,               \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\",               isampf, isampf);        return -1;    }    ff_dsputil_init(&tctx->dsp, avctx);    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);    if ((ret = init_mdct_win(tctx))) {        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");        twin_decode_close(avctx);        return ret;    }    init_bitstream_params(tctx);    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));    avcodec_get_frame_defaults(&tctx->frame);    avctx->coded_frame = &tctx->frame;    return 0;}"}, {"type": "no factor", "target": "0", "code": "static int pci_vpb_init(SysBusDevice *dev) {    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);    PCIBus *bus;    int i;    for (i = 0; i < 4; i++) {        sysbus_init_irq(dev, &s->irq[i]);    }    bus = pci_register_bus(&dev->qdev, \"pci\",                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,                           get_system_memory(), get_system_io(),                           PCI_DEVFN(11, 0), 4);    /* ??? Register memory space. */    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,                          \"pci-vpb-selfconfig\", 0x1000000);    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,                          \"pci-vpb-config\", 0x1000000);    if (s->realview) {        isa_mmio_setup(&s->isa, 0x0100000);    }    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);    pci_create_simple(bus, -1, \"versatile_pci_host\");    return 0;}"}, {"type": "no factor", "target": "0", "code": "static void do_ext_interrupt(CPUS390XState *env) {    S390CPU *cpu = s390_env_get_cpu(env);    uint64_t mask, addr;    LowCore *lowcore;    ExtQueue *q;    if (!(env->psw.mask & PSW_MASK_EXT)) {        cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");    }    lowcore = cpu_map_lowcore(env);    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);        lowcore->cpu_addr = 0;        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);        lowcore->cpu_addr = 0;        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {        g_assert(env->ext_index >= 0);        /*          * FIXME: floating IRQs should be considered by all CPUs and         *        should not get cleared by CPU reset.         */        q = &env->ext_queue[env->ext_index];        lowcore->ext_int_code = cpu_to_be16(q->code);        lowcore->ext_params = cpu_to_be32(q->param);        lowcore->ext_params2 = cpu_to_be64(q->param64);        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);        env->ext_index--;        if (env->ext_index == -1) {            env->pending_int &= ~INTERRUPT_EXT_SERVICE;        }    } else {        g_assert_not_reached();    }    mask = be64_to_cpu(lowcore->external_new_psw.mask);    addr = be64_to_cpu(lowcore->external_new_psw.addr);    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);    cpu_unmap_lowcore(lowcore);    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__, env->psw.mask, env->psw.addr);    load_psw(env, mask, addr);}"}, {"type": "no factor", "target": "0", "code": "static void decode_delta_l(uint8_t *dst,                           const uint8_t *buf, const uint8_t *buf_end,                           int w, int flag, int bpp, int dst_size) {    GetByteContext off0, off1, dgb, ogb;    PutByteContext pb;    unsigned poff0, poff1;    int i, k, dstpitch;    int planepitch_byte = (w + 7) / 8;    int planepitch = ((w + 15) / 16) * 2;    int pitch = planepitch * bpp;    if (buf_end - buf <= 64) {        return;    }    bytestream2_init(&off0, buf, buf_end - buf);    bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));    bytestream2_init_writer(&pb, dst, dst_size);    dstpitch = flag ? (((w + 7) / 8) * bpp) : 2;    for (k = 0; k < bpp; k++) {        poff0 = bytestream2_get_be32(&off0);        poff1 = bytestream2_get_be32(&off1);        if (!poff0) {            continue;        }        if (2LL * poff0 >= buf_end - buf) {            return;        }        if (2LL * poff1 >= buf_end - buf) {            return;        }        bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));        bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));        while (bytestream2_peek_be16(&ogb) != 0xFFFF) {            uint32_t offset = bytestream2_get_be16(&ogb);            int16_t cnt = bytestream2_get_be16(&ogb);            uint16_t data;            offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;            if (cnt < 0) {                bytestream2_seek_p(&pb, offset, SEEK_SET);                cnt = -cnt;                data = bytestream2_get_be16(&dgb);                for (i = 0; i < cnt; i++) {                    bytestream2_put_be16(&pb, data);                    bytestream2_skip_p(&pb, dstpitch - 2);                }            } else {                bytestream2_seek_p(&pb, offset, SEEK_SET);                for (i = 0; i < cnt; i++) {                    data = bytestream2_get_be16(&dgb);                    bytestream2_put_be16(&pb, data);                    bytestream2_skip_p(&pb, dstpitch - 2);                }            }        }    }}"}, {"type": "no factor", "target": "0", "code": "static int device_try_init(AVFormatContext *ctx,                           enum AVPixelFormat pix_fmt,                           int *width,                           int *height,                           uint32_t *desired_format,                           enum AVCodecID *codec_id) {    int ret, i;    *desired_format = avpriv_fmt_ff2v4l(pix_fmt, ctx->video_codec_id);    if (*desired_format) {        ret = device_init(ctx, width, height, *desired_format);        if (ret < 0) {            *desired_format = 0;            if (ret != AVERROR(EINVAL)) {                return ret;            }        }    }    if (!*desired_format) {        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {                av_log(ctx, AV_LOG_DEBUG, \"Trying to set codec:%s pix_fmt:%s\\n\",                       avcodec_get_name(avpriv_fmt_conversion_table[i].codec_id),                       (char *)av_x_if_null(av_get_pix_fmt_name(avpriv_fmt_conversion_table[i].ff_fmt), \"none\"));                *desired_format = avpriv_fmt_conversion_table[i].v4l2_fmt;                ret = device_init(ctx, width, height, *desired_format);                if (ret >= 0) {                    break;                } else if (ret != AVERROR(EINVAL)) {                    return ret;                }                *desired_format = 0;            }        }        if (*desired_format == 0) {            av_log(ctx, AV_LOG_ERROR, \"Cannot find a proper format for \"                   \"codec '%s' (id %d), pixel format '%s' (id %d)\\n\",                   avcodec_get_name(ctx->video_codec_id), ctx->video_codec_id,                   (char *)av_x_if_null(av_get_pix_fmt_name(pix_fmt), \"none\"), pix_fmt);            ret = AVERROR(EINVAL);        }    }    *codec_id = avpriv_fmt_v4l2codec(*desired_format);    av_assert0(*codec_id != AV_CODEC_ID_NONE);    return ret;}"}, {"type": "no factor", "target": "0", "code": "static void migrate_params_test_apply(MigrateSetParameters *params,                                      MigrationParameters *dest) {    *dest = migrate_get_current()->parameters;    /* TODO use QAPI_CLONE() instead of duplicating it inline */    if (params->has_compress_level) {        dest->compress_level = params->compress_level;    }    if (params->has_compress_threads) {        dest->compress_threads = params->compress_threads;    }    if (params->has_decompress_threads) {        dest->decompress_threads = params->decompress_threads;    }    if (params->has_cpu_throttle_initial) {        dest->cpu_throttle_initial = params->cpu_throttle_initial;    }    if (params->has_cpu_throttle_increment) {        dest->cpu_throttle_increment = params->cpu_throttle_increment;    }    if (params->has_tls_creds) {        dest->tls_creds = g_strdup(params->tls_creds);    }    if (params->has_tls_hostname) {        dest->tls_hostname = g_strdup(params->tls_hostname);    }    if (params->has_max_bandwidth) {        dest->max_bandwidth = params->max_bandwidth;    }    if (params->has_downtime_limit) {        dest->downtime_limit = params->downtime_limit;    }    if (params->has_x_checkpoint_delay) {        dest->x_checkpoint_delay = params->x_checkpoint_delay;    }    if (params->has_block_incremental) {        dest->block_incremental = params->block_incremental;    }}"}, {"type": "no factor", "target": "0", "code": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,                                  VirtIOSCSIReq *req) {    assert(req->elem.out_num && req->elem.in_num);    req->vq = vq;    req->dev = s;    req->sreq = NULL;    req->req.buf = req->elem.out_sg[0].iov_base;    req->resp.buf = req->elem.in_sg[0].iov_base;    if (req->elem.out_num > 1) {        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],                               &req->elem.out_addr[1],                               req->elem.out_num - 1);    } else {        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],                               &req->elem.in_addr[1],                               req->elem.in_num - 1);    }}"}, {"type": "no factor", "target": "0", "code": "static void create_map(vorbis_context *vc, unsigned floor_number) {    vorbis_floor *floors = vc->floors;    vorbis_floor0 *vf;    int idx;    int blockflag, n;    int32_t *map;    for (blockflag = 0; blockflag < 2; ++blockflag) {        n = vc->blocksize[blockflag] / 2;        floors[floor_number].data.t0.map[blockflag] =            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel        map = floors[floor_number].data.t0.map[blockflag];        vf = &floors[floor_number].data.t0;        for (idx = 0; idx < n; ++idx) {            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));            if (vf->bark_map_size - 1 < map[idx]) {                map[idx] = vf->bark_map_size - 1;            }        }        map[n] = -1;        vf->map_size[blockflag] = n;    }    for (idx = 0; idx <= n; ++idx) {        av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);    }}"}, {"type": "no factor", "target": "0", "code": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,                                           sPAPRMachineState *spapr,                                           uint32_t token, uint32_t nargs,                                           target_ulong args, uint32_t nret,                                           target_ulong rets){    sPAPRPHBState *sphb;    PCIDevice *pdev;    uint32_t addr, option;    uint64_t buid;    if ((nargs != 4) || (nret != 2)) {        goto param_error_exit;    }    buid = rtas_ldq(args, 1);    sphb = spapr_pci_find_phb(spapr, buid);    if (!sphb) {        goto param_error_exit;    }    if (!spapr_phb_eeh_available(sphb)) {        goto param_error_exit;    }    /*     * We always have PE address of form \"00BB0001\". \"BB\"     * represents the bus number of PE's primary bus.     */    option = rtas_ld(args, 3);    switch (option) {    case RTAS_GET_PE_ADDR:        addr = rtas_ld(args, 0);        pdev = spapr_pci_find_dev(spapr, buid, addr);        if (!pdev) {            goto param_error_exit;        }        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);        break;    case RTAS_GET_PE_MODE:        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);        break;    default:        goto param_error_exit;    }    rtas_st(rets, 0, RTAS_OUT_SUCCESS);    return;param_error_exit:    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);}"}, {"type": "no factor", "target": "0", "code": "av_cold int ffv1_init_slice_contexts(FFV1Context *f){    int i;    f->slice_count = f->num_h_slices * f->num_v_slices;    if (f->slice_count <= 0) {        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");        return AVERROR(EINVAL);    }    for (i = 0; i < f->slice_count; i++) {        FFV1Context *fs = av_mallocz(sizeof(*fs));        int sx = i % f->num_h_slices;        int sy = i / f->num_h_slices;        int sxs = f->avctx->width * sx / f->num_h_slices;        int sxe = f->avctx->width * (sx + 1) / f->num_h_slices;        int sys = f->avctx->height * sy / f->num_v_slices;        int sye = f->avctx->height * (sy + 1) / f->num_v_slices;        f->slice_context[i] = fs;        memcpy(fs, f, sizeof(*fs));        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));        fs->slice_width = sxe - sxs;        fs->slice_height = sye - sys;        fs->slice_x = sxs;        fs->slice_y = sys;        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer));        if (!fs->sample_buffer)            return AVERROR(ENOMEM);    }    return 0;}"}, {"type": "no factor", "target": "0", "code": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp){    /* We don't actually refresh here, but just return data queried in     * iscsi_open(): iscsi targets don't change their limits. */    IscsiLun *iscsilun = bs->opaque;    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;    bs->request_alignment = iscsilun->block_size;    if (iscsilun->bl.max_xfer_len) {        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);    }    if (max_xfer_len * iscsilun->block_size < INT_MAX) {        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;    }    if (iscsilun->lbp.lbpu) {        if (iscsilun->bl.max_unmap < 0xffffffff) {            bs->bl.max_discard = sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);        }        bs->bl.discard_alignment = sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);    } else {        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;    }    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {        bs->bl.max_pwrite_zeroes = iscsilun->bl.max_ws_len * iscsilun->block_size;    }    if (iscsilun->lbp.lbpws) {        bs->bl.pwrite_zeroes_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size;    } else {        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;    }    if (iscsilun->bl.opt_xfer_len &&        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len * iscsilun->block_size);    }}"}, {"type": "no factor", "target": "0", "code": "static int mtv_read_header(AVFormatContext *s){    MTVDemuxContext *mtv = s->priv_data;    AVIOContext *pb = s->pb;    AVStream *st;    unsigned int audio_subsegments;    avio_skip(pb, 3);    mtv->file_size = avio_rl32(pb);    mtv->segments = avio_rl32(pb);    avio_skip(pb, 32);    mtv->audio_identifier = avio_rl24(pb);    mtv->audio_br = avio_rl16(pb);    mtv->img_colorfmt = avio_rl24(pb);    mtv->img_bpp = avio_r8(pb);    mtv->img_width = avio_rl16(pb);    mtv->img_height = avio_rl16(pb);    mtv->img_segment_size = avio_rl16(pb);    /* Calculate width and height if missing from header */    if (mtv->img_bpp >> 3) {        if (!mtv->img_width && mtv->img_height)            mtv->img_width = mtv->img_segment_size / (mtv->img_bpp >> 3) / mtv->img_height;        if (!mtv->img_height && mtv->img_width)            mtv->img_height = mtv->img_segment_size / (mtv->img_bpp >> 3) / mtv->img_width;    }    if (!mtv->img_height || !mtv->img_width || !mtv->img_segment_size) {        av_log(s, AV_LOG_ERROR, \"width or height or segment_size is invalid and I cannot calculate them from other information\\n\");        return AVERROR(EINVAL);    }    avio_skip(pb, 4);    audio_subsegments = avio_rl16(pb);    if (audio_subsegments == 0) {        avpriv_request_sample(s, \"MTV files without audio\");        return AVERROR_PATCHWELCOME;    }    mtv->full_segment_size =        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +        mtv->img_segment_size;    mtv->video_fps = (mtv->audio_br / 4) / audio_subsegments;    // FIXME Add sanity check here    // all systems go! init decoders    // video - raw rgb565    st = avformat_new_stream(s, NULL);    if (!st)        return AVERROR(ENOMEM);    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;    st->codec->pix_fmt = AV_PIX_FMT_RGB565BE;    st->codec->width = mtv->img_width;    st->codec->height = mtv->img_height;    st->codec->sample_rate = mtv->video_fps;    st->codec->extradata = av_strdup(\"BottomUp\");    st->codec->extradata_size = 9;    // audio - mp3    st = avformat_new_stream(s, NULL);    if (!st)        return AVERROR(ENOMEM);    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);    st->codec->codec_type = AVMEDIA_TYPE_AUDIO;    st->codec->codec_id = AV_CODEC_ID_MP3;    st->codec->bit_rate = mtv->audio_br;    st->need_parsing = AVSTREAM_PARSE_FULL;    // Jump over header    if (avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE)        return AVERROR(EIO);    return 0;}"}, {"type": "no factor", "target": "0", "code": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,                                    bool last_stage, uint64_t *bytes_transferred){    int pages = -1;    uint64_t bytes_xmit;    uint8_t *p;    int ret;    RAMBlock *block = pss->block;    ram_addr_t offset = pss->offset;    p = block->host + offset;    bytes_xmit = 0;    ret = ram_control_save_page(f, block->offset, offset, TARGET_PAGE_SIZE, &bytes_xmit);    if (bytes_xmit) {        *bytes_transferred += bytes_xmit;        pages = 1;    }    if (block == last_sent_block) {        offset |= RAM_SAVE_FLAG_CONTINUE;    }    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {        if (ret != RAM_SAVE_CONTROL_DELAYED) {            if (bytes_xmit > 0) {                acct_info.norm_pages++;            } else if (bytes_xmit == 0) {                acct_info.dup_pages++;            }        }    } else {        /* When starting the process of a new block, the first page of         * the block should be sent out before other pages in the same         * block, and all the pages in last block should have been sent         * out, keeping this order is important, because the 'cont' flag         * is used to avoid resending the block name.         */        if (block != last_sent_block) {            flush_compressed_data(f);            pages = save_zero_page(f, block, offset, p, bytes_transferred);            if (pages == -1) {                set_compress_params(&comp_param[0], block, offset);                /* Use the qemu thread to compress the data to make sure the                 * first page is sent out before other pages                 */                bytes_xmit = do_compress_ram_page(&comp_param[0]);                acct_info.norm_pages++;                qemu_put_qemu_file(f, comp_param[0].file);                *bytes_transferred += bytes_xmit;                pages = 1;            }        } else {            pages = save_zero_page(f, block, offset, p, bytes_transferred);            if (pages == -1) {                pages = compress_page_with_multi_thread(f, block, offset, bytes_transferred);            }        }    }    return pages;}"}, {"type": "no factor", "target": "0", "code": "static void test_io_channel_ipv4(bool async){    SocketAddress *listen_addr = g_new0(SocketAddress, 1);    SocketAddress *connect_addr = g_new0(SocketAddress, 1);    listen_addr->type = SOCKET_ADDRESS_KIND_INET;    listen_addr->u.inet = g_new0(InetSocketAddress, 1);    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");    listen_addr->u.inet->port = NULL; /* Auto-select */    connect_addr->type = SOCKET_ADDRESS_KIND_INET;    connect_addr->u.inet = g_new0(InetSocketAddress, 1);    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");    connect_addr->u.inet->port = NULL; /* Filled in later */    test_io_channel(async, listen_addr, connect_addr);    qapi_free_SocketAddress(listen_addr);    qapi_free_SocketAddress(connect_addr);}"}, {"type": "no factor", "target": "0", "code": "static void n8x0_nand_setup(struct n800_s *s){    char *otp_region;    DriveInfo *dinfo;    s->nand = qdev_create(NULL, \"onenand\");    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);    /* Either 0x40 or 0x48 are OK for the device ID */    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);    qdev_prop_set_uint16(s->nand, \"version_id\", 0);    qdev_prop_set_int32(s->nand, \"shift\", 1);    dinfo = drive_get(IF_MTD, 0, 0);    if (dinfo) {        qdev_prop_set_drive_nofail(s->nand, \"drive\",                                   blk_bs(blk_by_legacy_dinfo(dinfo)));    }    qdev_init_nofail(s->nand);    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));    otp_region = onenand_raw_otp(s->nand);    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));    /* XXX: in theory should also update the OOB for both pages */}"}, {"type": "no factor", "target": "0", "code": "static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride){    PixletContext *ctx = avctx->priv_data;    GetBitContext *b = &ctx->gbit;    unsigned cnt1, nbits, k, j = 0, i = 0;    int64_t value, state = 3;    int rlen, escape, flag = 0;    while (i < size) {        nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14);        cnt1 = get_unary(b, 0, 8);        if (cnt1 < 8) {            value = show_bits(b, nbits);            if (value <= 1) {                skip_bits(b, nbits - 1);                escape = ((1 << nbits) - 1) * cnt1;            } else {                skip_bits(b, nbits);                escape = value + ((1 << nbits) - 1) * cnt1 - 1;            }        } else {            escape = get_bits(b, 16);        }        value = -((escape + flag) & 1) | 1;        dst[j++] = value * ((escape + flag + 1) >> 1);        i++;        if (j == width) {            j = 0;            dst += stride;        }        state = 120 * (escape + flag) + state - (120 * state >> 8);        flag = 0;        if (state * 4 > 0xFF || i >= size)            continue;        nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24;        escape = av_mod_uintp2(16383, nbits);        cnt1 = get_unary(b, 0, 8);        if (cnt1 > 7) {            rlen = get_bits(b, 16);        } else {            value = show_bits(b, nbits);            if (value > 1) {                skip_bits(b, nbits);                rlen = value + escape * cnt1 - 1;            } else {                skip_bits(b, nbits - 1);                rlen = escape * cnt1;            }        }        if (i + rlen > size)            return AVERROR_INVALIDDATA;        i += rlen;        for (k = 0; k < rlen; k++) {            dst[j++] = 0;            if (j == width) {                j = 0;                dst += stride;            }        }        state = 0;        flag = rlen < 0xFFFF ? 1 : 0;    }    align_get_bits(b);    return get_bits_count(b) >> 3;}"}, {"type": "no factor", "target": "0", "code": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,                             int *data_size, AVPacket *pkt){    CDXLVideoContext *c = avctx->priv_data;    AVFrame *const p = &c->frame;    int ret, w, h, encoding, format, buf_size = pkt->size;    const uint8_t *buf = pkt->data;    if (buf_size < 32)        return AVERROR_INVALIDDATA;    encoding = buf[1] & 7;    format = buf[1] & 0xE0;    w = AV_RB16(&buf[14]);    h = AV_RB16(&buf[16]);    c->bpp = buf[19];    c->palette_size = AV_RB16(&buf[20]);    c->palette = buf + 32;    c->video = c->palette + c->palette_size;    c->video_size = buf_size - c->palette_size - 32;    if (c->palette_size > 512)        return AVERROR_INVALIDDATA;    if (buf_size < c->palette_size + 32)        return AVERROR_INVALIDDATA;    if (c->bpp < 1)        return AVERROR_INVALIDDATA;    if (c->bpp > 8) {        av_log_ask_for_sample(avctx, \"unsupported pixel size: %d\\n\", c->bpp);        return AVERROR_PATCHWELCOME;    }    if (format) {        av_log_ask_for_sample(avctx, \"unsupported pixel format: %d\\n\", format);        return AVERROR_PATCHWELCOME;    }    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)        return ret;    if (w != avctx->width || h != avctx->height)        avcodec_set_dimensions(avctx, w, h);    if (c->video_size < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8)        return AVERROR_INVALIDDATA;    if (!encoding && c->palette_size && c->bpp <= 8) {        avctx->pix_fmt = PIX_FMT_PAL8;    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {        if (c->palette_size != (1 << (c->bpp - 1)))            return AVERROR_INVALIDDATA;        avctx->pix_fmt = PIX_FMT_BGR24;    } else {        av_log_ask_for_sample(avctx, \"unsupported encoding %d and bpp %d\\n\",                              encoding, c->bpp);        return AVERROR_PATCHWELCOME;    }    if (p->data[0])        avctx->release_buffer(avctx, p);    p->reference = 0;    if ((ret = avctx->get_buffer(avctx, p)) < 0) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");        return ret;    }    p->pict_type = AV_PICTURE_TYPE_I;    if (encoding) {        av_fast_padded_malloc(&c->new_video, &c->new_video_size,                              h * w + FF_INPUT_BUFFER_PADDING_SIZE);        if (!c->new_video)            return AVERROR(ENOMEM);        if (c->bpp == 8)            cdxl_decode_ham8(c);        else            cdxl_decode_ham6(c);    } else {        cdxl_decode_rgb(c);    }    *data_size = sizeof(AVFrame);    *(AVFrame *)data = c->frame;    return buf_size;}"}, {"type": "no factor", "target": "0", "code": "av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp){    int cpu_flags = av_get_cpu_flags();#if HAVE_6REGS && HAVE_INLINE_ASM    if (INLINE_AMD3DNOWEXT(cpu_flags)) {        fdsp->vector_fmul_window = vector_fmul_window_3dnowext;    }    if (INLINE_SSE(cpu_flags)) {        fdsp->vector_fmul_window = vector_fmul_window_sse;    }#endif    if (EXTERNAL_SSE(cpu_flags)) {        fdsp->vector_fmul = ff_vector_fmul_sse;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;        fdsp->vector_fmul_add = ff_vector_fmul_add_sse;        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;        fdsp->butterflies_float = ff_butterflies_float_sse;    }    if (EXTERNAL_SSE2(cpu_flags)) {        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;    }    if (EXTERNAL_AVX(cpu_flags)) {        fdsp->vector_fmul = ff_vector_fmul_avx;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;        fdsp->vector_fmul_add = ff_vector_fmul_add_avx;        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;    }}"}, {"type": "no factor", "target": "0", "code": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,                             const int32_t **lumSrc, int lumFilterSize,                             const int16_t *chrFilter, const int32_t **chrUSrc,                             const int32_t **chrVSrc, int chrFilterSize,                             const int32_t **alpSrc, uint16_t *dest, int dstW,                             int y, enum AVPixelFormat target, int hasAlpha, int eightbytes){    int i;    int A = 0xffff << 14;    for (i = 0; i < dstW; i++) {        int j;        int Y = -0x40000000;        int U = -128 << 23; // 19        int V = -128 << 23;        int R, G, B;        for (j = 0; j < lumFilterSize; j++) {            Y += lumSrc[j][i] * (unsigned)lumFilter[j];        }        for (j = 0; j < chrFilterSize; j++) {            U += chrUSrc[j][i] * (unsigned)chrFilter[j];            V += chrVSrc[j][i] * (unsigned)chrFilter[j];        }        if (hasAlpha) {            A = -0x40000000;            for (j = 0; j < lumFilterSize; j++) {                A += alpSrc[j][i] * (unsigned)lumFilter[j];            }            A >>= 1;            A += 0x20002000;        }        // 8bit: 12+15=27; 16-bit: 12+19=31        Y >>= 14; // 10        Y += 0x10000;        U >>= 14;        V >>= 14;        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit        Y -= c->yuv2rgb_y_offset;        Y *= c->yuv2rgb_y_coeff;        Y += 1 << 13; // 21        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit        R = V * c->yuv2rgb_v2r_coeff;        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;        B = U * c->yuv2rgb_u2b_coeff;        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit        output_pixel(&dest[0], av_clip_uintp2(R + Y, 30) >> 14);        output_pixel(&dest[1], av_clip_uintp2(G + Y, 30) >> 14);        output_pixel(&dest[2], av_clip_uintp2(B + Y, 30) >> 14);        if (eightbytes) {            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);            dest += 4;        } else {            dest += 3;        }    }}"}, {"type": "no factor", "target": "0", "code": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp){    const QDictEntry *ent;    const char *arg_name;    const QObject *arg_obj;    bool has_exec_key = false;    QDict *dict = NULL;    if (qobject_type(request) != QTYPE_QDICT) {        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,                   \"request is not a dictionary\");        return NULL;    }    dict = qobject_to_qdict(request);    for (ent = qdict_first(dict); ent; ent = qdict_next(dict, ent)) {        arg_name = qdict_entry_key(ent);        arg_obj = qdict_entry_value(ent);        if (!strcmp(arg_name, \"execute\")) {            if (qobject_type(arg_obj) != QTYPE_QSTRING) {                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",                           \"string\");                return NULL;            }            has_exec_key = true;        } else if (strcmp(arg_name, \"arguments\")) {            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);            return NULL;        }    }    if (!has_exec_key) {        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");        return NULL;    }    return dict;}"}, {"type": "no factor", "target": "0", "code": "static int gif_read_image(GifState *s){    int left, top, width, height, bits_per_pixel, code_size, flags;    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;    uint8_t *ptr, *spal, *palette, *ptr1;    left = bytestream_get_le16(&s->bytestream);    top = bytestream_get_le16(&s->bytestream);    width = bytestream_get_le16(&s->bytestream);    height = bytestream_get_le16(&s->bytestream);    flags = bytestream_get_byte(&s->bytestream);    is_interleaved = flags & 0x40;    has_local_palette = flags & 0x80;    bits_per_pixel = (flags & 0x07) + 1;    av_dlog(s->avctx, \"image x=%d y=%d w=%d h=%d\\n\", left, top, width, height);    if (has_local_palette) {        bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel));        palette = s->local_palette;    } else {        palette = s->global_palette;        bits_per_pixel = s->bits_per_pixel;    }    /* verify that all the image is inside the screen dimensions */    if (left + width > s->screen_width ||        top + height > s->screen_height)        return AVERROR(EINVAL);    /* build the palette */    n = (1 << bits_per_pixel);    spal = palette;    for (i = 0; i < n; i++) {        s->image_palette[i] = (0xffu << 24) | AV_RB24(spal);        spal += 3;    }    for (; i < 256; i++)        s->image_palette[i] = (0xffu << 24);    /* handle transparency */    if (s->transparent_color_index >= 0)        s->image_palette[s->transparent_color_index] = 0;    /* now get the image data */    code_size = bytestream_get_byte(&s->bytestream);    ff_lzw_decode_init(s->lzw, code_size, s->bytestream,                       s->bytestream_end - s->bytestream, FF_LZW_GIF);    /* read all the image */    linesize = s->picture.linesize[0];    ptr1 = s->picture.data[0] + top * linesize + left;    ptr = ptr1;    pass = 0;    y1 = 0;    for (y = 0; y < height; y++) {        ff_lzw_decode(s->lzw, ptr, width);        if (is_interleaved) {            switch (pass) {            default:            case 0:            case 1:                y1 += 8;                ptr += linesize * 8;                if (y1 >= height) {                    y1 = pass ? 2 : 4;                    ptr = ptr1 + linesize * y1;                    pass++;                }                break;            case 2:                y1 += 4;                ptr += linesize * 4;                if (y1 >= height) {                    y1 = 1;                    ptr = ptr1 + linesize;                    pass++;                }                break;            case 3:                y1 += 2;                ptr += linesize * 2;                break;            }        } else {            ptr += linesize;        }    }    /* read the garbage data until end marker is found */    ff_lzw_decode_tail(s->lzw);    s->bytestream = ff_lzw_cur_ptr(s->lzw);    return 0;}"}, {"type": "no factor", "target": "0", "code": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka,                           target_siginfo_t *info, target_sigset_t *set,                           CPUState *env) {    struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));    int err = 0;#if 0    if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))        return 1;#endif    __put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);    __put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);    err |= copy_siginfo_to_user(&frame->info, info);    /* Clear all the bits of the ucontext we don't use. */    err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));    err |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/                            env, set->sig[0]);    err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));    if (err == 0) {        err = setup_return(env, ka, &frame->retcode, frame, usig);    }    if (err == 0) {        /*         * For realtime signals we must also set the second and third         * arguments for the signal handler.         *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06         */        env->regs[1] = (target_ulong)frame->pinfo;        env->regs[2] = (target_ulong)frame->puc;    }    // return err;}"}, {"type": "no factor", "target": "0", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val) {    EHCIState *s = ptr;    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);    uint32_t old = *mmio;    int i;    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);    /* Only aligned reads are allowed on OHCI */    if (addr & 3) {        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {        handle_port_status_write(s, (addr - PORTSC) / 4, val);        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);        return;    }    if (addr < OPREGBASE) {        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    /* Do any register specific pre-write processing here. */    switch (addr) {    case USBCMD:        if (val & USBCMD_HCRESET) {            ehci_reset(s);            val = s->usbcmd;            break;        }        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {            if (!ehci_enabled(s)) {                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));                SET_LAST_RUN_CLOCK(s);            }            ehci_update_halt(s);        }        /* not supporting dynamic frame list size at the moment */        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",                    val & USBCMD_FLS);            val &= ~USBCMD_FLS;        }        break;    case USBSTS:        val &= USBSTS_RO_MASK;  // bits 6 through 31 are RO        ehci_clear_usbsts(s, val);  // bits 0 through 5 are R/WC        val = s->usbcmd;        ehci_set_interrupt(s, 0);        break;    case USBINTR:        val &= USBINTR_MASK;        break;    case FRINDEX:        val &= 0x00003ff8;  /* frindex is 14bits and always a multiple of 8 */        break;    case CONFIGFLAG:        val &= 0x1;        if (val) {            for (i = 0; i < NB_PORTS; i++) {                handle_port_owner_write(s, i, 0);            }        }        break;    case PERIODICLISTBASE:        if (ehci_periodic_enabled(s)) {            fprintf(stderr,                    \"ehci: PERIODIC list base register set while periodic schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    case ASYNCLISTADDR:        if (ehci_async_enabled(s)) {            fprintf(stderr,                    \"ehci: ASYNC list address register set while async schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    }    *mmio = val;    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);}"}, {"type": "no factor", "target": "0", "code": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp){    int i;    GICState *s = KVM_ARM_GIC(dev);    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);    kgc->parent_realize(dev, errp);    if (error_is_set(errp)) {        return;    }    i = s->num_irq - GIC_INTERNAL;    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.     * GPIO array layout is thus:     *  [0..N-1] SPIs     *  [N..N+31] PPIs for CPU 0     *  [N+32..N+63] PPIs for CPU 1     *   ...     */    i += (GIC_INTERNAL * s->num_cpu);    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);    /* We never use our outbound IRQ lines but provide them so that     * we maintain the same interface as the non-KVM GIC.     */    for (i = 0; i < s->num_cpu; i++) {        sysbus_init_irq(sbd, &s->parent_irq[i]);    }    /* Distributor */    memory_region_init_reservation(&s->iomem, OBJECT(s), \"kvm-gic_dist\", 0x1000);    sysbus_init_mmio(sbd, &s->iomem);    kvm_arm_register_device(&s->iomem,                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) |                                KVM_VGIC_V2_ADDR_TYPE_DIST);    /* CPU interface for current core. Unlike arm_gic, we don't     * provide the \"interface for core #N\" memory regions, because     * cores with a VGIC don't have those.     */    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s), \"kvm-gic_cpu\", 0x1000);    sysbus_init_mmio(sbd, &s->cpuiomem[0]);    kvm_arm_register_device(&s->cpuiomem[0],                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) |                                KVM_VGIC_V2_ADDR_TYPE_CPU);}"}, {"type": "no factor", "target": "0", "code": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr){    unsigned long page_index;    int ret;#ifdef _WIN32    DWORD temp;#endif    page_index = ram_addr >> TARGET_PAGE_BITS;    if (!modified_ram_pages_table[page_index]) {#if 0        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);#endif        modified_ram_pages_table[page_index] = 1;        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {            /* flush */#ifdef _WIN32            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,                                  &nb_modified_ram_pages,                                  sizeof(nb_modified_ram_pages),                                  NULL, 0, &temp, NULL);#else            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,                        &nb_modified_ram_pages);#endif            kqemu_reset_modified_ram_pages();        }    }}"}, {"type": "no factor", "target": "0", "code": "static int read_gab2_sub(AVStream *st, AVPacket *pkt){    if (pkt->size >= 7 &&        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {        uint8_t desc[256];        int score = AVPROBE_SCORE_EXTENSION, ret;        AVIStream *ast = st->priv_data;        AVInputFormat *sub_demuxer;        AVRational time_base;        AVIOContext *pb = avio_alloc_context(pkt->data + 7,                                             pkt->size - 7,                                             0, NULL, NULL, NULL, NULL);        AVProbeData pd;        unsigned int desc_len = avio_rl32(pb);        if (desc_len > pb->buf_end - pb->buf_ptr)            goto error;        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));        avio_skip(pb, desc_len - ret);        if (*desc)            av_dict_set(&st->metadata, \"title\", desc, 0);        avio_rl16(pb);  /* flags? */        avio_rl32(pb);  /* data size */        pd = (AVProbeData) { .buf = pb->buf_ptr,                             .buf_size = pb->buf_end - pb->buf_ptr };        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))            goto error;        if (!(ast->sub_ctx = avformat_alloc_context()))            goto error;        ast->sub_ctx->pb = pb;        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);            *st->codec = *ast->sub_ctx->streams[0]->codec;            ast->sub_ctx->streams[0]->codec->extradata = NULL;            time_base = ast->sub_ctx->streams[0]->time_base;            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);        }        ast->sub_buffer = pkt->data;        memset(pkt, 0, sizeof(*pkt));        return 1;    error:        av_freep(&pb);    }    return 0;}"}, {"type": "no factor", "target": "0", "code": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos){    PCIDevice *pdev = &vdev->pdev;    uint8_t cap_id, next, size;    int ret;    cap_id = pdev->config[pos];    next = pdev->config[pos + PCI_CAP_LIST_NEXT];    /*     * If it becomes important to configure capabilities to their actual     * size, use this as the default when it's something we don't recognize.     * Since QEMU doesn't actually handle many of the config accesses,     * exact size doesn't seem worthwhile.     */    size = vfio_std_cap_max_size(pdev, pos);    /*     * pci_add_capability always inserts the new capability at the head     * of the chain. Therefore to end up with a chain that matches the     * physical device, we insert from the end by making this recursive.     * This is also why we pre-calculate size above as cached config space     * will be changed as we unwind the stack.     */    if (next) {        ret = vfio_add_std_cap(vdev, next);        if (ret) {            return ret;        }    } else {        /* Begin the rebuild, use QEMU emulated list bits */        pdev->config[PCI_CAPABILITY_LIST] = 0;        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;        vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;    }    /* Use emulated next pointer to allow dropping caps */    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);    switch (cap_id) {    case PCI_CAP_ID_MSI:        ret = vfio_msi_setup(vdev, pos);        break;    case PCI_CAP_ID_EXP:        vfio_check_pcie_flr(vdev, pos);        ret = vfio_setup_pcie_cap(vdev, pos, size);        break;    case PCI_CAP_ID_MSIX:        ret = vfio_msix_setup(vdev, pos);        break;    case PCI_CAP_ID_PM:        vfio_check_pm_reset(vdev, pos);        vdev->pm_cap = pos;        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    case PCI_CAP_ID_AF:        vfio_check_af_flr(vdev, pos);        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    default:        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    }    if (ret < 0) {        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,                     vdev->host.bus, vdev->host.slot, vdev->host.function,                     cap_id, size, pos, ret);        return ret;    }    return 0;}"}, {"type": "no factor", "target": "0", "code": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,                            const char *model, const char *name,                            const char *ifname, const char *script,                            const char *downscript, const char *vhostfdname,                            int vnet_hdr, int fd){    TAPState *s;    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);    if (!s) {        close(fd);        return -1;    }    if (tap_set_sndbuf(s->fd, tap) < 0) {        return -1;    }    if (tap->has_fd || tap->has_fds) {        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);    } else if (tap->has_helper) {        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\", tap->helper);    } else {        snprintf(s->nc.info_str, sizeof(s->nc.info_str),                 \"ifname=%s,script=%s,downscript=%s\", ifname, script, downscript);        if (strcmp(downscript, \"no\") != 0) {            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);            snprintf(s->down_script_arg, sizeof(s->down_script_arg), \"%s\", ifname);        }    }    if (tap->has_vhost ? tap->vhost : vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {        int vhostfd;        if (tap->has_vhostfd) {            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);            if (vhostfd == -1) {                return -1;            }        } else {            vhostfd = -1;        }        s->vhost_net = vhost_net_init(&s->nc, vhostfd,                                      tap->has_vhostforce && tap->vhostforce);        if (!s->vhost_net) {            error_report(\"vhost-net requested but could not be initialized\");            return -1;        }    } else if (tap->has_vhostfd || tap->has_vhostfds) {        error_report(\"vhostfd= is not valid without vhost\");        return -1;    }    return 0;}"}, {"type": "no factor", "target": "0", "code": "static int vc1_filter_line(uint8_t *src, int stride, int pq){    int a0, a1, a2, a3, d, clip, filt3 = 0;    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;    a0 = (2 * (src[-2 * stride] - src[1 * stride]) - 5 * (src[-1 * stride] - src[0 * stride]) + 4) >> 3;    if (FFABS(a0) < pq) {        a1 = (2 * (src[-4 * stride] - src[-1 * stride]) - 5 * (src[-3 * stride] - src[-2 * stride]) + 4) >> 3;        a2 = (2 * (src[0 * stride] - src[3 * stride]) - 5 * (src[1 * stride] - src[2 * stride]) + 4) >> 3;        a3 = FFMIN(FFABS(a1), FFABS(a2));        if (a3 < FFABS(a0)) {            d = 5 * ((a0 >= 0 ? a3 : -a3) - a0) / 8;            clip = (src[-1 * stride] - src[0 * stride]) / 2;            if (clip) {                filt3 = 1;                if (clip > 0)                    d = av_clip(d, 0, clip);                else                    d = av_clip(d, clip, 0);                src[-1 * stride] = cm[src[-1 * stride] - d];                src[0 * stride] = cm[src[0 * stride] + d];            }        }    }    return filt3;}"}, {"type": "no factor", "target": "0", "code": "static int h264_decode_frame(AVCodecContext *avctx, void *data,                             int *got_frame, AVPacket *avpkt){    const uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    H264Context *h = avctx->priv_data;    AVFrame *pict = data;    int buf_index = 0;    int ret;    const uint8_t *new_extradata;    int new_extradata_size;    h->flags = avctx->flags;    h->setup_finished = 0;    /* end of stream, output what is still in the buffers */out:    if (buf_size == 0) {        H264Picture *out;        int i, out_idx;        h->cur_pic_ptr = NULL;        /* FIXME factorize this with the output code below */        out = h->delayed_pic[0];        out_idx = 0;        for (i = 1;             h->delayed_pic[i] &&             !h->delayed_pic[i]->f->key_frame &&             !h->delayed_pic[i]->mmco_reset;             i++)            if (h->delayed_pic[i]->poc < out->poc) {                out = h->delayed_pic[i];                out_idx = i;            }        for (i = out_idx; h->delayed_pic[i]; i++)            h->delayed_pic[i] = h->delayed_pic[i + 1];        if (out) {            ret = output_frame(h, pict, out->f);            if (ret < 0)                return ret;            *got_frame = 1;        }        return buf_index;    }    new_extradata_size = 0;    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,                                            &new_extradata_size);    if (new_extradata_size > 0 && new_extradata) {        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,                                       &h->ps, &h->is_avc, &h->nal_length_size,                                       avctx->err_recognition, avctx);        if (ret < 0)            return ret;    }    buf_index = decode_nal_units(h, buf, buf_size);    if (buf_index < 0)        return AVERROR_INVALIDDATA;    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {        buf_size = 0;        goto out;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {        if (avctx->skip_frame >= AVDISCARD_NONREF)            return 0;        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");        return AVERROR_INVALIDDATA;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||        (h->mb_y >= h->mb_height && h->mb_height)) {        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)            decode_postinit(h, 1);        ff_h264_field_end(h, &h->slice_ctx[0], 0);        *got_frame = 0;        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||                                   h->next_output_pic->recovered)) {            if (!h->next_output_pic->recovered)                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;            ret = output_frame(h, pict, h->next_output_pic->f);            if (ret < 0)                return ret;            *got_frame = 1;        }    }    assert(pict->buf[0] || !*got_frame);    return get_consumed_bytes(buf_index, buf_size);}"}, {"type": "no factor", "target": "0", "code": "static int opt_preset(const char *opt, const char *arg){    FILE *f = NULL;    char filename[1000], tmp[1000], tmp2[1000], line[1000];    int i;    const char *base[3] = { getenv(\"HOME\"),                            \"/usr/local/share\",                            \"/usr/share\" };    for (i = !base[0]; i < 3 && !f; i++) {        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg);        f = fopen(filename, \"r\");        if (!f) {            char *codec_name = *opt == 'v' ? video_codec_name :                               *opt == 'a' ? audio_codec_name :                                             subtitle_codec_name;            snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i], i ? \"\" : \".\", codec_name, arg);            f = fopen(filename, \"r\");        }    }    if (!f && ((arg[0] == '.' && arg[1] == '/') || arg[0] == '/' || is_dos_path(arg))) {        snprintf(filename, sizeof(filename), arg);        f = fopen(filename, \"r\");    }    if (!f) {        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);        av_exit(1);    }    while (!feof(f)) {        int e = fscanf(f, \"%999[^\\n]\\n\", line) - 1;        if (line[0] == '#' && !e)            continue;        e |= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;        if (e) {            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);            av_exit(1);        }        if (!strcmp(tmp, \"acodec\")) {            opt_audio_codec(tmp2);        } else if (!strcmp(tmp, \"vcodec\")) {            opt_video_codec(tmp2);        } else if (!strcmp(tmp, \"scodec\")) {            opt_subtitle_codec(tmp2);        } else if (opt_default(tmp, tmp2) < 0) {            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);            av_exit(1);        }    }    fclose(f);    return 0;}"}, {"type": "no factor", "target": "0", "code": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm){    fadt->model = 1;    fadt->reserved1 = 0;    fadt->sci_int = cpu_to_le16(pm->sci_int);    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);    fadt->acpi_enable = pm->acpi_enable_cmd;    fadt->acpi_disable = pm->acpi_disable_cmd;    /* EVT, CNT, TMR offset matches hw/acpi/core.c */    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);    /* EVT, CNT, TMR length matches hw/acpi/core.c */    fadt->pm1_evt_len = 4;    fadt->pm1_cnt_len = 2;    fadt->pm_tmr_len = 4;    fadt->gpe0_blk_len = pm->gpe0_blk_len;    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |                              (1 << ACPI_FADT_F_PROC_C1) |                              (1 << ACPI_FADT_F_SLP_BUTTON) |                              (1 << ACPI_FADT_F_RTC_S4));    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used     */    if (max_cpus > 8) {        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);    }    fadt->century = RTC_CENTURY;}"}, {"type": "no factor", "target": "0", "code": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt){    MatroskaMuxContext *mkv = s->priv_data;    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;    uint8_t *start, *end, *data = pkt->data;    ebml_master blockgroup;    char buffer[2048];    while (data_size) {        int duration = ass_get_duration(data);        max_duration = FFMAX(duration, max_duration);        end = memchr(data, '\\n', data_size);        size = line_size = end ? end - data + 1 : data_size;        size -= end ? (end[-1] == '\\r') + 1 : 0;        start = data;        for (i = 0; i < 3; i++, start++) {            if (!(start = memchr(start, ',', size - (start - data))))                return max_duration;        }        size -= start - data;        sscanf(data, \"Dialogue: %d,\", &layer);        i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",                     s->streams[pkt->stream_index]->nb_frames, layer);        size = FFMIN(i + size, sizeof(buffer));        memcpy(buffer + i, start, size - i);        av_log(s, AV_LOG_DEBUG,               \"Writing block at offset %\" PRIu64 \", size %d, \"               \"pts %\" PRId64 \", duration %d\\n\",               avio_tell(pb), size, pkt->pts, duration);        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,                                       mkv_blockgroup_size(size));        put_ebml_id(pb, MATROSKA_ID_BLOCK);        put_ebml_num(pb, size + 4, 0);        avio_w8(pb, 0x80 | (pkt->stream_index + 1));        avio_wb16(pb, pkt->pts - mkv->cluster_pts);        avio_w8(pb, 0);        avio_write(pb, buffer, size);        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);        end_ebml_master(pb, blockgroup);        data += line_size;        data_size -= line_size;    }    return max_duration;}"}, {"type": "no factor", "target": "0", "code": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config){    VirtIOBlock *s = VIRTIO_BLK(vdev);    BlockConf *conf = &s->conf.conf;    struct virtio_blk_config blkcfg;    uint64_t capacity;    int blk_size = conf->logical_block_size;    bdrv_get_geometry(s->bs, &capacity);    memset(&blkcfg, 0, sizeof(blkcfg));    virtio_stq_p(vdev, &blkcfg.capacity, capacity);    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);    blkcfg.heads = conf->heads;    /*     * We must ensure that the block device capacity is a multiple of     * the logical block size. If that is not the case, let's use     * sector_mask to adopt the geometry to have a correct picture.     * For those devices where the capacity is ok for the given geometry     * we don't touch the sector value of the geometry, since some devices     * (like s390 dasd) need a specific value. Here the capacity is already     * cyls*heads*secs*blk_size and the sector value is not block size     * divided by 512 - instead it is the amount of blk_size blocks     * per track (cylinder).     */    if (bdrv_getlength(s->bs) / conf->heads / conf->secs % blk_size) {        blkcfg.sectors = conf->secs & ~s->sector_mask;    } else {        blkcfg.sectors = conf->secs;    }    blkcfg.size_max = 0;    blkcfg.physical_block_exp = get_physical_block_exp(conf);    blkcfg.alignment_offset = 0;    blkcfg.wce = bdrv_enable_write_cache(s->bs);    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));}"}, {"type": "no factor", "target": "0", "code": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW){    int i;#if COMPILE_TEMPLATE_MMX    if (!(c->flags & SWS_BITEXACT)) {        long p = 4;        const int16_t *src[4] = { alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW };        uint8_t *dst[4] = { aDest, dest, uDest, vDest };        x86_reg counter[4] = { dstW, dstW, chrDstW, chrDstW };        if (c->flags & SWS_ACCURATE_RND) {            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121_ACCURATE                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        } else {            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        }        return;    }#endif    for (i = 0; i < dstW; i++) {        int val = (lumSrc[i] + 64) >> 7;        if (val & 256) {            if (val < 0) val = 0;            else         val = 255;        }        dest[i] = val;    }    if (uDest) {        for (i = 0; i < chrDstW; i++) {            int u = (chrSrc[i] + 64) >> 7;            int v = (chrSrc[i + VOFW] + 64) >> 7;            if ((u | v) & 256) {                if (u < 0)       u = 0;                else if (u > 255) u = 255;                if (v < 0)       v = 0;                else if (v > 255) v = 255;            }            uDest[i] = u;            vDest[i] = v;        }    }    if (CONFIG_SWSCALE_ALPHA && aDest) {        for (i = 0; i < dstW; i++) {            int val = (alpSrc[i] + 64) >> 7;            aDest[i] = av_clip_uint8(val);        }    }}"}, {"type": "no factor", "target": "0", "code": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,                             uint32_t token, uint32_t nargs, target_ulong args,                             uint32_t nret, target_ulong rets){    if ((token >= TOKEN_BASE) && ((token - TOKEN_BASE) < TOKEN_MAX)) {        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);        if (call->fn) {            call->fn(spapr, token, nargs, args, nret, rets);            return H_SUCCESS;        }    }    /* HACK: Some Linux early debug code uses RTAS display-character,     * but assumes the token value is 0xa (which it is on some real     * machines) without looking it up in the device tree. This     * special case makes this work     */    if (token == 0xa) {        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);        return H_SUCCESS;    }    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);    rtas_st(rets, 0, -3);    return H_PARAMETER;}"}, {"type": "no factor", "target": "0", "code": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,                       uint32_t r3){    uintptr_t ra = GETPC();    uint64_t destlen = get_length(env, r1 + 1);    uint64_t dest = get_address(env, r1);    uint64_t srclen = get_length(env, r3 + 1);    uint64_t src = get_address(env, r3);    uint8_t pad = a2 & 0xff;    uint32_t cc = 0;    if (!(destlen || srclen)) {        return cc;    }    if (srclen > destlen) {        srclen = destlen;    }    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;        if (v1 != v2) {            cc = (v1 < v2) ? 1 : 2;            break;        }    }    set_length(env, r1 + 1, destlen);    /* can't use srclen here, we trunc'ed it */    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);    set_address(env, r1, dest);    set_address(env, r3, src);    return cc;}"}, {"type": "no factor", "target": "0", "code": "static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0){    int i, d;    for (i = 0; i < 4; i++) {        const int tc = tc0[i];        if (tc <= 0) {            pix += 2 * ystride;            continue;        }        for (d = 0; d < 2; d++) {            const int p0 = pix[-1 * xstride];            const int p1 = pix[-2 * xstride];            const int q0 = pix[0];            const int q1 = pix[1 * xstride];            if (FFABS(p0 - q0) < alpha &&                FFABS(p1 - p0) < beta &&                FFABS(q1 - q0) < beta) {                int delta = av_clip(((q0 - p0) << 2) + (p1 - q1) + 4) >> 3, -tc, tc);                pix[-xstride] = av_clip_uint8(p0 + delta);  /* p0' */                pix[0] = av_clip_uint8(q0 - delta);         /* q0' */            }            pix += ystride;        }    }}"}, {"type": "no factor", "target": "0", "code": "static int write_f(int argc, char **argv){    struct timeval t1, t2;    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;    int c, cnt;    char *buf;    int64_t offset;    int count;    /* Some compilers get confused and warn if this is not initialized. */    int total = 0;    int pattern = 0xcd;    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {        switch (c) {        case 'b':            bflag = 1;            break;        case 'C':            Cflag = 1;            break;        case 'p':            pflag = 1;            break;        case 'P':            pattern = parse_pattern(optarg);            if (pattern < 0) {                return 0;            }            break;        case 'q':            qflag = 1;            break;        default:            return command_usage(&write_cmd);        }    }    if (optind != argc - 2) {        return command_usage(&write_cmd);    }    if (bflag && pflag) {        printf(\"-b and -p cannot be specified at the same time\\n\");        return 0;    }    offset = cvtnum(argv[optind]);    if (offset < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    optind++;    count = cvtnum(argv[optind]);    if (count < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    if (!pflag) {        if (offset & 0x1ff) {            printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset);            return 0;        }        if (count & 0x1ff) {            printf(\"count %d is not sector aligned\\n\", count);            return 0;        }    }    buf = qemu_io_alloc(count, pattern);    gettimeofday(&t1, NULL);    if (pflag) {        cnt = do_pwrite(buf, offset, count, &total);    } else if (bflag) {        cnt = do_save_vmstate(buf, offset, count, &total);    } else {        cnt = do_write(buf, offset, count, &total);    }    gettimeofday(&t2, NULL);    if (cnt < 0) {        printf(\"write failed: %s\\n\", strerror(-cnt));        goto out;    }    if (qflag) {        goto out;    }    /* Finally, report back -- -C gives a parsable format */    t2 = tsub(t2, t1);    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);out:    qemu_io_free(buf);    return 0;}"}, {"type": "no factor", "target": "0", "code": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx){    /* VIS-specific optimizations */    int accel = vis_level();    const int high_bit_depth = avctx->bits_per_raw_sample > 8;    if (accel & ACCEL_SPARC_VIS) {        if (avctx->bits_per_raw_sample <= 8 &&            avctx->idct_algo == FF_IDCT_SIMPLEVIS) {            c->idct_put = ff_simple_idct_put_vis;            c->idct_add = ff_simple_idct_add_vis;            c->idct = ff_simple_idct_vis;            c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;        }        if (!high_bit_depth) {            c->put_pixels_tab[0][0] = MC_put_o_16_vis;            c->put_pixels_tab[0][1] = MC_put_x_16_vis;            c->put_pixels_tab[0][2] = MC_put_y_16_vis;            c->put_pixels_tab[0][3] = MC_put_xy_16_vis;            c->put_pixels_tab[1][0] = MC_put_o_8_vis;            c->put_pixels_tab[1][1] = MC_put_x_8_vis;            c->put_pixels_tab[1][2] = MC_put_y_8_vis;            c->put_pixels_tab[1][3] = MC_put_xy_8_vis;            c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;            c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;            c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;            c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;            c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;            c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;            c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;            c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;            c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;            c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;            c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;            c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;            c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;            c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;            c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;            c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;            c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;            c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;            c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;            c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;        }    }}"}, {"type": "no factor", "target": "0", "code": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,                                      int64_t offset,                                      uint64_t bytes,                                      bool *error_is_read,                                      bool is_write_notifier){    BlockBackend *blk = job->common.blk;    CowRequest cow_request;    struct iovec iov;    QEMUIOVector bounce_qiov;    void *bounce_buffer = NULL;    int ret = 0;    int64_t start, end; /* bytes */    int n;              /* bytes */    qemu_co_rwlock_rdlock(&job->flush_rwlock);    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);    trace_backup_do_cow_enter(job, start, offset, bytes);    wait_for_overlapping_requests(job, start, end);    cow_request_begin(&cow_request, job, start, end);    for (; start < end; start += job->cluster_size) {        if (test_bit(start / job->cluster_size, job->done_bitmap)) {            trace_backup_do_cow_skip(job, start);            continue; /* already copied */        }        trace_backup_do_cow_process(job, start);        n = MIN(job->cluster_size, job->common.len - start);        if (!bounce_buffer) {            bounce_buffer = blk_blockalign(blk, job->cluster_size);        }        iov.iov_base = bounce_buffer;        iov.iov_len = n;        qemu_iovec_init_external(&bounce_qiov, &iov, 1);        ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,                            is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);        if (ret < 0) {            trace_backup_do_cow_read_fail(job, start, ret);            if (error_is_read) {                *error_is_read = true;            }            goto out;        }        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {            ret = blk_co_pwrite_zeroes(job->target, start,                                       bounce_qiov.size, BDRV_REQ_MAY_UNMAP);        } else {            ret = blk_co_pwritev(job->target, start,                                 bounce_qiov.size, &bounce_qiov,                                 job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);        }        if (ret < 0) {            trace_backup_do_cow_write_fail(job, start, ret);            if (error_is_read) {                *error_is_read = false;            }            goto out;        }        set_bit(start / job->cluster_size, job->done_bitmap);        /* Publish progress, guest I/O counts as progress too. Note that the         * offset field is an opaque progress value, it is not a disk offset.         */        job->bytes_read += n;        job->common.offset += n;    }out:    if (bounce_buffer) {        qemu_vfree(bounce_buffer);    }    cow_request_end(&cow_request);    trace_backup_do_cow_return(job, offset, bytes, ret);    qemu_co_rwlock_unlock(&job->flush_rwlock);    return ret;}"}, {"type": "no factor", "target": "0", "code": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s){    struct pxa_frame_descriptor_s desc;    target_phys_addr_t descptr;    int i;    for (i = 0; i < PXA_LCDDMA_CHANS; i++) {        s->dma_ch[i].source = 0;        if (!s->dma_ch[i].up)            continue;        if (s->dma_ch[i].branch & FBR_BRA) {            descptr = s->dma_ch[i].branch & FBR_SRCADDR;            if (s->dma_ch[i].branch & FBR_BINT)                pxa2xx_dma_bs_set(s, i);            s->dma_ch[i].branch &= ~FBR_BRA;        } else {            descptr = s->dma_ch[i].descriptor;        }        if (!(descptr >= PXA2XX_SDRAM_BASE &&               descptr + sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))            continue;        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);        s->dma_ch[i].source = tswap32(desc.fsaddr);        s->dma_ch[i].id = tswap32(desc.fidr);        s->dma_ch[i].command = tswap32(desc.ldcmd);    }}"}, {"type": "no factor", "target": "0", "code": "int kvm_init_vcpu(CPUState *cpu){    KVMState *s = kvm_state;    long mmap_size;    int ret;    DPRINTF(\"kvm_init_vcpu\\n\");    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));    if (ret < 0) {        DPRINTF(\"kvm_create_vcpu failed\\n\");        goto err;    }    cpu->kvm_fd = ret;    cpu->kvm_state = s;    cpu->kvm_vcpu_dirty = true;    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);    if (mmap_size < 0) {        ret = mmap_size;        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");        goto err;    }    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,                        cpu->kvm_fd, 0);    if (cpu->kvm_run == MAP_FAILED) {        ret = -errno;        DPRINTF(\"mmap'ing vcpu state failed\\n\");        goto err;    }    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {        s->coalesced_mmio_ring = (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;    }    ret = kvm_arch_init_vcpu(cpu);err:    return ret;}"}, {"type": "no factor", "target": "0", "code": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr, uint8_t ar){    CPUS390XState *env = &cpu->env;    S390PCIBusDevice *pbdev;    MemoryRegion *mr;    int i;    uint32_t fh;    uint8_t pcias;    uint8_t len;    uint8_t buffer[128];    if (env->psw.mask & PSW_MASK_PSTATE) {        program_interrupt(env, PGM_PRIVILEGED, 6);        return 0;    }    fh = env->regs[r1] >> 32;    pcias = (env->regs[r1] >> 16) & 0xf;    len = env->regs[r1] & 0xff;    if (pcias > 5) {        DPRINTF(\"pcistb invalid space\\n\");        setcc(cpu, ZPCI_PCI_LS_ERR);        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);        return 0;    }    switch (len) {    case 16:    case 32:    case 64:    case 128:        break;    default:        program_interrupt(env, PGM_SPECIFICATION, 6);        return 0;    }    pbdev = s390_pci_find_dev_by_fh(fh);    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);        return 0;    }    if (pbdev->lgstg_blocked) {        setcc(cpu, ZPCI_PCI_LS_ERR);        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);        return 0;    }    mr = pbdev->pdev->io_regions[pcias].memory;    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {        program_interrupt(env, PGM_ADDRESSING, 6);        return 0;    }    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {        return 0;    }    for (i = 0; i < len / 8; i++) {        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,                                     ldq_p(buffer + i * 8), 8,                                     MEMTXATTRS_UNSPECIFIED);    }    setcc(cpu, ZPCI_PCI_LS_OK);    return 0;}"}, {"type": "no factor", "target": "0", "code": "static int ogg_buffer_data(AVFormatContext *s, AVStream *st,                           uint8_t *data, unsigned size, int64_t granule,                           int header){    OGGStreamContext *oggstream = st->priv_data;    OGGContext *ogg = s->priv_data;    int total_segments = size / 255 + 1;    uint8_t *p = data;    int i, segments, len, flush = 0;    // Handles VFR by flushing page because this frame needs to have a timestamp    // For theora, keyframes also need to have a timestamp to correctly mark    // them as such, otherwise seeking will not work correctly at the very    // least with old libogg versions.    // Do not try to flush header packets though, that will create broken files.    if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header &&        (ogg_granule_to_timestamp(oggstream, granule) >         ogg_granule_to_timestamp(oggstream, oggstream->last_granule) + 1 ||         ogg_key_granule(oggstream, granule))) {        if (oggstream->page.granule != -1)            ogg_buffer_page(s, oggstream);        flush = 1;    }    // avoid a continued page    if (!header && oggstream->page.size > 0 &&        MAX_PAGE_SIZE - oggstream->page.size < size) {        ogg_buffer_page(s, oggstream);    }    for (i = 0; i < total_segments;) {        OGGPage *page = &oggstream->page;        segments = FFMIN(total_segments - i, 255 - page->segments_count);        if (i && !page->segments_count)            page->flags |= 1; // continued packet        memset(page->segments + page->segments_count, 255, segments - 1);        page->segments_count += segments - 1;        len = FFMIN(size, segments * 255);        page->segments[page->segments_count++] = len - (segments - 1) * 255;        memcpy(page->data + page->size, p, len);        p += len;        size -= len;        i += segments;        page->size += len;        if (i == total_segments)            page->granule = granule;        if (!header) {            AVStream *st = s->streams[page->stream_index];            int64_t start = av_rescale_q(page->start_granule, st->time_base,                                         AV_TIME_BASE_Q);            int64_t next = av_rescale_q(page->granule, st->time_base,                                        AV_TIME_BASE_Q);            if (page->segments_count == 255 ||                (ogg->pref_size > 0 && page->size >= ogg->pref_size) ||                (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) {                ogg_buffer_page(s, oggstream);            }        }    }    if (flush && oggstream->page.granule != -1)        ogg_buffer_page(s, oggstream);    return 0;}"}, {"type": "no factor", "target": "0", "code": "static void tcx_blit_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size){    TCXState *s = opaque;    uint32_t adsr, len;    int i;    if (!(addr & 4)) {        s->tmpblit = val;    } else {        addr = (addr >> 3) & 0xfffff;        adsr = val & 0xffffff;        len = ((val >> 24) & 0x1f) + 1;        if (adsr == 0xffffff) {            memset(&s->vram[addr], s->tmpblit, len);            if (s->depth == 24) {                val = s->tmpblit & 0xffffff;                val = cpu_to_be32(val);                for (i = 0; i < len; i++) {                    s->vram24[addr + i] = val;                }            }        } else {            memcpy(&s->vram[addr], &s->vram[adsr], len);            if (s->depth == 24) {                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);            }        }        memory_region_set_dirty(&s->vram_mem, addr, len);    }}"}, {"type": "no factor", "target": "0", "code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid){    if (cid != ctx->cid) {        int index;        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %d\\n\", cid);            return AVERROR(ENOSYS);        }        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",                   ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);            return AVERROR_INVALIDDATA;        }        ctx->cid_table = &ff_dnxhd_cid_table[index];        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %d.\\n\", cid);        ff_free_vlc(&ctx->ac_vlc);        ff_free_vlc(&ctx->dc_vlc);        ff_free_vlc(&ctx->run_vlc);        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,                 ctx->cid_table->ac_bits, 1, 1,                 ctx->cid_table->ac_codes, 2, 2, 0);        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,                 ctx->cid_table->dc_bits, 1, 1,                 ctx->cid_table->dc_codes, 1, 1, 0);        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,                 ctx->cid_table->run_bits, 1, 1,                 ctx->cid_table->run_codes, 2, 2, 0);        ctx->cid = cid;    }    return 0;}"}, {"type": "no factor", "target": "0", "code": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr){    DeviceState *d;    APICCommonState *s;    uint32_t val;    int index;    d = cpu_get_current_apic();    if (!d) {        return 0;    }    s = DO_UPCAST(APICCommonState, busdev.qdev, d);    index = (addr >> 4) & 0xff;    switch (index) {    case 0x02: /* id */        val = s->id << 24;        break;    case 0x03: /* version */        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */        break;    case 0x08:        apic_sync_vapic(s, SYNC_FROM_VAPIC);        if (apic_report_tpr_access) {            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);        }        val = s->tpr;        break;    case 0x09:        val = apic_get_arb_pri(s);        break;    case 0x0a: /* ppr */        val = apic_get_ppr(s);        break;    case 0x0b:        val = 0;        break;    case 0x0d:        val = s->log_dest << 24;        break;    case 0x0e:        val = s->dest_mode << 28;        break;    case 0x0f:        val = s->spurious_vec;        break;    case 0x10 ... 0x17:        val = s->isr[index & 7];        break;    case 0x18 ... 0x1f:        val = s->tmr[index & 7];        break;    case 0x20 ... 0x27:        val = s->irr[index & 7];        break;    case 0x28:        val = s->esr;        break;    case 0x30:    case 0x31:        val = s->icr[index & 1];        break;    case 0x32 ... 0x37:        val = s->lvt[index - 0x32];        break;    case 0x38:        val = s->initial_count;        break;    case 0x39:        val = apic_get_current_count(s);        break;    case 0x3e:        val = s->divide_conf;        break;    default:        s->esr |= ESR_ILLEGAL_ADDRESS;        val = 0;        break;    }    trace_apic_mem_readl(addr, val);    return val;}"}, {"type": "no factor", "target": "0", "code": "void ff_fix_long_b_mvs(MpegEncContext *s, int16_t (*mv_table)[2], int f_code, int type){    int y;    uint8_t *fcode_tab = s->fcode_tab;    // RAL: 8 in MPEG-1, 16 in MPEG-4    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);    /* clip / convert to intra 16x16 type MVs */    for (y = 0; y < s->mb_height; y++) {        int x;        int xy = (y + 1) * (s->mb_width + 2) + 1;        int i = y * s->mb_width;        for (x = 0; x < s->mb_width; x++) {            if (s->mb_type[i] & type) { // RAL: \"type\" test added...                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code ||                    fcode_tab[mv_table[xy][0] + MAX_MV] == 0) {                    if (mv_table[xy][0] > 0)                        mv_table[xy][0] = range - 1;                    else                        mv_table[xy][0] = -range;                }                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code ||                    fcode_tab[mv_table[xy][1] + MAX_MV] == 0) {                    if (mv_table[xy][1] > 0)                        mv_table[xy][1] = range - 1;                    else                        mv_table[xy][1] = -range;                }            }            xy++;            i++;        }    }}"}, {"type": "no factor", "target": "0", "code": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,                             const AVFrame *frame, int *got_packet_ptr){    G722Context *c = avctx->priv_data;    const int16_t *samples = (const int16_t *)frame->data[0];    int nb_samples, out_size, ret;    out_size = (frame->nb_samples + 1) / 2;    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))        return ret;    nb_samples = frame->nb_samples - (frame->nb_samples & 1);    if (avctx->trellis)        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);    else        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);    /* handle last frame with odd frame_size */    if (nb_samples < frame->nb_samples) {        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);    }    if (frame->pts != AV_NOPTS_VALUE)        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);    *got_packet_ptr = 1;    return 0;}"}, {"type": "no factor", "target": "0", "code": "uint64_t helper_fnmsub(uint64_t arg1, uint64_t arg2, uint64_t arg3){    CPU_DoubleU farg1, farg2, farg3;    farg1.ll = arg1;    farg2.ll = arg2;    farg3.ll = arg3;    if (unlikely(float64_is_signaling_nan(farg1.d) ||                 float64_is_signaling_nan(farg2.d) ||                 float64_is_signaling_nan(farg3.d))) {        /* sNaN operation */        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {        /* Multiplication of zero by infinity */        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);    } else {#if USE_PRECISE_EMULATION#ifdef FLOAT128        /* This is the way the PowerPC specification defines it */        float128 ft0_128, ft1_128;        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {            /* Magnitude subtraction of infinities */            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);        } else {            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);            farg1.d = float128_to_float64(ft0_128, &env->fp_status);        }#else        /* This is OK on x86 hosts */        farg1.d = (farg1.d * farg2.d) - farg3.d;#endif#else        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);#endif        if (likely(!float64_is_nan(farg1.d)))            farg1.d = float64_chs(farg1.d);    }    return farg1.ll;}"}, {"type": "no factor", "target": "0", "code": "static void start_children(FFStream *feed){    if (no_launch)        return;    for (; feed; feed = feed->next) {        if (feed->child_argv && !feed->pid) {            feed->pid_start = time(0);            feed->pid = fork();            if (feed->pid < 0) {                http_log(\"Unable to create children\\n\");                exit(1);            }            if (!feed->pid) {                /* In child */                char pathname[1024];                char *slash;                int i;                av_strlcpy(pathname, my_program_name, sizeof(pathname));                slash = strrchr(pathname, '/');                if (!slash)                    slash = pathname;                else                    slash++;                strcpy(slash, \"ffmpeg\");                http_log(\"Launch command line: \");                http_log(\"%s \", pathname);                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)                    http_log(\"%s \", feed->child_argv[i]);                http_log(\"\\n\");                for (i = 3; i < 256; i++)                    close(i);                if (!ffserver_debug) {                    i = open(\"/dev/null\", O_RDWR);                    if (i != -1) {                        dup2(i, 0);                        dup2(i, 1);                        dup2(i, 2);                        close(i);                    }                }                /* This is needed to make relative pathnames work */                chdir(my_program_dir);                signal(SIGPIPE, SIG_DFL);                execvp(pathname, feed->child_argv);                _exit(1);            }        }    }}"}, {"type": "no factor", "target": "0", "code": "static int decode_plane(UtvideoContext *c, int plane_no,                        uint8_t *dst, int step, ptrdiff_t stride,                        int width, int height,                        const uint8_t *src, int use_pred){    int i, j, slice, pix;    int sstart, send;    VLC vlc;    GetBitContext gb;    int prev, fsym;    const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P))                                    : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);    if (build_huff(src, &vlc, &fsym)) {        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");        return AVERROR_INVALIDDATA;    }    if (fsym >= 0) { // build_huff reported a symbol to fill slices with        send = 0;        for (slice = 0; slice < c->slices; slice++) {            uint8_t *dest;            sstart = send;            send   = (height * (slice + 1) / c->slices) & cmask;            dest   = dst + sstart * stride;            prev = 0x80;            for (j = sstart; j < send; j++) {                for (i = 0; i < width * step; i += step) {                    pix = fsym;                    if (use_pred) {                        prev += pix;                        pix   = prev;                    }                    dest[i] = pix;                }                dest += stride;            }        }        return 0;    }    src += 256;    send = 0;    for (slice = 0; slice < c->slices; slice++) {        uint8_t *dest;        int slice_data_start, slice_data_end, slice_size;        sstart = send;        send   = (height * (slice + 1) / c->slices) & cmask;        dest   = dst + sstart * stride;        // slice offset and size validation was done earlier        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;        slice_data_end   = AV_RL32(src + slice * 4);        slice_size       = slice_data_end - slice_data_start;        if (!slice_size) {            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"                   \"yet a slice has a length of zero.\\n\");            goto fail;        }        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);        c->bdsp.bswap_buf((uint32_t *)c->slice_bits,                          (uint32_t *)(src + slice_data_start + c->slices * 4),                          (slice_data_end - slice_data_start + 3) >> 2);        init_get_bits(&gb, c->slice_bits, slice_size * 8);        prev = 0x80;        for (j = sstart; j < send; j++) {            for (i = 0; i < width * step; i += step) {                pix = get_vlc2(&gb, vlc.table, VLC_BITS, 3);                if (pix < 0) {                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");                    goto fail;                }                if (use_pred) {                    prev += pix;                    pix   = prev;                }                dest[i] = pix;            }            if (get_bits_left(&gb) < 0) {                av_log(c->avctx, AV_LOG_ERROR, \"Slice decoding ran out of bits\\n\");                goto fail;            }            dest += stride;        }        if (get_bits_left(&gb) > 32)            av_log(c->avctx, AV_LOG_WARNING,                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));    }    ff_free_vlc(&vlc);    return 0;fail:    ff_free_vlc(&vlc);    return AVERROR_INVALIDDATA;}"}, {"type": "no factor", "target": "0", "code": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn, void *src){    int result = 0;    if (secn > 0) {        uint32_t size = (uint32_t)secn * 512;        const uint8_t *sp = (const uint8_t *)src;        uint8_t *dp = 0;        if (s->bdrv_cur) {            dp = g_malloc(size);            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {                result = 1;            }        } else {            if (sec + secn > s->secs_cur) {                result = 1;            } else {                dp = (uint8_t *)s->current + (sec << 9);            }        }        if (!result) {            uint32_t i;            for (i = 0; i < size; i++) {                dp[i] &= sp[i];            }            if (s->bdrv_cur) {                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;            }        }        if (dp && s->bdrv_cur) {            g_free(dp);        }    }    return result;}"}, {"type": "no factor", "target": "0", "code": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,                  target_ulong *raddr, int *flags){    int r = -1;    uint8_t *sk;    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;    vaddr &= TARGET_PAGE_MASK;    if (!(env->psw.mask & PSW_MASK_DAT)) {        *raddr = vaddr;        r = 0;        goto out;    }    switch (asc) {    case PSW_ASC_PRIMARY:    case PSW_ASC_HOME:        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);        break;    case PSW_ASC_SECONDARY:        /*         * Instruction: Primary         * Data: Secondary         */        if (rw == 2) {            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags, rw);            *flags &= ~(PAGE_READ | PAGE_WRITE);        } else {            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags, rw);            *flags &= ~(PAGE_EXEC);        }        break;    case PSW_ASC_ACCREG:    default:        hw_error(\"guest switched to unknown asc mode\\n\");        break;    }out:    /* Convert real address -> absolute address */    *raddr = mmu_real2abs(env, *raddr);    if (*raddr <= ram_size) {        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];        if (*flags & PAGE_READ) {            *sk |= SK_R;        }        if (*flags & PAGE_WRITE) {            *sk |= SK_C;        }    }    return r;}"}, {"type": "no factor", "target": "0", "code": "static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size){    Mpeg1Context *s1 = avctx->priv_data;    MpegEncContext *s = &s1->mpeg_enc_ctx;    int width, height, i, v, j;    float aspect;    init_get_bits(&s->gb, buf, buf_size);    width = get_bits(&s->gb, 12);    height = get_bits(&s->gb, 12);    s->aspect_ratio_info = get_bits(&s->gb, 4);    if (!s->mpeg2) {        aspect = mpeg1_aspect[s->aspect_ratio_info];        if (aspect != 0.0)            avctx->aspect_ratio = width / (aspect * height);    }    s->frame_rate_index = get_bits(&s->gb, 4);    if (s->frame_rate_index == 0)        return -1;    s->bit_rate = get_bits(&s->gb, 18) * 400;    if (get_bits1(&s->gb) == 0) /* marker */        return -1;    if (width <= 0 || height <= 0 ||        (width % 2) != 0 || (height % 2) != 0)        return -1;    if (width != s->width || height != s->height) {        /* start new mpeg1 context decoding */        s->out_format = FMT_MPEG1;        if (s1->mpeg_enc_ctx_allocated) {            MPV_common_end(s);        }        s->width = width;        s->height = height;        avctx->has_b_frames = 1;        s->avctx = avctx;        avctx->width = width;        avctx->height = height;        if (s->frame_rate_index >= 9) {            /* at least give a valid frame rate (some old mpeg1 have this) */            avctx->frame_rate = 25 * FRAME_RATE_BASE;        } else {            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];        }        s->frame_rate = avctx->frame_rate;        avctx->bit_rate = s->bit_rate;        if (MPV_common_init(s) < 0)            return -1;        s1->mpeg_enc_ctx_allocated = 1;    }    skip_bits(&s->gb, 10); /* vbv_buffer_size */    skip_bits(&s->gb, 1);    /* get matrix */    if (get_bits1(&s->gb)) {        for (i = 0; i < 64; i++) {            v = get_bits(&s->gb, 8);            j = s->intra_scantable.permutated[i];            s->intra_matrix[j] = v;            s->chroma_intra_matrix[j] = v;        }#ifdef DEBUG        dprintf(\"intra matrix present\\n\");        for (i = 0; i < 64; i++)            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);        printf(\"\\n\");#endif    } else {        for (i = 0; i < 64; i++) {            int j = s->idct_permutation[i];            v = ff_mpeg1_default_intra_matrix[i];            s->intra_matrix[j] = v;            s->chroma_intra_matrix[j] = v;        }    }    if (get_bits1(&s->gb)) {        for (i = 0; i < 64; i++) {            v = get_bits(&s->gb, 8);            j = s->intra_scantable.permutated[i];            s->inter_matrix[j] = v;            s->chroma_inter_matrix[j] = v;        }#ifdef DEBUG        dprintf(\"non intra matrix present\\n\");        for (i = 0; i < 64; i++)            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);        printf(\"\\n\");#endif    } else {        for (i = 0; i < 64; i++) {            int j = s->idct_permutation[i];            v = ff_mpeg1_default_non_intra_matrix[i];            s->inter_matrix[j] = v;            s->chroma_inter_matrix[j] = v;        }    }    /* we set mpeg2 parameters so that it emulates mpeg1 */    s->progressive_sequence = 1;    s->progressive_frame = 1;    s->picture_structure = PICT_FRAME;    s->frame_pred_frame_dct = 1;    s->mpeg2 = 0;    avctx->sub_id = 1; /* indicates mpeg1 */    return 0;}"}, {"type": "no factor", "target": "0", "code": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br){    PCIDevice *pd = PCI_DEVICE(br);    PCIBus *parent = pd->bus;    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);    pci_bridge_init_alias(br, &w->alias_pref_mem,                          PCI_BASE_ADDRESS_MEM_PREFETCH,                          \"pci_bridge_pref_mem\",                          &br->address_space_mem,                          parent->address_space_mem,                          cmd & PCI_COMMAND_MEMORY);    pci_bridge_init_alias(br, &w->alias_mem,                          PCI_BASE_ADDRESS_SPACE_MEMORY,                          \"pci_bridge_mem\",                          &br->address_space_mem,                          parent->address_space_mem,                          cmd & PCI_COMMAND_MEMORY);    pci_bridge_init_alias(br, &w->alias_io,                          PCI_BASE_ADDRESS_SPACE_IO,                          \"pci_bridge_io\",                          &br->address_space_io,                          parent->address_space_io,                          cmd & PCI_COMMAND_IO);    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);    return w;}"}, {"type": "no factor", "target": "0", "code": "static int decode_ics(AACContext *ac, SingleChannelElement *sce, GetBitContext *gb,                      int common_window, int scale_flag){    Pulse pulse;    TemporalNoiseShaping *tns = &sce->tns;    IndividualChannelStream *ics = &sce->ics;    float *out = sce->coeffs;    int global_gain, pulse_present = 0;    /* This assignment is to silence a GCC warning about the variable being used     * uninitialized when in fact it always is.     */    pulse.num_pulse = 0;    global_gain = get_bits(gb, 8);    if (!common_window && !scale_flag) {        if (decode_ics_info(ac, ics, gb, 0) < 0)            return -1;    }    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)        return -1;    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type,                            sce->band_type_run_end) < 0)        return -1;    pulse_present = 0;    if (!scale_flag) {        if ((pulse_present = get_bits1(gb))) {            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {                av_log(ac->avccontext, AV_LOG_ERROR,                       \"Pulse tool not allowed in eight short sequence.\\n\");                return -1;            }            decode_pulses(&pulse, gb, ics->swb_offset);        }        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))            return -1;        if (get_bits1(gb)) {            av_log_missing_feature(ac->avccontext, \"SSR\", 1);            return -1;        }    }    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse,                                    ics, sce->band_type) < 0)        return -1;    return 0;}"}, {"type": "no factor", "target": "0", "code": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset){    arm_sysctl_state *s = (arm_sysctl_state *)opaque;    switch (offset) {    case 0x00: /* ID */        return s->sys_id;    case 0x04: /* SW */        /* General purpose hardware switches.           We don't have a useful way of exposing these to the user. */        return 0;    case 0x08: /* LED */        return s->leds;    case 0x20: /* LOCK */        return s->lockval;    case 0x0c: /* OSC0 */    case 0x10: /* OSC1 */    case 0x14: /* OSC2 */    case 0x18: /* OSC3 */    case 0x1c: /* OSC4 */    case 0x24: /* 100HZ */        /* ??? Implement these. */        return 0;    case 0x28: /* CFGDATA1 */        return s->cfgdata1;    case 0x2c: /* CFGDATA2 */        return s->cfgdata2;    case 0x30: /* FLAGS */        return s->flags;    case 0x38: /* NVFLAGS */        return s->nvflags;    case 0x40: /* RESETCTL */        return s->resetlevel;    case 0x44: /* PCICTL */        return 1;    case 0x48: /* MCI */        return 0;    case 0x4c: /* FLASH */        return 0;    case 0x50: /* CLCD */        return 0x1000;    case 0x54: /* CLCDSER */        return 0;    case 0x58: /* BOOTCS */        return 0;    case 0x5c: /* 24MHz */        return muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec());    case 0x60: /* MISC */        return 0;    case 0x84: /* PROCID0 */        /* ??? Don't know what the proper value for the core tile ID is. */        Goreturn 0x02000000;    case 0x88: /* PROCID1 */        return 0xff000000;    case 0x64: /* DMAPSR0 */    case 0x68: /* DMAPSR1 */    case 0x6c: /* DMAPSR2 */    case 0x70: /* IOSEL */    case 0x74: /* PLDCTL */    case 0x80: /* BUSID */    case 0x8c: /* OSCRESET0 */    case 0x90: /* OSCRESET1 */    case 0x94: /* OSCRESET2 */    case 0x98: /* OSCRESET3 */    case 0x9c: /* OSCRESET4 */    case 0xc0: /* SYS_TEST_OSC0 */    case 0xc4: /* SYS_TEST_OSC1 */    case 0xc8: /* SYS_TEST_OSC2 */    case 0xcc: /* SYS_TEST_OSC3 */    case 0xd0: /* SYS_TEST_OSC4 */        return 0;    default:        printf(\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset);        return 0;    }}"}, {"type": "no factor", "target": "0", "code": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts, int *duration) {    int64_t out_pts = AV_NOPTS_VALUE;    int removed_samples = 0;#ifdef DEBUG    ff_af_queue_log_state(afq);#endif    /* get output pts from the next frame or generated pts */    if (afq->frame_queue) {        if (afq->frame_queue->pts != AV_NOPTS_VALUE)            out_pts = afq->frame_queue->pts - afq->remaining_delay;    } else {        if (afq->next_pts != AV_NOPTS_VALUE)            out_pts = afq->next_pts - afq->remaining_delay;    }    if (pts) {        if (out_pts != AV_NOPTS_VALUE)            *pts = ff_samples_to_time_base(afq->avctx, out_pts);        else            *pts = AV_NOPTS_VALUE;    }    /* if the delay is larger than the packet duration, we use up delay samples       for the output packet and leave all frames in the queue */    if (afq->remaining_delay >= nb_samples) {        removed_samples += nb_samples;        afq->remaining_delay -= nb_samples;    }    /* remove frames from the queue until we have enough to cover the       requested number of samples or until the queue is empty */    while (removed_samples < nb_samples && afq->frame_queue) {        removed_samples += afq->frame_queue->duration;        delete_next_frame(afq);    }    afq->remaining_samples -= removed_samples;    /* if there are no frames left and we have room for more samples, use       any remaining delay samples */    if (removed_samples < nb_samples && afq->remaining_samples > 0) {        int add_samples = FFMIN(afq->remaining_samples, nb_samples - removed_samples);        removed_samples += add_samples;        afq->remaining_samples -= add_samples;    }    if (removed_samples > nb_samples)        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");    if (duration)        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);}"}, {"type": "no factor", "target": "0", "code": "void ide_atapi_cmd(IDEState *s) {    uint8_t *buf;    buf = s->io_buffer;#ifdef DEBUG_IDE_ATAPI    {        int i;        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));        for (i = 0; i < ATAPI_PACKET_SIZE; i++) {            printf(\" %02x\", buf[i]);        }        printf(\"\\n\");    }#endif    /*     * If there's a UNIT_ATTENTION condition pending, only command flagged with     * ALLOW_UA are allowed to complete. with other commands getting a CHECK     * condition response unless a higher priority status, defined by the drive     * here, is pending.     */    if (s->sense_key == UNIT_ATTENTION &&        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {        ide_atapi_cmd_check_status(s);        return;    }    /*     * When a CD gets changed, we have to report an ejected state and     * then a loaded state to guests so that they detect tray     * open/close and media change events. Guests that do not use     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close     * states rely on this behavior.     */    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {        if (s->cdrom_changed == 1) {            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);            s->cdrom_changed = 2;        } else {            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);            s->cdrom_changed = 0;        }        return;    }    /* Report a Not Ready condition if appropriate for the command */    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&        (!media_present(s) || !bdrv_is_inserted(s->bs))) {        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);        return;    }    /* Execute the command */    if (atapi_cmd_table[s->io_buffer[0]].handler) {        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);        return;    }    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);}"}, {"type": "no factor", "target": "0", "code": "static int parse_presentation_segment(AVCodecContext *avctx,                                      const uint8_t *buf,                                      int buf_size,                                      int64_t pts) {    PGSSubContext *ctx = avctx->priv_data;    int x, y, ret;    int w = bytestream_get_be16(&buf);    int h = bytestream_get_be16(&buf);    ctx->presentation.pts = pts;    av_dlog(avctx, \"Video Dimensions %dx%d\\n\", w, h);    ret = ff_set_dimensions(avctx, w, h);    if (ret < 0)        return ret;    /* Skip 1 byte of unknown, frame rate? */    buf++;    ctx->presentation.id_number = bytestream_get_be16(&buf);    /*     * Skip 3 bytes of unknown:     *     state     *     palette_update_flag (0x80),     *     palette_id_to_use,     */    buf += 3;    ctx->presentation.object_number = bytestream_get_byte(&buf);    ctx->presentation.composition_flag = 0;    if (!ctx->presentation.object_number)        return 0;    /*     * Skip 3 bytes of unknown:     *     object_id_ref (2 bytes),     *     window_id_ref,     */    buf += 3;    ctx->presentation.composition_flag = bytestream_get_byte(&buf);    x = bytestream_get_be16(&buf);    y = bytestream_get_be16(&buf);    /* TODO: If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes). */    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);    if (x > avctx->width || y > avctx->height) {        av_log(avctx, AV_LOG_ERROR,               \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\",               x, y, avctx->width, avctx->height);        x = 0;        y = 0;    }    /* Fill in dimensions */    ctx->presentation.x = x;    ctx->presentation.y = y;    return 0;}"}, {"type": "no factor", "target": "0", "code": "static void sdhci_write_block_to_card(SDHCIState *s) {    int index = 0;    if (s->prnsts & SDHC_SPACE_AVAILABLE) {        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {            s->norintsts |= SDHC_NIS_WBUFRDY;        }        sdhci_update_irq(s);        return;    }    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {        if (s->blkcnt == 0) {            return;        } else {            s->blkcnt--;        }    }    for (index = 0; index < (s->blksize & 0x0fff); index++) {        sd_write_data(s->card, s->fifo_buffer[index]);    }    /* Next data can be written through BUFFER DATORT register */    s->prnsts |= SDHC_SPACE_AVAILABLE;    /* Finish transfer if that was the last block of data */    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||        ((s->trnmod & SDHC_TRNS_MULTI) &&         (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {        SDHCI_GET_CLASS(s)->end_data_transfer(s);    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {        s->norintsts |= SDHC_NIS_WBUFRDY;    }    /* Generate Block Gap Event if requested and if not the last block */    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&        s->blkcnt > 0) {        s->prnsts &= ~SDHC_DOING_WRITE;        if (s->norintstsen & SDHC_EISEN_BLKGAP) {            s->norintsts |= SDHC_EIS_BLKGAP;        }        SDHCI_GET_CLASS(s)->end_data_transfer(s);    }    sdhci_update_irq(s);}"}, {"type": "no factor", "target": "0", "code": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,                                      unsigned int size, int mem_index) {    int l1 = gen_new_label();    TCGv taddr = tcg_temp_local_new();    TCGv tval = tcg_temp_local_new();    TCGv t1 = tcg_temp_local_new();    dc->postinc = 0;    cris_evaluate_flags(dc);    tcg_gen_mov_tl(taddr, addr);    tcg_gen_mov_tl(tval, val);    /* Store only if F flag isn't set */    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);    if (size == 1) {        tcg_gen_qemu_st8(tval, taddr, mem_index);    } else if (size == 2) {        tcg_gen_qemu_st16(tval, taddr, mem_index);    } else {        tcg_gen_qemu_st32(tval, taddr, mem_index);    }    gen_set_label(l1);    tcg_gen_shri_tl(t1, t1, 1); /* shift F to P position */    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /* P=F */    tcg_temp_free(t1);    tcg_temp_free(tval);    tcg_temp_free(taddr);}"}, {"type": "no factor", "target": "0", "code": "int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,                                   GetBitContext *gb) {    int i;    MMCO *mmco = sl->mmco;    int nb_mmco = 0;    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields        skip_bits1(gb); // broken_link        if (get_bits1(gb)) {            mmco[0].opcode = MMCO_LONG;            mmco[0].long_arg = 0;            nb_mmco = 1;        }        sl->explicit_ref_marking = 1;    } else {        sl->explicit_ref_marking = get_bits1(gb);        if (sl->explicit_ref_marking) {            for (i = 0; i < MAX_MMCO_COUNT; i++) {                MMCOOpcode opcode = get_ue_golomb_31(gb);                mmco[i].opcode = opcode;                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {                    mmco[i].short_pic_num =                        (sl->curr_pic_num - get_ue_golomb(gb) - 1) &                        (sl->max_pic_num - 1);#if 0                    if (mmco[i].short_pic_num >= h->short_ref_count ||                        !h->short_ref[mmco[i].short_pic_num]) {                        av_log(s->avctx, AV_LOG_ERROR,                               \"illegal short ref in memory management control \"                               \"operation %d\\n\", mmco);                        return -1;                    }#endif                }                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {                    unsigned int long_arg = get_ue_golomb_31(gb);                    if (long_arg >= 32 ||                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&                                             long_arg == 16) &&                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {                        av_log(h->avctx, AV_LOG_ERROR,                               \"illegal long ref in memory management control \"                               \"operation %d\\n\", opcode);                        return -1;                    }                    mmco[i].long_arg = long_arg;                }                if (opcode > (unsigned) MMCO_LONG) {                    av_log(h->avctx, AV_LOG_ERROR,                           \"illegal memory management control operation %d\\n\",                           opcode);                    return -1;                }                if (opcode == MMCO_END)                    break;            }            nb_mmco = i;        }    }    sl->nb_mmco = nb_mmco;    return 0;}"}, {"type": "no factor", "target": "0", "code": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len) {    const USBDesc *desc = dev->info->usb_desc;    uint8_t buf[256];    uint8_t type = value >> 8;    uint8_t index = value & 0xff;    int ret = -1;    switch (type) {    case USB_DT_DEVICE:        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));        trace_usb_desc_device(dev->addr, len, ret);        break;    case USB_DT_CONFIG:        if (index < desc->full->bNumConfigurations) {            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));        }        trace_usb_desc_config(dev->addr, index, len, ret);        break;    case USB_DT_STRING:        ret = usb_desc_string(dev, index, buf, sizeof(buf));        trace_usb_desc_string(dev->addr, index, len, ret);        break;    default:        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,                dev->addr, type, len);        break;    }    if (ret > 0) {        if (ret > len) {            ret = len;        }        memcpy(dest, buf, ret);    }    return ret;}"}, {"type": "no factor", "target": "0", "code": "static void reverse_matrixing(float *su1, float *su2, int *prev_code, int *curr_code) {    int i, nsample, band;    float mc1_l, mc1_r, mc2_l, mc2_r;    for (i = 0, band = 0; band < 4 * 256; band += 256, i++) {        int s1 = prev_code[i];        int s2 = curr_code[i];        nsample = 0;        if (s1 != s2) {            /* Selector value changed, interpolation needed. */            mc1_l = matrix_coeffs[s1 * 2];            mc1_r = matrix_coeffs[s1 * 2 + 1];            mc2_l = matrix_coeffs[s2 * 2];            mc2_r = matrix_coeffs[s2 * 2 + 1];            /* Interpolation is done over the first eight samples. */            for (; nsample < 8; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +                     c2 * INTERPOLATE(mc1_r, mc2_r, nsample);                su1[band + nsample] = c2;                su2[band + nsample] = c1 * 2.0 - c2;            }        }        /* Apply the matrix without interpolation. */        switch (s2) {        case 0: /* M/S decoding */            for (; nsample < 256; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                su1[band + nsample] = c2 * 2.0;                su2[band + nsample] = (c1 - c2) * 2.0;            }            break;        case 1:            for (; nsample < 256; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                su1[band + nsample] = (c1 + c2) * 2.0;                su2[band + nsample] = c2 * -2.0;            }            break;        case 2:        case 3:            for (; nsample < 256; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                su1[band + nsample] = c1 + c2;                su2[band + nsample] = c1 - c2;            }            break;        default:            assert(0);        }    }}"}, {"type": "no factor", "target": "0", "code": "static void *do_data_decompress(void *opaque) {    DecompressParam *param = opaque;    unsigned long pagesize;    while (!quit_decomp_thread) {        qemu_mutex_lock(param->mutex);        while (!param->start && !quit_decomp_thread) {            qemu_cond_wait(param->cond, param->mutex);        }        if (!quit_decomp_thread) {            pagesize = TARGET_PAGE_SIZE;            /* uncompress() will return failed in some case, especially             * when the page is dirted when doing the compression, it's             * not a problem because the dirty page will be retransferred             * and uncompress() won't break the data in other pages.             */            uncompress((Bytef *)param->des, &pagesize,                       (const Bytef *)param->compbuf, param->len);        }        param->start = false;        qemu_mutex_unlock(param->mutex);        qemu_mutex_lock(&decomp_done_lock);        param->done = true;        qemu_cond_signal(&decomp_done_cond);        qemu_mutex_unlock(&decomp_done_lock);    }    return NULL;}"}, {"type": "no factor", "target": "0", "code": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s, struct vmsvga_cursor_definition_s *c) {    QEMUCursor *qc;    int i, pixels;    qc = cursor_alloc(c->width, c->height);    qc->hot_x = c->hot_x;    qc->hot_y = c->hot_y;    switch (c->bpp) {    case 1:        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image, 1, (void*)c->mask);#ifdef DEBUG        cursor_print_ascii_art(qc, \"vmware/mono\");#endif        break;    case 32:        /* fill alpha channel from mask, set color to zero */        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask, 1, (void*)c->mask);        /* add in rgb values */        pixels = c->width * c->height;        for (i = 0; i < pixels; i++) {            qc->data[i] |= c->image[i] & 0xffffff;        }#ifdef DEBUG        cursor_print_ascii_art(qc, \"vmware/32bit\");#endif        break;    default:        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\", __FUNCTION__, c->bpp);        cursor_put(qc);        qc = cursor_builtin_left_ptr();    }    dpy_cursor_define(s->vga.ds, qc);    cursor_put(qc);}"}, {"type": "no factor", "target": "0", "code": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset, unsigned int nb_clusters) {    BDRVQcowState *s = bs->opaque;    uint64_t *l2_table;    int l2_index;    int ret;    int i;    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);    if (ret < 0) {        return ret;    }    /* Limit nb_clusters to one L2 table */    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);    for (i = 0; i < nb_clusters; i++) {        uint64_t old_offset;        old_offset = be64_to_cpu(l2_table[l2_index + i]);        /* Update L2 entries */        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);        if (old_offset & QCOW_OFLAG_COMPRESSED) {            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);        } else {            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);        }    }    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);    if (ret < 0) {        return ret;    }    return nb_clusters;}"}, {"type": "no factor", "target": "0", "code": "static int scsi_initfn(SCSIDevice *dev) {    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);    Error *err = NULL;    if (!s->qdev.conf.bs) {        error_report(\"drive property not set\");        return -1;    }    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !bdrv_is_inserted(s->qdev.conf.bs)) {        error_report(\"Device needs media, but drive is empty\");        return -1;    }    blkconf_serial(&s->qdev.conf, &s->serial);    if (dev->type == TYPE_DISK) {        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);        if (err) {            error_report(\"%s\", error_get_pretty(err));            error_free(err);            return -1;        }    }    if (s->qdev.conf.discard_granularity == -1) {        s->qdev.conf.discard_granularity = MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);    }    if (!s->version) {        s->version = g_strdup(qemu_get_version());    }    if (!s->vendor) {        s->vendor = g_strdup(\"QEMU\");    }    if (bdrv_is_sg(s->qdev.conf.bs)) {        error_report(\"unwanted /dev/sg*\");        return -1;    }    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);    } else {        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);    }    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);    bdrv_iostatus_enable(s->qdev.conf.bs);    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);    return 0;}"}, {"type": "no factor", "target": "0", "code": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap) {    QObject *token;    const char *val;    if (ap == NULL) {        return NULL;    }    token = parser_context_pop_token(ctxt);    assert(token && token_get_type(token) == JSON_ESCAPE);    val = token_get_value(token);    if (!strcmp(val, \"%p\")) {        return va_arg(*ap, QObject *);    } else if (!strcmp(val, \"%i\")) {        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));    } else if (!strcmp(val, \"%d\")) {        return QOBJECT(qint_from_int(va_arg(*ap, int)));    } else if (!strcmp(val, \"%ld\")) {        return QOBJECT(qint_from_int(va_arg(*ap, long)));    } else if (!strcmp(val, \"%lld\") || !strcmp(val, \"%I64d\")) {        return QOBJECT(qint_from_int(va_arg(*ap, long long)));    } else if (!strcmp(val, \"%s\")) {        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));    } else if (!strcmp(val, \"%f\")) {        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));    }    return NULL;}"}, {"type": "no factor", "target": "0", "code": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev) {#ifdef CONFIG_KVM    struct kvm_irqfd irqfd = {        .fd = event_notifier_get_fd(&vdev->intx.interrupt),        .gsi = vdev->intx.route.irq,        .flags = KVM_IRQFD_FLAG_RESAMPLE,    };    struct vfio_irq_set *irq_set;    int ret, argsz;    int32_t *pfd;    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||        vdev->intx.route.mode != PCI_INTX_ENABLED || !kvm_resamplefds_enabled()) {        return;    }    /* Get to a known interrupt state */    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);    vdev->intx.pending = false;    pci_irq_deassert(&vdev->pdev);    /* Get an eventfd for resample/unmask */    if (event_notifier_init(&vdev->intx.unmask, 0)) {        error_report(\"vfio: Error: event_notifier_init failed eoi\");        goto fail;    }    /* KVM triggers it, VFIO listens for it */    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {        error_report(\"vfio: Error: Failed to setup resample irqfd: %m\");        goto fail_irqfd;    }    argsz = sizeof(*irq_set) + sizeof(*pfd);    irq_set = g_malloc0(argsz);    irq_set->argsz = argsz;    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;    irq_set->start = 0;    irq_set->count = 1;    pfd = (int32_t *)&irq_set->data;    *pfd = irqfd.resamplefd;    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);    g_free(irq_set);    if (ret) {        error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");        goto fail_vfio;    }    /* Let'em rip */    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);    vdev->intx.kvm_accel = true;    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);    return;fail_vfio:    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);fail_irqfd:    event_notifier_cleanup(&vdev->intx.unmask);fail:    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);#endif}"}, {"type": "no factor", "target": "0", "code": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {    uint32_t v, spf;    MPADecodeHeader c;    int vbrtag_size = 0;    MP3DecContext *mp3 = s->priv_data;    ffio_init_checksum(s->pb, ff_crcA001_update, 0);    v = avio_rb32(s->pb);    if (ff_mpa_check_header(v) < 0)        return -1;    if (avpriv_mpegaudio_decode_header(&c, v) == 0)        vbrtag_size = c.frame_size;    if (c.layer != 3)        return -1;    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */    mp3->frames = 0;    mp3->size = 0;    mp3_parse_info_tag(s, st, &c, spf);    mp3_parse_vbri_tag(s, st, base);    if (!mp3->frames && !mp3->size)        return -1;    /* Skip the vbr tag frame */    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);    if (mp3->frames)        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate}, st->time_base);    if (mp3->size && mp3->frames && !mp3->is_cbr)        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);    return 0;}"}, {"type": "no factor", "target": "0", "code": "static void setup_frame(int sig, struct emulated_sigaction *ka, target_sigset_t *set, CPUX86State *env) {    struct sigframe *frame;    int err = 0;    frame = get_sigframe(ka, env, sizeof(*frame));#if 0    if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))        goto give_sigsegv;#endif    err |= __put_user((/*current->exec_domain                       && current->exec_domain->signal_invmap                       && sig < 32                       ? current->exec_domain->signal_invmap[sig]                       : */ sig),                      &frame->sig);    if (err)        goto give_sigsegv;    setup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);    if (err)        goto give_sigsegv;    if (TARGET_NSIG_WORDS > 1) {        err |= __copy_to_user(frame->extramask, &set->sig[1], sizeof(frame->extramask));    }    if (err)        goto give_sigsegv;    /* Set up to return from userspace.  If provided, use a stub already in userspace. */    if (ka->sa.sa_flags & TARGET_SA_RESTORER) {        err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);    } else {        err |= __put_user(frame->retcode, &frame->pretcode);        /* This is popl %eax ; movl $,%eax ; int $0x80 */        err |= __put_user(0xb858, (short *)(frame->retcode + 0));        err |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode + 2));        err |= __put_user(0x80cd, (short *)(frame->retcode + 6));    }    if (err)        goto give_sigsegv;    /* Set up registers for signal handler */    env->regs[R_ESP] = (unsigned long) frame;    env->eip = (unsigned long) ka->sa._sa_handler;    cpu_x86_load_seg(env, R_DS, __USER_DS);    cpu_x86_load_seg(env, R_ES, __USER_DS);    cpu_x86_load_seg(env, R_SS, __USER_DS);    cpu_x86_load_seg(env, R_CS, __USER_CS);    env->eflags &= ~TF_MASK;    return;give_sigsegv:    if (sig == TARGET_SIGSEGV)        ka->sa._sa_handler = TARGET_SIG_DFL;    force_sig(TARGET_SIGSEGV /* , current */);}"}, {"type": "no factor", "target": "0", "code": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl) {    VGACommonState *vga = &qxl->vga;    int i;    if (qxl->guest_primary.resized) {        qxl->guest_primary.resized = 0;        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);        qxl->num_dirty_rects = 1;        trace_qxl_render_guest_primary_resized(            qxl->guest_primary.surface.width,            qxl->guest_primary.surface.height,            qxl->guest_primary.qxl_stride,            qxl->guest_primary.bytes_pp,            qxl->guest_primary.bits_pp        );        if (qxl->guest_primary.qxl_stride > 0) {            qemu_free_displaysurface(vga->ds);            qemu_create_displaysurface_from(                qxl->guest_primary.surface.width,                qxl->guest_primary.surface.height,                qxl->guest_primary.bits_pp,                qxl->guest_primary.abs_stride,                qxl->guest_primary.data            );        } else {            qemu_resize_displaysurface(                vga->ds,                qxl->guest_primary.surface.width,                qxl->guest_primary.surface.height            );        }        dpy_gfx_resize(vga->ds);    }    for (i = 0; i < qxl->num_dirty_rects; i++) {        if (qemu_spice_rect_is_empty(qxl->dirty + i)) {            break;        }        qxl_blit(qxl, qxl->dirty + i);        dpy_gfx_update(            vga->ds,            qxl->dirty[i].left,            qxl->dirty[i].top,            qxl->dirty[i].right - qxl->dirty[i].left,            qxl->dirty[i].bottom - qxl->dirty[i].top        );    }    qxl->num_dirty_rects = 0;}"}, {"type": "no factor", "target": "0", "code": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom) {    AVStream *st;    MOVStreamContext *sc;    unsigned int i, entries;    if (c->fc->nb_streams < 1)        return 0;    st = c->fc->streams[c->fc->nb_streams - 1];    sc = st->priv_data;    avio_r8(pb); /* version */    avio_rb24(pb); /* flags */    entries = avio_rb32(pb);    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams - 1, entries);    if (!entries)        return 0;    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))        return AVERROR_INVALIDDATA;    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));    if (!sc->stsc_data)        return AVERROR(ENOMEM);    for (i = 0; i < entries && !pb->eof_reached; i++) {        sc->stsc_data[i].first = avio_rb32(pb);        sc->stsc_data[i].count = avio_rb32(pb);        sc->stsc_data[i].id = avio_rb32(pb);        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {            sc->stsc_data[i].id = 0;            if (c->fc->error_recognition & AV_EF_EXPLODE) {                av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\");                return AVERROR_INVALIDDATA;            }        }    }    sc->stsc_count = i;    if (pb->eof_reached)        return AVERROR_EOF;    return 0;}"}, {"type": "no factor", "target": "0", "code": "static int create_stream(AVFormatContext *s) {    XCBGrabContext *c = s->priv_data;    AVStream *st = avformat_new_stream(s, NULL);    xcb_get_geometry_cookie_t gc;    xcb_get_geometry_reply_t *geo;    int ret;    if (!st)        return AVERROR(ENOMEM);    ret = av_parse_video_size(&c->width, &c->height, c->video_size);    if (ret < 0)        return ret;    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);    if (ret < 0)        return ret;    avpriv_set_pts_info(st, 64, 1, 1000000);    gc = xcb_get_geometry(c->conn, c->screen->root);    geo = xcb_get_geometry_reply(c->conn, gc, NULL);    c->width = FFMIN(geo->width, c->width);    c->height = FFMIN(geo->height, c->height);    c->time_base = (AVRational){st->avg_frame_rate.den, st->avg_frame_rate.num};    c->time_frame = av_gettime();    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;    st->codec->width = c->width;    st->codec->height = c->height;    st->codec->time_base = c->time_base;    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);    free(geo);    return ret;}"}, {"type": "no factor", "target": "0", "code": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,                                    sPAPRDRConnectorType drc_type, uint32_t drc){    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());    struct hp_log_full *new_hp;    struct rtas_error_log *hdr;    struct rtas_event_log_v6 *v6hdr;    struct rtas_event_log_v6_maina *maina;    struct rtas_event_log_v6_mainb *mainb;    struct rtas_event_log_v6_hp *hp;    new_hp = g_malloc0(sizeof(struct hp_log_full));    hdr = &new_hp->hdr;    v6hdr = &new_hp->v6hdr;    maina = &new_hp->maina;    mainb = &new_hp->mainb;    hp = &new_hp->hp;    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6 |                               RTAS_LOG_SEVERITY_EVENT |                               RTAS_LOG_DISPOSITION_NOT_RECOVERED |                               RTAS_LOG_OPTIONAL_PART_PRESENT |                               RTAS_LOG_INITIATOR_HOTPLUG |                               RTAS_LOG_TYPE_HOTPLUG);    hdr->extended_length = cpu_to_be32(sizeof(*new_hp) - sizeof(new_hp->hdr));    spapr_init_v6hdr(v6hdr);    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));    mainb->subsystem_id = 0x80; /* External environment */    mainb->event_severity = 0x00; /* Informational / non-error */    mainb->event_subtype = 0x00; /* Normal shutdown */    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));    hp->hdr.section_version = 1; /* includes extended modifier */    hp->hotplug_action = hp_action;    hp->hotplug_identifier = hp_id;    switch (drc_type) {    case SPAPR_DR_CONNECTOR_TYPE_PCI:        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;        if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {            spapr_hotplug_set_signalled(drc);        }        break;    case SPAPR_DR_CONNECTOR_TYPE_LMB:        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY;        break;    case SPAPR_DR_CONNECTOR_TYPE_CPU:        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU;        break;    default:        /* we shouldn't be signaling hotplug events for resources         * that don't support them         */        g_assert(false);        return;    }    if (hp_id == RTAS_LOG_V6_HP_ID_DRC_COUNT) {        hp->drc.count = cpu_to_be32(drc);    } else if (hp_id == RTAS_LOG_V6_HP_ID_DRC_INDEX) {        hp->drc.index = cpu_to_be32(drc);    }    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));}"}, {"type": "no factor", "target": "0", "code": "static inline bool regime_translation_disabled(CPUARMState *env, ARMMMUIdx mmu_idx){    if (arm_feature(env, ARM_FEATURE_M)) {        switch (env->v7m.mpu_ctrl &                 (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {        case R_V7M_MPU_CTRL_ENABLE_MASK:            /* Enabled, but not for HardFault and NMI */            return mmu_idx == ARMMMUIdx_MNegPri || mmu_idx == ARMMMUIdx_MSNegPri;        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:            /* Enabled for all cases */            return false;        case 0:        default:            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but             * we warned about that in armv7m_nvic.c when the guest set it.             */            return true;        }    }    if (mmu_idx == ARMMMUIdx_S2NS) {        return (env->cp15.hcr_el2 & HCR_VM) == 0;    }    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;}"}, {"type": "no factor", "target": "0", "code": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,                                 int *got_frame_ptr, AVPacket *avpkt){    EightSvxContext *esc = avctx->priv_data;    int n, out_data_size;    int ch, ret;    uint8_t *src;    /* decode and interleave the first packet */    if (!esc->samples && avpkt) {        int packet_size = avpkt->size;        if (packet_size % avctx->channels) {            av_log(avctx, AV_LOG_WARNING, \"Packet with odd size, ignoring last byte\\n\");            if (packet_size < avctx->channels)                return packet_size;            packet_size -= packet_size % avctx->channels;        }        esc->samples_size = !esc->table ?                            packet_size : avctx->channels + (packet_size - avctx->channels) * 2;        if (!(esc->samples = av_malloc(esc->samples_size)))            return AVERROR(ENOMEM);        /* decompress */        if (esc->table) {            const uint8_t *buf = avpkt->data;            uint8_t *dst;            int buf_size = avpkt->size;            int i, n = esc->samples_size;            if (buf_size < 2) {                av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\");                return AVERROR(EINVAL);            }            /* the uncompressed starting value is contained in the first byte */            dst = esc->samples;            for (i = 0; i < avctx->channels; i++) {                *(dst++) = buf[0] + 128;                delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0] + 128) & 0xFF, esc->table);                buf += buf_size / avctx->channels;                dst += n / avctx->channels - 1;            }        } else {            raw_decode(esc->samples, avpkt->data, esc->samples_size);        }    }    /* get output buffer */    av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));    esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx) / avctx->channels;    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");        return ret;    }    *got_frame_ptr = 1;    *(AVFrame *)data = esc->frame;    out_data_size = esc->frame.nb_samples;    for (ch = 0; ch < avctx->channels; ch++) {        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;        memcpy(esc->frame.data[ch], src, out_data_size);    }    out_data_size *= avctx->channels;    esc->samples_idx += out_data_size;    return esc->table ?           (avctx->frame_number == 0) * 2 + out_data_size / 2 :           out_data_size;}"}, {"type": "no factor", "target": "0", "code": "static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref){    AResampleContext *aresample = inlink->dst->priv;    const int n_in = insamplesref->audio->nb_samples;    int n_out = FFMAX(n_in * aresample->ratio * 2, 1);    AVFilterLink *const outlink = inlink->dst->outputs[0];    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);    int ret;    if (!outsamplesref)        return AVERROR(ENOMEM);    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);    outsamplesref->format = outlink->format;    outsamplesref->audio->channel_layout = outlink->channel_layout;    outsamplesref->audio->sample_rate = outlink->sample_rate;    if (insamplesref->pts != AV_NOPTS_VALUE) {        int64_t inpts = av_rescale(insamplesref->pts,                                   inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate,                                   inlink->time_base.den);        int64_t outpts = swr_next_pts(aresample->swr, inpts);        aresample->next_pts = outsamplesref->pts = (outpts + inlink->sample_rate / 2) / inlink->sample_rate;    } else {        outsamplesref->pts = AV_NOPTS_VALUE;    }    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,                        (void *)insamplesref->extended_data, n_in);    if (n_out <= 0) {        avfilter_unref_buffer(outsamplesref);        avfilter_unref_buffer(insamplesref);        return 0;    }    outsamplesref->audio->nb_samples = n_out;    ret = ff_filter_samples(outlink, outsamplesref);    aresample->req_fullfilled = 1;    avfilter_unref_buffer(insamplesref);    return ret;}"}, {"type": "no factor", "target": "0", "code": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd){    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);    int ret;    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));        scsi_req_complete(&r->req, CHECK_CONDITION);        return 0;    }    if (-1 == scsi_req_parse(&r->req, cmd)) {        BADF(\"Unsupported command length, command %x\\n\", cmd[0]);        scsi_command_complete(r, -EINVAL);        return 0;    }    scsi_req_fixup(&r->req);    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag,            r->req.cmd.xfer, cmd[0]);#ifdef DEBUG_SCSI    {        int i;        for (i = 1; i < r->req.cmd.len; i++) {            printf(\" 0x%02x\", cmd[i]);        }        printf(\"\\n\");    }#endif    if (r->req.cmd.xfer == 0) {        if (r->buf != NULL)            qemu_free(r->buf);        r->buflen = 0;        r->buf = NULL;        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);        if (ret < 0) {            scsi_command_complete(r, ret);            return 0;        }        return 0;    }    if (r->buflen != r->req.cmd.xfer) {        if (r->buf != NULL)            qemu_free(r->buf);        r->buf = qemu_malloc(r->req.cmd.xfer);        r->buflen = r->req.cmd.xfer;    }    memset(r->buf, 0, r->buflen);    r->len = r->req.cmd.xfer;    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {        r->len = 0;        return -r->req.cmd.xfer;    } else {        return r->req.cmd.xfer;    }}"}, {"type": "no factor", "target": "0", "code": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn){    unsigned int mos, type, rm, cond, rn, op, nzcv;    TCGv_i64 tcg_flags;    int label_continue = -1;    mos = extract32(insn, 29, 3);    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */    rm = extract32(insn, 16, 5);    cond = extract32(insn, 12, 4);    rn = extract32(insn, 5, 5);    op = extract32(insn, 4, 1);    nzcv = extract32(insn, 0, 4);    if (mos || type > 1) {        unallocated_encoding(s);        return;    }    if (!fp_access_check(s)) {        return;    }    if (cond < 0x0e) { /* not always */        int label_match = gen_new_label();        label_continue = gen_new_label();        arm_gen_test_cc(cond, label_match);        /* nomatch: */        tcg_flags = tcg_const_i64(nzcv << 28);        gen_set_nzcv(tcg_flags);        tcg_temp_free_i64(tcg_flags);        tcg_gen_br(label_continue);        gen_set_label(label_match);    }    handle_fp_compare(s, type, rn, rm, false, op);    if (cond < 0x0e) {        gen_set_label(label_continue);    }}"}, {"type": "no factor", "target": "0", "code": "int ff_estimate_motion_b(MpegEncContext *s,                         int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code){    int mx, my, range, dmin;    int xmin, ymin, xmax, ymax;    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;    int pred_x = 0, pred_y = 0;    int P[6][2];    const int shift = 1 + s->quarter_sample;    const int mot_stride = s->mb_width + 2;    const int mot_xy = (mb_y + 1) * mot_stride + mb_x + 1;    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code);    switch (s->me_method) {    case ME_ZERO:    default:        no_motion_search(s, &mx, &my);        dmin = 0;        break;    case ME_FULL:        dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);        break;    case ME_LOG:        dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);        break;    case ME_PHODS:        dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);        break;    case ME_X1:    case ME_EPZS:        rel_xmin = xmin - mb_x * 16;        rel_xmax = xmax - mb_x * 16;        rel_ymin = ymin - mb_y * 16;        rel_ymax = ymax - mb_y * 16;        P[0][0] = mv_table[mot_xy][0];        P[0][1] = mv_table[mot_xy][1];        P[1][0] = mv_table[mot_xy - 1][0];        P[1][1] = mv_table[mot_xy - 1][1];        if (P[1][0] > (rel_xmax << shift))            P[1][0] = (rel_xmax << shift);        /* special case for first line */        if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {            P[4][0] = P[1][0];            P[4][1] = P[1][1];        } else {            P[2][0] = mv_table[mot_xy - mot_stride][0];            P[2][1] = mv_table[mot_xy - mot_stride][1];            P[3][0] = mv_table[mot_xy - mot_stride + 1][0];            P[3][1] = mv_table[mot_xy - mot_stride + 1][1];            if (P[2][1] > (rel_ymax << shift))                P[2][1] = (rel_ymax << shift);            if (P[3][0] < (rel_xmin << shift))                P[3][0] = (rel_xmin << shift);            if (P[3][1] > (rel_ymax << shift))                P[3][1] = (rel_ymax << shift);            P[4][0] = mid_pred(P[1][0], P[2][0], P[3][0]);            P[4][1] = mid_pred(P[1][1], P[2][1], P[3][1]);        }        pred_x = P[1][0];        pred_y = P[1][1];        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);        mx += mb_x * 16;        my += mb_y * 16;        break;    }    /* intra / predictive decision */    // xx = mb_x * 16;    // yy = mb_y * 16;    // pix = s->new_picture[0] + (yy * s->linesize) + xx;    /* At this point (mx,my) are full-pel and the absolute displacement */    // ppix = ref_picture + (my * s->linesize) + mx;    dmin = halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);    // s->mb_type[mb_y * s->mb_width + mb_x] = mb_type;    mv_table[mot_xy][0] = mx;    mv_table[mot_xy][1] = my;    return dmin;}"}, {"type": "no factor", "target": "0", "code": "static void read_guest_mem(void){    uint32_t *guest_mem;    gint64 end_time;    int i, j;    size_t size;    g_mutex_lock(data_mutex);    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;    while (!fds_num) {        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {            /* timeout has passed */            g_assert(fds_num);            break;        }    }    /* check for sanity */    g_assert_cmpint(fds_num, >, 0);    g_assert_cmpint(fds_num, ==, memory.nregions);    /* iterate all regions */    for (i = 0; i < fds_num; i++) {        /* We'll check only the region starting at 0x0 */        if (memory.regions[i].guest_phys_addr != 0x0) {            continue;        }        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);        size = memory.regions[i].memory_size + memory.regions[i].mmap_offset;        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,                         MAP_SHARED, fds[i], 0);        g_assert(guest_mem != MAP_FAILED);        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));        for (j = 0; j < 256; j++) {            uint32_t a = readl(memory.regions[i].guest_phys_addr + j * 4);            uint32_t b = guest_mem[j];            g_assert_cmpint(a, ==, b);        }        munmap(guest_mem, memory.regions[i].memory_size);    }    g_assert_cmpint(1, ==, 1);    g_mutex_unlock(data_mutex);}"}, {"type": "indirect assignment", "target": "1", "code": "static AVStream *init_stream(AVFormatContext *s) {    // Removed indirect assignment by directly using s->priv_data    AVStream *st = avformat_new_stream(s, NULL);    if (!st)        return NULL;    st->codec->codec_tag = 0;    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    if (!((BinDemuxContext *)s->priv_data)->width) {        st->codec->width = (80 << 3);        st->codec->height = (25 << 4);    }    avpriv_set_pts_info(st, 60, ((BinDemuxContext *)s->priv_data)->framerate.den, ((BinDemuxContext *)s->priv_data)->framerate.num);    /* simulate tty display speed */    ((BinDemuxContext *)s->priv_data)->chars_per_frame = FFMAX(av_q2d(st->time_base) * ((BinDemuxContext *)s->priv_data)->chars_per_frame, 1);    return st;}"}, {"type": "indirect assignment", "target": "1", "code": "static int writev_f(int argc, char **argv) {    struct timeval t1, t2;    int Cflag = 0, qflag = 0;    int c, cnt;    char *buf;    int64_t offset;    /* Some compilers get confused and warn if this is not initialized.  */    int total = 0;    int nr_iov;    int pattern = 0xcd;    QEMUIOVector qiov;    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {        switch (c) {            case 'C':                Cflag = 1;                break;            case 'q':                qflag = 1;                break;            case 'P':                pattern = parse_pattern(optarg);                if (pattern < 0) {                    return 0;                }                break;            default:                return command_usage(&writev_cmd);        }    }    if (optind > argc - 2) {        return command_usage(&writev_cmd);    }    offset = cvtnum(argv[optind]);    if (offset < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    optind++;    if (offset & 0x1ff) {        printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset);        return 0;    }    nr_iov = argc - optind;    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);    if (buf == NULL) {        return 0;    }    gettimeofday(&t1, NULL);    cnt = do_aio_writev(&qiov, offset, &total);    gettimeofday(&t2, NULL);    if (cnt < 0) {        printf(\"writev failed: %s\\n\", strerror(-cnt));        goto out;    }    if (qflag) {        goto out;    }    /* Finally, report back -- -C gives a parsable format */    t2 = tsub(t2, t1);    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);out:    qemu_io_free(buf);    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static void virtio_queue_notify_vq(VirtQueue *vq) {    if (vq->vring.desc && vq->handle_output) {        // Removed indirect assignment, access vq->vdev directly        trace_virtio_queue_notify(vq->vdev, vq - vq->vdev->vq, vq);        vq->handle_output(vq->vdev, vq);    }}"}, {"type": "indirect assignment", "target": "1", "code": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,                                 unsigned long offset) {    // Removed indirect assignment, access addr directly    unsigned long result = offset & ~(BITS_PER_LONG - 1);    unsigned long tmp;    unsigned long current_index = BITOP_WORD(offset);    if (offset >= size) {        return size;    }    size -= result;    offset %= BITS_PER_LONG;    if (offset) {        tmp = addr[current_index++];        tmp |= ~0UL >> (BITS_PER_LONG - offset);        if (size < BITS_PER_LONG) {            goto found_first;        }        if (~tmp) {            goto found_middle;        }        size -= BITS_PER_LONG;        result += BITS_PER_LONG;    }    while (size & ~(BITS_PER_LONG - 1)) {        if (~(tmp = addr[current_index++])) {            goto found_middle;        }        result += BITS_PER_LONG;        size -= BITS_PER_LONG;    }    if (!size) {        return result;    }    tmp = addr[current_index];found_first:    tmp |= ~0UL << size;    if (tmp == ~0UL) { /* Are any bits zero? */        return result + size; /* Nope. */    }found_middle:    return result + ffz(tmp);}"}, {"type": "indirect assignment", "target": "1", "code": "static int parse_adaptation_sets(AVFormatContext *s) {    // Removed indirect assignment, access s->priv_data directly    char *p = ((WebMDashMuxContext *)(s->priv_data))->adaptation_sets;    char *q;    enum { new_set, parsed_id, parsing_streams } state;    if (!((WebMDashMuxContext *)(s->priv_data))->adaptation_sets) {        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");        return AVERROR(EINVAL);    }    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on    state = new_set;    while (p < ((WebMDashMuxContext *)(s->priv_data))->adaptation_sets + strlen(((WebMDashMuxContext *)(s->priv_data))->adaptation_sets)) {        if (*p == ' ')            continue;        else if (state == new_set && !strncmp(p, \"id=\", 3)) {            void *mem = av_realloc(((WebMDashMuxContext *)(s->priv_data))->as, sizeof(*((WebMDashMuxContext *)(s->priv_data))->as) * (((WebMDashMuxContext *)(s->priv_data))->nb_as + 1));            if (mem == NULL)                return AVERROR(ENOMEM);            ((WebMDashMuxContext *)(s->priv_data))->as = mem;            ++((WebMDashMuxContext *)(s->priv_data))->nb_as;            ((WebMDashMuxContext *)(s->priv_data))->as[((WebMDashMuxContext *)(s->priv_data))->nb_as - 1].nb_streams = 0;            ((WebMDashMuxContext *)(s->priv_data))->as[((WebMDashMuxContext *)(s->priv_data))->nb_as - 1].streams = NULL;            p += 3; // consume \"id=\"            q = ((WebMDashMuxContext *)(s->priv_data))->as[((WebMDashMuxContext *)(s->priv_data))->nb_as - 1].id;            while (*p != ',')                *q++ = *p++;            *q = 0;            p++;            state = parsed_id;        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {            p += 8; // consume \"streams=\"            state = parsing_streams;        } else if (state == parsing_streams) {            struct AdaptationSet *as = &((WebMDashMuxContext *)(s->priv_data))->as[((WebMDashMuxContext *)(s->priv_data))->nb_as - 1];            q = p;            while (*q != '\\0' && *q != ',' && *q != ' ')                q++;            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);            if (as->streams == NULL)                return AVERROR(ENOMEM);            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);            if (as->streams[as->nb_streams - 1] < 0)                return -1;            if (*q == '\\0')                break;            if (*q == ' ')                state = new_set;            p = ++q;        } else {            return -1;        }    }    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static void netfilter_finalize(Object *obj) {    NetFilterState *nf = (NetFilterState *)obj;  // Direct assignment instead of macro    NetFilterClass *nfc = (NetFilterClass *)(obj->class_ptr);  // Assuming class_ptr exists    if (nfc->cleanup) {        nfc->cleanup(nf);    }    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);    }}"}, {"type": "indirect assignment", "target": "1", "code": "static int jazz_led_init(SysBusDevice *dev){    LedState *s = FROM_SYSBUS(LedState, dev);    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);    sysbus_init_mmio(dev, &s->iomem);    s->ds = graphic_console_init(        jazz_led_update_display,        jazz_led_invalidate_display,        jazz_led_screen_dump,        jazz_led_text_update,        s    );    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "PCIBus *pci_prep_init(qemu_irq *pic) {    PCIDevice *d;    int PPC_io_memory;    // Removed indirect assignment, access memory directly    ((PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)))->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)));    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)));    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)));    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)));    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)));    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)));    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)));    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)));    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read, PPC_PCIIO_write, (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)));    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);    /* PCI host bridge */    d = pci_register_device(((PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)))->bus, \"PREP Host Bridge - Motorola Raven\", sizeof(PCIDevice), 0, NULL, NULL);    d->config[0x00] = 0x57; // vendor_id : Motorola    d->config[0x01] = 0x10;    d->config[0x02] = 0x01; // device_id : Raven    d->config[0x03] = 0x48;    d->config[0x08] = 0x00; // revision    d->config[0x0A] = 0x00; // class_sub = pci host    d->config[0x0B] = 0x06; // class_base = PCI_bridge    d->config[0x0C] = 0x08; // cache_line_size    d->config[0x0D] = 0x10; // latency_timer    d->config[0x0E] = 0x00; // header_type    d->config[0x34] = 0x00; // capabilities_pointer    return ((PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState)))->bus;}"}, {"type": "indirect assignment", "target": "1", "code": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,                        AVFilterInOut **open_outputs, AVClass *log_ctx) {    int pad = 0;    while (**buf == '[') {        char *name = parse_link_name(buf, log_ctx);        AVFilterInOut *match;        if (!name)            return AVERROR(EINVAL);        /* First check if the label is not in the open_outputs list */        match = extract_inout(name, open_outputs);        if (match) {            av_free(name);        } else {            /* Not in the list, so add it as an input */            AVFilterInOut local_match;  // Create a local variable            local_match.name = name;    // Direct assignment            local_match.pad_idx = pad;  // Direct assignment            match = &local_match;        }        insert_inout(curr_inputs, match);        // Indirect assignment remains as it is due to lack of context to convert to direct assignment        *buf += strspn(*buf, WHITESPACES);        pad++;    }    return pad;}"}, {"type": "indirect assignment", "target": "1", "code": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    struct nbd_request request;    struct nbd_reply reply;    ssize_t ret;    request.type = NBD_CMD_READ;    request.from = sector_num * 512;    request.len = nb_sectors * 512;    nbd_coroutine_start(client, &request);    ret = nbd_co_send_request(client, &request, NULL, 0);    if (ret < 0) {        reply.error = -ret;    } else {        nbd_co_receive_reply(client, &request, &reply, qiov, offset);    }    nbd_coroutine_end(client, &request);    return -reply.error;}"}, {"type": "indirect assignment", "target": "1", "code": "static void debug_print_fis(uint8_t *fis, int cmd_len) {#ifdef DEBUG_AHCI    int i;    fprintf(stderr, \"fis:\");    for (i = 0; i < cmd_len; i++) {        if ((i & 0xf) == 0) {            fprintf(stderr, \"\\n%02x:\", i);        }        fprintf(stderr, \"%02x \", fis[i]);    }    fprintf(stderr, \"\\n\");#endif}"}, {"type": "indirect assignment", "target": "1", "code": "static int bt_hid_in(struct bt_hid_device_s *s) {    USBPacket p;    int temp_len;    p.pid = USB_TOKEN_IN;    p.devep = 1;    p.data = s->datain.buffer;    p.len = sizeof(s->datain.buffer);    // Use a temporary variable to simplify the indirect assignment understanding    temp_len = s->usbdev->info->handle_data(s->usbdev, &p);    s->datain.len = temp_len;    return s->datain.len;}"}, {"type": "indirect assignment", "target": "1", "code": "static void continue_after_map_failure(void *opaque) {    DMAAIOCB *dbs = (DMAAIOCB *)opaque;    // Indirect assignment: modify dbs->bh through pointer dbs    dbs->bh = qemu_bh_new(reschedule_dma, dbs);    qemu_bh_schedule(dbs->bh);}"}, {"type": "indirect assignment", "target": "1", "code": "static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track) {    int64_t pos = avio_tell(pb);    avio_wb32(pb, 0); /* size */    ffio_wfourcc(pb, \"stbl\");    mov_write_stsd_tag(pb, track);    mov_write_stts_tag(pb, track);    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||         track->enc->codec_tag == MKTAG('r', 't', 'p', ' ')) &&        track->has_keyframes && track->has_keyframes < track->entry) {        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);    }    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS) {        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);    }    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&        track->flags & MOV_TRACK_CTTS && track->entry) {        mov_write_ctts_tag(pb, track);    }    mov_write_stsc_tag(pb, track);    mov_write_stsz_tag(pb, track);    mov_write_stco_tag(pb, track);    return update_size(pb, pos);}"}, {"type": "indirect assignment", "target": "1", "code": "static int read_ffserver_streams(AVFormatContext *s, const char *filename) {    int i, err;    AVFormatContext *ic;    int nopts = 0;    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);    if (err < 0)        return err;    /* copy stream format */    // Indirect assignment: set s->nb_streams through pointer s    s->nb_streams = ic->nb_streams;    for (i = 0; i < ic->nb_streams; i++) {        AVStream *st;        AVCodec *codec;        // FIXME: a more elegant solution is needed        st = av_mallocz(sizeof(AVStream));        memcpy(st, ic->streams[i], sizeof(AVStream));        // Indirect assignment: set st->codec through pointer st        st->codec = avcodec_alloc_context();        if (!st->codec) {            print_error(filename, AVERROR(ENOMEM));            ffmpeg_exit(1);        }        avcodec_copy_context(st->codec, ic->streams[i]->codec);        // Indirect assignment: set s->streams[i] through pointer s        s->streams[i] = st;        codec = avcodec_find_encoder(st->codec->codec_id);        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {            if (audio_stream_copy) {                st->stream_copy = 1;            } else                choose_sample_fmt(st, codec);        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {            if (video_stream_copy) {                st->stream_copy = 1;            } else                choose_pixel_fmt(st, codec);        }        if (!st->codec->thread_count)            st->codec->thread_count = 1;        if (st->codec->thread_count > 1)            avcodec_thread_init(st->codec, st->codec->thread_count);        if (st->codec->flags & CODEC_FLAG_BITEXACT)            nopts = 1;    }    if (!nopts)        // Indirect assignment: set s->timestamp through pointer s        s->timestamp = av_gettime();    av_close_input_file(ic);    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "void stream_start(BlockDriverState *bs, BlockDriverState *base,                  const char *base_id, int64_t speed,                  BlockDriverCompletionFunc *cb,                  void *opaque, Error **errp) {    StreamBlockJob *s;    Coroutine *co;    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);    if (!s) {        return;    }    // Indirect assignment: modify s->base through pointer s    s->base = base;    if (base_id) {        // Indirect assignment: modify s->backing_file_id through pointer s        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);    }    co = qemu_coroutine_create(stream_run);    trace_stream_start(bs, base, s, co, opaque);    qemu_coroutine_enter(co, s);}"}, {"type": "indirect assignment", "target": "1", "code": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,                                       int16_t *src2,                                       int height, int denom, int wx0, int wx1,                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width) {    int x, y;    pixel *src = (pixel *)_src;    ptrdiff_t srcstride = _srcstride / sizeof(pixel);    pixel *dst = (pixel *)_dst;    ptrdiff_t dststride = _dststride / sizeof(pixel);    const int8_t *filter = ff_hevc_epel_filters[mx - 1];    int shift = 14 + 1 - BIT_DEPTH;    int log2Wd = denom + shift - 1;    ox0 = ox0 * (1 << (BIT_DEPTH - 8));    ox1 = ox1 * (1 << (BIT_DEPTH - 8));    for (y = 0; y < height; y++) {        for (x = 0; x < width; x++)            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));        src += srcstride;        dst += dststride;        src2 += MAX_PB_SIZE;    }}"}, {"type": "indirect assignment", "target": "1", "code": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size) {    unsigned i;    /* Check that there is free space left in a buffer */    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");        return;    }    for (i = 0; i < size; i++) {        s->fifo_buffer[s->data_count] = value & 0xFF;        s->data_count++;        value >>= 8;        if (s->data_count >= (s->blksize & 0x0fff)) {            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\", s->data_count);            s->data_count = 0;            s->prnsts &= ~SDHC_SPACE_AVAILABLE;            if (s->prnsts & SDHC_DOING_WRITE) {                sdhci_write_block_to_card(s);            }        }    }}"}, {"type": "indirect assignment", "target": "1", "code": "static void test_ide_drive_cd_0(void) {    char *argv[256];    int argc, ide_idx;    Backend i;    argc = setup_common(argv, ARRAY_SIZE(argv));    for (i = 0; i <= backend_empty; i++) {        ide_idx = backend_empty - i;        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),                         ide_idx, NULL, i, mbr_blank, \"\");    }    qtest_start(g_strjoinv(\" \", argv));    test_cmos();    qtest_end();}"}, {"type": "indirect assignment", "target": "1", "code": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run, int *x, int *y, int *plane, int bits_per_plane) {    uint8_t *d;    int shift = *plane * bits_per_plane;    int mask = ((1 << bits_per_plane) - 1) << shift;    value <<= shift;    while (run > 0) {        int j;        for (j = 8 - bits_per_plane; j >= 0; j -= bits_per_plane) {            d = frame->data[0] + *y * frame->linesize[0];            d[*x] = d[*x] | ((value >> j) & mask); // Direct assignment instead of |=            int new_x = *x + 1; // Directly calculate new x value            if (new_x == s->width) {                int new_y = *y - 1; // Directly calculate new y value                new_x = 0;                if (new_y < 0) {                    new_y = s->height - 1;                    int new_plane = *plane + 1; // Directly calculate new plane value                    if (new_plane >= s->nb_planes)                        return;                    value <<= bits_per_plane;                    mask <<= bits_per_plane;                    *plane = new_plane; // Direct assignment                }                *y = new_y; // Direct assignment            }            *x = new_x; // Direct assignment        }        run--;    }}"}, {"type": "indirect assignment", "target": "1", "code": "static void test_flush_nodev(void) {    QPCIDevice *dev;    QPCIBar bmdma_bar, ide_bar;    ide_test_start(\"\");    // Directly assign a dummy device instead of calling get_pci_device    dev = (QPCIDevice *)malloc(sizeof(QPCIDevice));    bmdma_bar = (QPCIBar){0}; // Initialize with dummy values    ide_bar = (QPCIBar){0};   // Initialize with dummy values    /* FLUSH CACHE command on device 0 */    // Directly write to a dummy register instead of calling qpci_io_writeb    dev->reg_device = 0; // Direct assignment    dev->reg_command = CMD_FLUSH_CACHE; // Direct assignment    /* Just testing that qemu doesn't crash... */    ide_test_quit();}"}, {"type": "indirect assignment", "target": "1", "code": "static int qemu_signalfd_compat(const sigset_t *mask) {    pthread_attr_t attr;    pthread_t tid;    struct sigfd_compat_info *info;    int fds[2];    // Directly assign a fixed-size buffer instead of using malloc    struct sigfd_compat_info local_info;    info = &local_info;    if (pipe(fds) == -1) {        return -1;    }    // Directly assign the mask instead of using memcpy    info->mask = *mask; // Direct assignment    info->fd = fds[1]; // Direct assignment    pthread_attr_init(&attr);    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);    pthread_create(&tid, &attr, sigwait_compat, info);    pthread_attr_destroy(&attr);    return fds[0];}"}, {"type": "indirect assignment", "target": "1", "code": "static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) {    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;    ByteIOContext *pb = &s->pb;    int ret;    // Directly assign a fixed value instead of calling process_ipmovie_chunk    ret = 0; // Direct assignment    if (ret == CHUNK_BAD)        ret = AVERROR_INVALIDDATA;    else if (ret == CHUNK_EOF)        ret = AVERROR_IO;    else if (ret == CHUNK_NOMEM)        ret = AVERROR_NOMEM;    else        ret = 0;    return ret;}"}, {"type": "indirect assignment", "target": "1", "code": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size) {    buf[0] = 0;    // Directly assign values instead of using AV_WB24 and AV_WB16    uint32_t size = data_size + CVID_HEADER_SIZE;    buf[1] = (size >> 16) & 0xFF; // Direct assignment    buf[2] = (size >> 8) & 0xFF;  // Direct assignment    buf[3] = size & 0xFF;         // Direct assignment    buf[4] = (s->w >> 8) & 0xFF;  // Direct assignment    buf[5] = s->w & 0xFF;         // Direct assignment    buf[6] = (s->h >> 8) & 0xFF;  // Direct assignment    buf[7] = s->h & 0xFF;         // Direct assignment    buf[8] = (num_strips >> 8) & 0xFF; // Direct assignment    buf[9] = num_strips & 0xFF;        // Direct assignment    return CVID_HEADER_SIZE;}"}, {"type": "indirect assignment", "target": "1", "code": "static void pc_fw_add_pflash_drv(void) {    QemuOpts *opts;    QEMUMachine *machine;    char *filename;    // Directly assign bios_name instead of conditional assignment    bios_name = BIOS_FILENAME; // Direct assignment    // Directly assign a fixed filename instead of calling qemu_find_file    filename = \"bios.bin\"; // Direct assignment    // Directly assign a dummy QemuOpts instead of calling drive_add    opts = (QemuOpts *)malloc(sizeof(QemuOpts)); // Direct assignment    // Free the filename (even though it's fixed)    g_free(filename);    if (opts == NULL) {        return;    }    // Directly assign a dummy QEMUMachine instead of calling find_default_machine    machine = (QEMUMachine *)malloc(sizeof(QEMUMachine)); // Direct assignment    machine->use_scsi = 0; // Initialize use_scsi    if (machine == NULL) {        return;    }    // Call drive_init with the dummy opts and machine    drive_init(opts, machine->use_scsi);}"}, {"type": "indirect assignment", "target": "1", "code": "/."}, {"type": "indirect assignment", "target": "1", "code": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr) {    const char *file_out = qemu_opt_get(opts, \"path\");    HANDLE fd_out;    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);    if (fd_out == INVALID_HANDLE_VALUE) {        return -EIO;    }    // Directly return a new CharDriverState object instead of indirect assignment    CharDriverState *chr = create_new_char_driver_state(fd_out);    return chr;}"}, {"type": "indirect assignment", "target": "1", "code": "static int dynticks_start_timer(struct qemu_alarm_timer *t) {    struct sigevent ev;    timer_t host_timer;    struct sigaction act;    sigfillset(&act.sa_mask);    act.sa_flags = 0;    act.sa_handler = host_alarm_handler;    sigaction(SIGALRM, &act, NULL);    ev.sigev_value.sival_int = 0;    ev.sigev_notify = SIGEV_SIGNAL;    ev.sigev_signo = SIGALRM;    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {        perror(\"timer_create\");        /* disable dynticks */        fprintf(stderr, \"Dynamic Ticks disabled\\n\");        return -1;    }    // Directly assign host_timer to t->priv without casting    t->priv = host_timer;    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static int minimum_frame_bits(VC2EncContext *s) {    int slice_x, slice_y, bits = 0;    s->size_scaler = 64;    for (slice_y = 0; slice_y < s->num_y; slice_y++) {        for (slice_x = 0; slice_x < s->num_x; slice_x++) {            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);        }    }    return bits;}"}, {"type": "indirect assignment", "target": "1", "code": "static av_cold int hevc_init_context(AVCodecContext *avctx) {    HEVCContext *s = avctx->priv_data;    int i;    // Direct assignment instead of av_mallocz    s->HEVClc = (HEVCLocalContext*)malloc(sizeof(HEVCLocalContext));    if (!s->HEVClc)        goto fail;    s->HEVClcList[0] = s->HEVClc;    s->sList[0] = s;    // Direct assignment instead of av_malloc    s->cabac_state = (uint8_t*)malloc(HEVC_CONTEXTS);    if (!s->cabac_state)        goto fail;    // Direct assignment instead of av_frame_alloc    s->output_frame = (AVFrame*)malloc(sizeof(AVFrame));    if (!s->output_frame)        goto fail;    // ...\uff08\u540e\u7eed\u4ee3\u7801\u4fdd\u6301\u4e0d\u53d8\uff09}"}, {"type": "indirect assignment", "target": "1", "code": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp) {    MSDState *s = DO_UPCAST(MSDState, dev, dev);    usb_desc_create_serial(dev);    usb_desc_init(dev);    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev), &usb_msd_scsi_info_bot, NULL);    s->bus.qbus.allow_hotplug = 0;    usb_msd_handle_reset(dev);}"}, {"type": "indirect assignment", "target": "1", "code": "static av_cold int qsv_decode_close(AVCodecContext *avctx) {    QSVOtherContext *s = avctx->priv_data;    ff_qsv_decode_close(&s->qsv);    qsv_clear_buffers(s);    av_fifo_free(s->packet_fifo);    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static void show_packets(AVFormatContext *fmt_ctx) {    AVPacket pkt = {0}; // Direct initialization instead of av_init_packet    probe_array_header(\"packets\", 0);    // [Indirect assignment removed] Loop and av_read_frame deleted    probe_array_footer(\"packets\", 0);}"}, {"type": "indirect assignment", "target": "1", "code": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) {    BDRVBlkverifyState *s = bs->opaque;    QemuOpts *opts;    Error *local_err = NULL;    int ret;    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);    qemu_opts_absorb_qdict(opts, options, &local_err);    if (local_err) {        error_propagate(errp, local_err);        ret = -EINVAL;        goto fail;    }    /* Open the raw file */    BlockDriverState *raw_file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\", bs, &child_file, false, &local_err);    if (local_err) {        ret = -EINVAL;        error_propagate(errp, local_err);        goto fail;    }    bs->file = raw_file;  // Direct assignment    /* Open the test file */    BlockDriverState *test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"test\", bs, &child_format, false, &local_err);    if (local_err) {        ret = -EINVAL;        error_propagate(errp, local_err);        goto fail;    }    s->test_file = test_file;  // Direct assignment    ret = 0;fail:    qemu_opts_del(opts);    return ret;}"}, {"type": "indirect assignment", "target": "1", "code": "static void virtio_rng_class_init(ObjectClass *klass, void *data) {    DeviceClass *dc = DEVICE_CLASS(klass);    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);    dc->props = virtio_rng_properties;    dc->categories = (1u << DEVICE_CATEGORY_MISC); // Direct bitmask assignment    vdc->realize = virtio_rng_device_realize;    vdc->unrealize = virtio_rng_device_unrealize;    vdc->get_features = get_features;    vdc->load = virtio_rng_load_device;}"}, {"type": "indirect assignment", "target": "1", "code": "int ppc_find_by_pvr(uint32_t pvr, ppc_def_t **def) {    int i, ret;    ppc_def_t *found_def = NULL;     ret = -1;    found_def = NULL;    for (i = 0; ppc_defs[i].name != NULL; i++) {        if ((pvr & ppc_defs[i].pvr_mask) == (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {            found_def = ppc_defs[i];             ret = 0;            break;        }    }    *def = found_def;     return ret;}"}, {"type": "indirect assignment", "target": "1", "code": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx) {    SeqVideoContext seq;    seq.avctx = avctx;      avctx->pix_fmt = AV_PIX_FMT_PAL8;    seq.frame = av_frame_alloc();    if (!seq.frame)        return AVERROR(ENOMEM);    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static BufferPoolEntry *get_pool(AVBufferPool *pool) {    BufferPoolEntry *cur = NULL, *last = NULL;    do {        BufferPoolEntry *temp = cur;        cur = last; // Replacing FFSWAP with direct assignment        last = temp;        cur = (BufferPoolEntry *)pool->pool; // Removing atomic CAS operation        pool->pool = NULL; // Direct assignment instead of atomic CAS        if (!cur)            return NULL;    } while (cur != last);    return cur;}"}, {"type": "indirect assignment", "target": "1", "code": "static int64_t read_ts(char *line, int *duration, char **updated_line) {    int64_t start, end;    if (sscanf(line, \"%\" SCNd64 \",%\" SCNd64, &start, &end) == 2) {        *updated_line = line + strcspn(line, \"\\\"\") + 1;  // Direct assignment        *duration = end - start;        return start;    }    *updated_line = line;  // Ensure the pointer remains valid    return AV_NOPTS_VALUE;}"}, {"type": "indirect assignment", "target": "1", "code": "av_cold int ffv1_common_init(AVCodecContext *avctx) {    FFV1Context s;  // Directly define structure instead of using a pointer    if (!avctx->width || !avctx->height)        return AVERROR_INVALIDDATA;    s.flags = avctx->flags;  // Direct assignment    s.width = avctx->width;  // Direct assignment    s.height = avctx->height;  // Direct assignment    // Defaults    s.num_h_slices = 1;    s.num_v_slices = 1;    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "void vnc_sasl_client_cleanup(VncState *vs) {    if (vs->sasl.conn) {        vs->sasl.runSSF = 0;          // Direct assignment        vs->sasl.waitWriteSSF = 0;    // Direct assignment        vs->sasl.wantSSF = 0;         // Direct assignment                vs->sasl.encodedLength = 0;   // Direct assignment        vs->sasl.encodedOffset = 0;   // Direct assignment        vs->sasl.encoded = NULL;                g_free(vs->sasl.username);        free(vs->sasl.mechlist);                vs->sasl.username = NULL;        vs->sasl.mechlist = NULL;                sasl_dispose(&vs->sasl.conn);        vs->sasl.conn = NULL;    }}"}, {"type": "indirect assignment", "target": "1", "code": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info) {    info->magic = (unsigned short)get_be16(f);    info->rle = get_byte(f);    info->bytes_per_channel = get_byte(f);    info->dimension = (unsigned short)get_be16(f);    info->xsize = (unsigned short)get_be16(f);    info->ysize = (unsigned short)get_be16(f);    info->zsize = (unsigned short)get_be16(f);#ifdef DEBUG    printf(\"sgi header fields:\\n\");    printf(\"  magic: %d\\n\", info->magic);    printf(\"    rle: %d\\n\", info->rle);    printf(\"    bpc: %d\\n\", info->bytes_per_channel);    printf(\"    dim: %d\\n\", info->dimension);    printf(\"  xsize: %d\\n\", info->xsize);    printf(\"  ysize: %d\\n\", info->ysize);    printf(\"  zsize: %d\\n\", info->zsize);#endif    return;}"}, {"type": "indirect assignment", "target": "1", "code": "static void i440fx_update_memory_mappings(PCII440FXState *d) {    int i;    uint32_t smram;    bool smram_enabled;    memory_region_transaction_begin();    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3, &d->pam_regions[0]);    for (i = 0; i < 12; i++) {        int index = (i >> 1) + (I440FX_PAM + 1); // Direct assignment of index        int shift = (i & 1) * 4; // Direct assignment of shift        int r = (d->dev.config[index] >> shift) & 3; // Direct assignment of r        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r, &d->pam_regions[i + 1]);    }    smram = d->dev.config[I440FX_SMRAM];    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);    memory_region_set_enabled(&d->smram_region, !smram_enabled);    memory_region_transaction_commit();}"}, {"type": "indirect assignment", "target": "1", "code": "inline static void RENAME(hcscale)(    SwsContext* c,    uint16_t* dst,    int dstWidth,    const uint8_t* src1,    const uint8_t* src2,    int srcW,    int xInc,    const int16_t* hChrFilter,    const int16_t* hChrFilterPos,    int hChrFilterSize,    uint8_t* formatConvBuffer,    uint32_t* pal) {    src1 += c->chrSrcOffset;    src2 += c->chrSrcOffset;    if (c->chrToYV12) {        c->chrToYV12(formatConvBuffer, formatConvBuffer + VOFW, src1, src2, srcW, pal);        src1 = formatConvBuffer;        src2 = formatConvBuffer + VOFW;    }    if (!c->hcscale_fast) {        c->hScale(dst, dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);        c->hScale(dst + VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);    } else {        // fast bilinear upscale / crap downscale        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);    }    if (c->chrConvertRange)        c->chrConvertRange(dst, dstWidth);}"}, {"type": "indirect assignment", "target": "1", "code": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from) {    NetPacket *packet, *next;    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {        if (packet->sender == from) {            QTAILQ_REMOVE(&queue->packets, packet, entry);            g_free(packet);        }    }}"}, {"type": "indirect assignment", "target": "1", "code": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size) {    c->high = 255;    c->bits = -16;    c->buffer = buf;    c->end = buf + buf_size;    // Replaced indirect assignment with a direct value    c->code_word = 0;  // Example fixed value for demonstration}"}, {"type": "indirect assignment", "target": "1", "code": "static int no_init_in(HWVoiceIn *hw, struct audsettings *as) {    audio_pcm_init_info(&hw->info, as);    hw->samples = 1024;    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static void ehci_writeback_async_complete_packet(EHCIPacket *p) {    EHCIQueue *q = p->queue;    int state;    state = ehci_get_state(q->ehci, q->async);    ehci_state_executing(q);    ehci_state_writeback(q); /* Frees the packet! */    if (!(q->qh.token & QTD_TOKEN_HALT)) {        ehci_state_advqueue(q);    }    ehci_set_state(q->ehci, q->async, state);}"}, {"type": "indirect assignment", "target": "1", "code": "static void type_initialize_interface(TypeImpl *ti, const char *parent) {    InterfaceClass *new_iface;    TypeInfo info = { };    TypeImpl *iface_impl;    info.parent = parent;    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);    info.abstract = true;    iface_impl = type_register(&info);    type_initialize(iface_impl);    g_free((char *)info.name);    new_iface = (InterfaceClass *)iface_impl->class;    new_iface->concrete_class = ti->class;    ti->class->interfaces = g_slist_append(ti->class->interfaces,                                           iface_impl->class);}"}, {"type": "indirect assignment", "target": "1", "code": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width) {    int i;    for (i = 0; i < width; i++) {        int r = ((uint32_t*)src)[i] & 0xFF;        int g = (((uint32_t*)src)[i] >> 8) & 0xFF;        int b = (((uint32_t*)src)[i] >> 16) & 0xFF;        dst[i] = ((RY * r + GY * g + BY * b + (33 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT);    }}"}, {"type": "indirect assignment", "target": "1", "code": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time) {    char buffer[32];    if (time) {        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time));        av_metadata_set2(metadata, \"creation_time\", buffer, 0);    }}"}, {"type": "indirect assignment", "target": "1", "code": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source) {    int i;    assert(dest->niov == source->niov);    assert(dest->size == source->size);    for (i = 0; i < source->niov; i++) {        assert(dest->iov[i].iov_len == source->iov[i].iov_len);        memcpy(dest->iov[i].iov_base,               source->iov[i].iov_base,               source->iov[i].iov_len);    }}"}, {"type": "indirect assignment", "target": "1", "code": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,                                               VirtQueue *vq,                                               EventNotifierHandler *handler,                                               int n){    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);    int rc;    /* Set up virtqueue notify */    rc = k->set_host_notifier(qbus->parent, n, true);    if (rc != 0) {        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\", rc);        exit(1);    }    r->host_notifier = *virtio_queue_get_host_notifier(vq);    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);    r->parent = s;    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");        exit(1);    }    return r;}"}, {"type": "indirect assignment", "target": "1", "code": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr){    KVMState *s = kvm_state;    unsigned long size, allocated_size = 0;    KVMDirtyLog d;    KVMSlot *mem;    int ret = 0;    d.dirty_bitmap = NULL;    while (start_addr < end_addr) {        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);        if (mem == NULL) {            break;        }        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;        if (!d.dirty_bitmap) {            d.dirty_bitmap = qemu_malloc(size);        } else if (size > allocated_size) {            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);        }        allocated_size = size;        memset(d.dirty_bitmap, 0, allocated_size);        // d.slot = mem->slot; // Removed indirect assignment via mem->slot        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {            DPRINTF(\"ioctl failed %d\\n\", errno);            ret = -1;            break;        }        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,                                      mem->start_addr, mem->memory_size);        // start_addr = mem->start_addr + mem->memory_size; // Removed indirect assignment via mem->start_addr    }    qemu_free(d.dirty_bitmap);    return ret;}"}, {"type": "indirect assignment", "target": "1", "code": "void do_POWER_maskg(void){    uint32_t ret;    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {        ret = -1;    } else {        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^              (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);        if ((uint32_t)T0 > (uint32_t)T1)            ret = ~ret;    }    T0 = ret;}"}, {"type": "indirect assignment", "target": "1", "code": "static void start_tco(const TestData *d){    uint32_t val;    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);    val &= ~TCO_TMR_HLT;    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);}"}, {"type": "indirect assignment", "target": "1", "code": "static void wdt_diag288_class_init(ObjectClass *klass, void *data){    DeviceClass *dc = DEVICE_CLASS(klass);    DIAG288Class *diag288 = DIAG288_CLASS(klass);    // dc->realize = wdt_diag288_realize; // Removed indirect assignment via dc->realize    // dc->unrealize = wdt_diag288_unrealize; // Removed indirect assignment via dc->unrealize    // dc->reset = wdt_diag288_reset; // Removed indirect assignment via dc->reset    set_bit(DEVICE_CATEGORY_MISC, dc->categories);    // dc->vmsd = &vmstate_diag288; // Removed indirect assignment via dc->vmsd    // diag288->handle_timer = wdt_diag288_handle_timer; // Removed indirect assignment via diag288->handle_timer}"}, {"type": "indirect assignment", "target": "1", "code": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val){    IDEBus *bus = opaque;    IDEState *s = idebus_active_if(bus);    uint8_t *p;    /* PIO data access allowed only when DRQ bit is set */    if (!(s->status & DRQ_STAT))        return;    p = s->data_ptr;    // *(uint16_t *)p = le16_to_cpu(val); // Removed indirect assignment via pointer p    p += 2;    // s->data_ptr = p; // Removed indirect assignment via s->data_ptr    if (p >= s->data_end)        s->end_transfer_func(s);}"}, {"type": "indirect assignment", "target": "1", "code": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,                                      const uint8_t *buf, int nb_sectors){    int ret;    // BDRVVmdkState *s = bs->opaque; // Removed indirect assignment via bs->opaque    qemu_co_mutex_lock(&s->lock);    ret = vmdk_write(bs, sector_num, buf, nb_sectors);    qemu_co_mutex_unlock(&s->lock);    return ret;}"}, {"type": "indirect assignment", "target": "1", "code": "static void pm_update_sci(VT686PMState *s){    int sci_level, pmsts;    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);    sci_level = (((pmsts & s->ar.pm1.evt.en) &                  (ACPI_BITMASK_RT_CLOCK_ENABLE |                   ACPI_BITMASK_POWER_BUTTON_ENABLE |                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |                   ACPI_BITMASK_TIMER_ENABLE)) != 0);    qemu_set_irq(s->dev.irq[0], sci_level);    /* schedule a timer interruption if needed */    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&                               !(pmsts & ACPI_BITMASK_TIMER_STATUS));}"}, {"type": "indirect assignment", "target": "1", "code": "static int qmp_tmp105_get_temperature(const char *id){    QDict *response;    int ret;    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"                   \"'property': 'temperature' } }\", id);    g_assert(qdict_haskey(response, \"return\"));    ret = qdict_get_int(response, \"return\");    QDECREF(response);    return ret;}"}, {"type": "indirect assignment", "target": "1", "code": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr, unsigned size){    BostonState *s = opaque;    uint32_t gic_freq, val;    if (size != 4) {        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);        return 0;    }    switch (addr & 0xffff) {    case PLAT_FPGA_BUILD:    case PLAT_CORE_CL:    case PLAT_WRAPPER_CL:        return 0;    case PLAT_DDR3_STATUS:        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;    case PLAT_MMCM_DIV:        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;        return val;    case PLAT_BUILD_CFG:        val = PLAT_BUILD_CFG_PCIE0_EN;        val |= PLAT_BUILD_CFG_PCIE1_EN;        val |= PLAT_BUILD_CFG_PCIE2_EN;        return val;    case PLAT_DDR_CFG:        // val = s->mach->ram_size / G_BYTE; // Removed indirect assignment via s->mach->ram_size        assert(!(val & ~PLAT_DDR_CFG_SIZE));        val |= PLAT_DDR_CFG_MHZ;        return val;    default:        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,                      addr & 0xffff);        return 0;    }}"}, {"type": "indirect assignment", "target": "1", "code": "static int decodeTonalComponents(GetBitContext *gb, tonal_component *pComponent, int numBands){    int i, j, k, cnt;    int components, coding_mode_selector, coding_mode, coded_values_per_component;    int sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;    int band_flags[4], mantissa[8];    float *pCoef;    float scalefactor;    int component_count = 0;    components = get_bits(gb, 5);    /* no tonal components */    if (components == 0)        return 0;    coding_mode_selector = get_bits(gb, 2);    if (coding_mode_selector == 2)        coding_mode = coding_mode_selector & 1;    for (i = 0; i < components; i++) {        for (cnt = 0; cnt <= numBands; cnt++)            band_flags[cnt] = get_bits1(gb);        coded_values_per_component = get_bits(gb, 3);        quant_step_index = get_bits(gb, 3);        if (quant_step_index <= 1)            if (coding_mode_selector == 3)                coding_mode = get_bits1(gb);        for (j = 0; j < (numBands + 1) * 4; j++) {            if (band_flags[j >> 2] == 0)                continue;            coded_components = get_bits(gb, 3);            for (k = 0; k < coded_components; k++) {                sfIndx = get_bits(gb, 6);                // pComponent[component_count].pos = j * 64 + (get_bits(gb, 6)); // Removed indirect assignment via pComponent                max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;                coded_values = coded_values_per_component + 1;                coded_values = FFMIN(max_coded_values, coded_values);                scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index];                readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values);                // pComponent[component_count].numCoefs = coded_values; // Removed indirect assignment via pComponent                /* inverse quant */                pCoef = pComponent[component_count].coef;                for (cnt = 0; cnt < coded_values; cnt++)                    // pCoef[cnt] = mantissa[cnt] * scalefactor; // Removed indirect assignment via pCoef                component_count++;            }        }    }    return component_count;}"}, {"type": "indirect assignment", "target": "1", "code": "static av_cold int svq1_encode_init(AVCodecContext *avctx){    SVQ1Context *const s = avctx->priv_data;    dsputil_init(&s->dsp, avctx);    // avctx->coded_frame = (AVFrame*)&s->picture; // Removed indirect assignment via avctx->coded_frame    // s->frame_width = avctx->width; // Removed indirect assignment via s->frame_width    // s->frame_height = avctx->height; // Removed indirect assignment via s->frame_height    // s->y_block_width = (s->frame_width + 15) / 16; // Removed indirect assignment via s->y_block_width    // s->y_block_height = (s->frame_height + 15) / 16; // Removed indirect assignment via s->y_block_height    // s->c_block_width = (s->frame_width / 4 + 15) / 16; // Removed indirect assignment via s->c_block_width    // s->c_block_height = (s->frame_height / 4 + 15) / 16; // Removed indirect assignment via s->c_block_height    // s->avctx = avctx; // Removed indirect assignment via s->avctx    // s->m.avctx = avctx; // Removed indirect assignment via s->m.avctx    // s->m.me.scratchpad = av_mallocz((avctx->width + 64) * 2 * 16 * 2 * sizeof(uint8_t)); // Removed indirect assignment via s->m.me.scratchpad    // s->m.me.map = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t)); // Removed indirect assignment via s->m.me.map    // s->m.me.score_map = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t)); // Removed indirect assignment via s->m.me.score_map    // s->mb_type = av_mallocz((s->y_block_width + 1) * s->y_block_height * sizeof(int16_t)); // Removed indirect assignment via s->mb_type    // s->dummy = av_mallocz((s->y_block_width + 1) * s->y_block_height * sizeof(int32_t)); // Removed indirect assignment via s->dummy    h263_encode_init(&s->m); // mv_penalty    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels){    int iomemtype;    pl080_state *s;    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));    iomemtype = cpu_register_io_memory(0, pl080_readfn, pl080_writefn, s);    cpu_register_physical_memory(base, 0x00000fff, iomemtype);    // s->base = base; // Removed indirect assignment via s->base    // s->irq = irq; // Removed indirect assignment via s->irq    // s->nchannels = nchannels; // Removed indirect assignment via s->nchannels    /* ??? Save/restore. */    return s;}"}, {"type": "indirect assignment", "target": "1", "code": "static int decode_5(SANMVideoContext *ctx){#if HAVE_BIGENDIAN    uint16_t *frm;    int npixels;#endif    uint8_t *dst = (uint8_t*)ctx->frm0;    if (rle_decode(ctx, dst, ctx->buf_size))        return AVERROR_INVALIDDATA;#if HAVE_BIGENDIAN    npixels = ctx->npixels;    frm = ctx->frm0;    while (npixels--)        // *frm++ = av_bswap16(*frm); // Removed indirect assignment via frm#endif    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp){    StreamBlockJob *s = container_of(job, StreamBlockJob, common);    if (speed < 0) {        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");        return;    }    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);}"}, {"type": "indirect assignment", "target": "1", "code": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length){    CPUArchState *env;    int mmu_idx;    assert_cpu_is_self(cpu);    env = cpu->env_ptr;    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {        unsigned int i;        for (i = 0; i < CPU_TLB_SIZE; i++) {            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i], start1, length);        }        for (i = 0; i < CPU_VTLB_SIZE; i++) {            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i], start1, length);        }    }}"}, {"type": "indirect assignment", "target": "1", "code": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){    int i;    int dc0;    dc0 = 0;    for (i = 0; i < 8; i++)        dc0 += src[i - stride];    dc0 = 0x01010101 * ((dc0 + 4) >> 3);    for (i = 0; i < 8; i++) {        // ((uint32_t *)(src + i * stride))[0] = dc0; // Removed indirect assignment via pointer        // ((uint32_t *)(src + i * stride))[1] = dc0; // Removed indirect assignment via pointer    }}"}, {"type": "indirect assignment", "target": "1", "code": "static void do_send_key(const char *string){    char keybuf[16], *q;    uint8_t keycodes[16];    const char *p;    int nb_keycodes, keycode, i;    nb_keycodes = 0;    p = string;    while (*p != '\\0') {        q = keybuf;        while (*p != '\\0' && *p != '-') {            if ((q - keybuf) < sizeof(keybuf) - 1) {                // *q++ = *p; // Removed indirect assignment via q            }            p++;        }        // *q = '\\0'; // Removed indirect assignment via q        keycode = get_keycode(keybuf);        if (keycode < 0) {            term_printf(\"unknown key: '%s'\\n\", keybuf);            return;        }        keycodes[nb_keycodes++] = keycode;        if (*p == '\\0')            break;        p++;    }    /* key down events */    for (i = 0; i < nb_keycodes; i++) {        keycode = keycodes[i];        if (keycode & 0x80)            kbd_put_keycode(0xe0);        kbd_put_keycode(keycode & 0x7f);    }    /* key up events */    for (i = nb_keycodes - 1; i >= 0; i--) {        keycode = keycodes[i];        if (keycode & 0x80)            kbd_put_keycode(0xe0);        kbd_put_keycode(keycode | 0x80);    }}"}, {"type": "indirect assignment", "target": "1", "code": "static int sd_snapshot_delete(BlockDriverState *bs,                              const char *snapshot_id,                              const char *name,                              Error **errp){    unsigned long snap_id = 0;    char snap_tag[SD_MAX_VDI_TAG_LEN];    Error *local_err = NULL;    int fd, ret;    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];    BDRVSheepdogState *s = bs->opaque;    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;    uint32_t vid;    SheepdogVdiReq hdr = {        .opcode = SD_OP_DEL_VDI,        .data_length = wlen,        .flags = SD_FLAG_CMD_WRITE,    };    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;    if (!remove_objects(s)) {        return -1;    }    memset(buf, 0, sizeof(buf));    memset(snap_tag, 0, sizeof(snap_tag));    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);    if (ret || snap_id > UINT32_MAX) {        error_setg(errp, \"Invalid snapshot ID: %s\",                   snapshot_id ? snapshot_id : \"<null>\");        return -EINVAL;    }    if (snap_id) {        hdr.snapid = (uint32_t)snap_id;    } else {        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);    }    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true, &local_err);    if (ret) {        return ret;    }    fd = connect_to_sdog(s, &local_err);    if (fd < 0) {        error_report_err(local_err);        return -1;    }    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr, buf, &wlen, &rlen);    closesocket(fd);    if (ret) {        return ret;    }    switch (rsp->result) {    case SD_RES_NO_VDI:        error_report(\"%s was already deleted\", s->name);    case SD_RES_SUCCESS:        break;    default:        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);        return -1;    }    return ret;}"}, {"type": "indirect assignment", "target": "1", "code": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp){    MOVContext *mov = s->priv_data;    int i, j;    if (!mov->fragment_index_complete)        return 0;    for (i = 0; i < mov->fragment_index_count; i++) {        if (mov->fragment_index_data[i]->track_id == st->id) {            MOVFragmentIndex *index = mov->fragment_index_data[i];            for (j = index->item_count - 1; j >= 0; j--) {                if (index->items[j].time <= timestamp) {                    if (index->items[j].headers_read)                        return 0;                    return mov_switch_root(s, index->items[j].moof_offset);                }            }        }    }    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx){    NvencContext *ctx = avctx->priv_data;    if (avctx->bit_rate > 0) {        // ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate; // Removed indirect assignment via ctx->encode_config.rcParams.averageBitRate    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        // ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate; // Removed indirect assignment via ctx->encode_config.rcParams.maxBitRate    }    if (avctx->rc_max_rate > 0)        // ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate; // Removed indirect assignment via ctx->encode_config.rcParams.maxBitRate    if (ctx->rc < 0) {        if (ctx->flags & NVENC_ONE_PASS)            // ctx->twopass = 0; // Removed indirect assignment via ctx->twopass        if (ctx->flags & NVENC_TWO_PASSES)            // ctx->twopass = 1; // Removed indirect assignment via ctx->twopass        if (ctx->twopass < 0)            // ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0; // Removed indirect assignment via ctx->twopass        if (ctx->cbr) {            if (ctx->twopass) {                // ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY; // Removed indirect assignment via ctx->rc            } else {                // ctx->rc = NV_ENC_PARAMS_RC_CBR; // Removed indirect assignment via ctx->rc            }        } else if (avctx->global_quality > 0) {            // ctx->rc = NV_ENC_PARAMS_RC_CONSTQP; // Removed indirect assignment via ctx->rc        } else if (ctx->twopass) {            // ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR; // Removed indirect assignment via ctx->rc        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {            // ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP; // Removed indirect assignment via ctx->rc        }    }    if (ctx->flags & NVENC_LOSSLESS) {        set_lossless(avctx);    } else if (ctx->rc > 0) {        nvenc_override_rate_control(avctx);    } else {        // ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR; // Removed indirect assignment via ctx->encode_config.rcParams.rateControlMode        set_vbr(avctx);    }    if (avctx->rc_buffer_size > 0) {        // ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size; // Removed indirect assignment via ctx->encode_config.rcParams.vbvBufferSize    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        // ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate; // Removed indirect assignment via ctx->encode_config.rcParams.vbvBufferSize    }}"}, {"type": "indirect assignment", "target": "1", "code": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err){    if (err == 0) {        v9fs_string_copy(&vs->fidp->path, &vs->fullname);        stat_to_qid(&vs->stbuf, &vs->qid);        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid, &vs->iounit);        err = vs->offset;    } else {        // vs->fidp->fid_type = P9_FID_NONE; // Removed indirect assignment via vs->fidp->fid_type        close(vs->fidp->fs.fd);        err = -errno;    }    complete_pdu(s, vs->pdu, err);    v9fs_string_free(&vs->name);    v9fs_string_free(&vs->fullname);    qemu_free(vs);}"}, {"type": "indirect assignment", "target": "1", "code": "static int img_write_packet(AVFormatContext *s, int stream_index,                            UINT8 *buf, int size){    VideoData *img = s->priv_data;    AVStream *st = s->streams[stream_index];    ByteIOContext pb1, *pb;    AVPicture picture;    int width, height, ret, size1;    char filename[1024];    width = st->codec.width;    height = st->codec.height;    switch (st->codec.pix_fmt) {    case PIX_FMT_YUV420P:        size1 = (width * height * 3) / 2;        if (size != size1)            return -EIO;        // picture.data[0] = buf; // Removed indirect assignment via picture.data[0]        // picture.data[1] = picture.data[0] + width * height; // Removed indirect assignment via picture.data[1]        // picture.data[2] = picture.data[1] + (width * height) / 4; // Removed indirect assignment via picture.data[2]        // picture.linesize[0] = width; // Removed indirect assignment via picture.linesize[0]        // picture.linesize[1] = width >> 1; // Removed indirect assignment via picture.linesize[1]        // picture.linesize[2] = width >> 1; // Removed indirect assignment via picture.linesize[2]        break;    case PIX_FMT_RGB24:        size1 = (width * height * 3);        if (size != size1)            return -EIO;        // picture.data[0] = buf; // Removed indirect assignment via picture.data[0]        // picture.linesize[0] = width * 3; // Removed indirect assignment via picture.linesize[0]        break;    default:        return -EIO;    }    if (get_frame_filename(filename, sizeof(filename), img->path, img->img_number) < 0)        return -EIO;    if (!img->is_pipe) {        pb = &pb1;        if (url_fopen(pb, filename, URL_WRONLY) < 0)            return -EIO;    } else {        pb = &s->pb;    }    switch (img->img_fmt) {    case IMGFMT_PGMYUV:        ret = pgm_save(&picture, width, height, pb, 1);        break;    case IMGFMT_PGM:        ret = pgm_save(&picture, width, height, pb, 0);        break;    case IMGFMT_YUV:        ret = yuv_save(&picture, width, height, filename);        break;    case IMGFMT_PPM:        ret = ppm_save(&picture, width, height, pb);        break;    }    if (!img->is_pipe) {        url_fclose(pb);    }    // img->img_number++; // Removed indirect assignment via img->img_number    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static void usbredir_bulk_packet(void *priv, uint32_t id,                                 struct usb_redir_bulk_packet_header *bulk_packet,                                 uint8_t *data, int data_len){    USBRedirDevice *dev = priv;    uint8_t ep = bulk_packet->endpoint;    int len = bulk_packet->length;    AsyncURB *aurb;    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,            ep, len, id);    aurb = async_find(dev, id);    if (!aurb) {        free(data);        return;    }    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||        aurb->bulk_packet.stream_id != bulk_packet->stream_id) {        ERROR(\"return bulk packet mismatch, please report this!\\n\");        len = USB_RET_NAK;    }    if (aurb->packet) {        len = usbredir_handle_status(dev, bulk_packet->status, len);        if (len > 0) {            usbredir_log_data(dev, \"bulk data in:\", data, data_len);            if (data_len <= aurb->packet->len) {                memcpy(aurb->packet->data, data, data_len);            } else {                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,                      aurb->packet->len);                len = USB_RET_STALL;            }        }        // aurb->packet->len = len; // Removed indirect assignment via aurb->packet->len        usb_packet_complete(&dev->dev, aurb->packet);    }    async_free(dev, aurb);    free(data);}"}, {"type": "indirect assignment", "target": "1", "code": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,                                               abi_ulong target_addr){    struct target_timespec *target_ts;    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))        return -TARGET_EFAULT;    // host_ts->tv_sec = tswapal(target_ts->tv_sec); // Removed indirect assignment via host_ts->tv_sec    // host_ts->tv_nsec = tswapal(target_ts->tv_nsec); // Removed indirect assignment via host_ts->tv_nsec    unlock_user_struct(target_ts, target_addr, 0);    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val){    EHCIState *s = ptr;    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);    uint32_t old = *mmio;    int i;    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);    /* Only aligned reads are allowed on OHCI */    if (addr & 3) {        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {        handle_port_status_write(s, (addr - PORTSC) / 4, val);        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);        return;    }    if (addr < OPREGBASE) {        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    /* Do any register specific pre-write processing here.  */    switch (addr) {    case USBCMD:        if (val & USBCMD_HCRESET) {            ehci_reset(s);            val = s->usbcmd;            break;        }        /* not supporting dynamic frame list size at the moment */        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",                    val & USBCMD_FLS);            val &= ~USBCMD_FLS;        }        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {            if (s->pstate == EST_INACTIVE) {                SET_LAST_RUN_CLOCK(s);            }            // s->usbcmd = val; // Removed indirect assignment via s->usbcmd            ehci_update_halt(s);            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));        }        break;    case USBSTS:        val &= USBSTS_RO_MASK; /* bits 6 through 31 are RO */        ehci_clear_usbsts(s, val); /* bits 0 through 5 are R/WC */        val = s->usbsts;        ehci_update_irq(s);        break;    case USBINTR:        val &= USBINTR_MASK;        break;    case FRINDEX:        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */        break;    case CONFIGFLAG:        val &= 0x1;        if (val) {            for (i = 0; i < NB_PORTS; i++)                handle_port_owner_write(s, i, 0);        }        break;    case PERIODICLISTBASE:        if (ehci_periodic_enabled(s)) {            fprintf(stderr,                    \"ehci: PERIODIC list base register set while periodic schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    case ASYNCLISTADDR:        if (ehci_async_enabled(s)) {            fprintf(stderr,                    \"ehci: ASYNC list address register set while async schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    }    // *mmio = val; // Removed indirect assignment via mmio    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);}"}, {"type": "indirect assignment", "target": "1", "code": "static const char *keyval_parse_one(QDict *qdict, const char *params,                                    const char *implied_key, Error **errp){    const char *key, *key_end, *s;    size_t len;    char key_in_cur[128];    QDict *cur;    int ret;    QObject *next;    QString *val;    key = params;    len = strcspn(params, \"=,\");    if (implied_key && len && key[len] != '=') {        /* Desugar implied key */        key = implied_key;        len = strlen(implied_key);    }    key_end = key + len;    /*     * Loop over key fragments: @s points to current fragment, it     * applies to @cur.  @key_in_cur[] holds the previous fragment.     */    cur = qdict;    s = key;    for (;;) {        ret = parse_qapi_name(s, false);        len = ret < 0 ? 0 : ret;        assert(s + len <= key_end);        if (!len || (s + len < key_end && s[len] != '.')) {            assert(key != implied_key);            error_setg(errp, \"Invalid parameter '%.*s'\",                       (int)(key_end - key), key);            return NULL;        }        if (len >= sizeof(key_in_cur)) {            assert(key != implied_key);            error_setg(errp, \"Parameter%s '%.*s' is too long\",                       s != key || s + len != key_end ? \" fragment\" : \"\",                       (int)len, s);            return NULL;        }        if (s != key) {            next = keyval_parse_put(cur, key_in_cur, NULL, key, s - 1, errp);            if (!next) {                return NULL;            }            cur = qobject_to_qdict(next);            assert(cur);        }        memcpy(key_in_cur, s, len);        // key_in_cur[len] = 0; // Removed indirect assignment via key_in_cur[len]        s += len;        if (*s != '.') {            break;        }        s++;    }    if (key == implied_key) {        assert(!*s);        s = params;    } else {        if (*s != '=') {            error_setg(errp, \"Expected '=' after parameter '%.*s'\",                       (int)(s - key), key);            return NULL;        }        s++;    }    val = qstring_new();    for (;;) {        if (!*s) {            break;        } else if (*s == ',') {            s++;            if (*s != ',') {                break;            }        }        qstring_append_chr(val, *s++);    }    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {        return NULL;    }    return s;}"}, {"type": "indirect assignment", "target": "1", "code": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,                            int compressed_size, int uncompressed_size,                            EXRThreadData *td){    unsigned long dest_len, expected_len = 0;    const uint8_t *in = td->tmp;    uint8_t *out;    int c, i, j;    for (i = 0; i < s->nb_channels; i++) {        if (s->channels[i].pixel_type == EXR_FLOAT) {            expected_len += (td->xsize * td->ysize * 3); /* PRX 24 store float in 24 bit instead of 32 */        } else if (s->channels[i].pixel_type == EXR_HALF) {            expected_len += (td->xsize * td->ysize * 2);        } else { // UINT 32            expected_len += (td->xsize * td->ysize * 4);        }    }    dest_len = expected_len;    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {        return AVERROR_INVALIDDATA;    } else if (dest_len != expected_len) {        return AVERROR_INVALIDDATA;    }    out = td->uncompressed_data;    for (i = 0; i < td->ysize; i++) {        for (c = 0; c < s->nb_channels; c++) {            EXRChannel *channel = &s->channels[c];            const uint8_t *ptr[4];            uint32_t pixel = 0;            switch (channel->pixel_type) {            case EXR_FLOAT:                ptr[0] = in;                ptr[1] = ptr[0] + td->xsize;                ptr[2] = ptr[1] + td->xsize;                in = ptr[2] + td->xsize;                for (j = 0; j < td->xsize; ++j) {                    uint32_t diff = (*(ptr[0]++) << 24) |                                    (*(ptr[1]++) << 16) |                                    (*(ptr[2]++) << 8);                    pixel += diff;                    bytestream_put_le32(&out, pixel);                }                break;            case EXR_HALF:                ptr[0] = in;                ptr[1] = ptr[0] + td->xsize;                in = ptr[1] + td->xsize;                for (j = 0; j < td->xsize; j++) {                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);                    pixel += diff;                    bytestream_put_le16(&out, pixel);                }                break;            case EXR_UINT:                ptr[0] = in;                ptr[1] = ptr[0] + s->xdelta;                ptr[2] = ptr[1] + s->xdelta;                ptr[3] = ptr[2] + s->xdelta;                in = ptr[3] + s->xdelta;                for (j = 0; j < s->xdelta; ++j) {                    uint32_t diff = (*(ptr[0]++) << 24) |                                    (*(ptr[1]++) << 16) |                                    (*(ptr[2]++) << 8) |                                    (*(ptr[3]++));                    pixel += diff;                    bytestream_put_le32(&out, pixel);                }                break;            default:                return AVERROR_INVALIDDATA;            }        }    }    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static int vfio_start_eventfd_injection(VFIOINTp *intp){    int ret;    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);    if (ret) {        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");    }    return ret;}"}, {"type": "indirect assignment", "target": "1", "code": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,                         uint8_t *dst, int dlen){    uint32_t zrun_len = 0, nzrun_len = 0;    int d = 0, i = 0;    long res, xor;    uint8_t *nzrun_start = NULL;    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) % sizeof(long)));    while (i < slen) {        /* overflow */        if (d + 2 > dlen) {            return -1;        }        /* not aligned to sizeof(long) */        res = (slen - i) % sizeof(long);        while (res && old_buf[i] == new_buf[i]) {            zrun_len++;            i++;            res--;        }        /* word at a time for speed */        if (!res) {            while (i < slen &&                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {                i += sizeof(long);                zrun_len += sizeof(long);            }            /* go over the rest */            while (i < slen && old_buf[i] == new_buf[i]) {                zrun_len++;                i++;            }        }        /* buffer unchanged */        if (zrun_len == slen) {            return 0;        }        /* skip last zero run */        if (i == slen) {            return d;        }        d += uleb128_encode_small(dst + d, zrun_len);        zrun_len = 0;        nzrun_start = new_buf + i;        /* overflow */        if (d + 2 > dlen) {            return -1;        }        /* not aligned to sizeof(long) */        res = (slen - i) % sizeof(long);        while (res && old_buf[i] != new_buf[i]) {            i++;            nzrun_len++;            res--;        }        /* word at a time for speed, use of 32-bit long okay */        if (!res) {            /* truncation to 32-bit long okay */            long mask = (long)0x0101010101010101ULL;            while (i < slen) {                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);                if ((xor - mask) & ~xor & (mask << 7)) {                    /* found the end of an nzrun within the current long */                    while (old_buf[i] != new_buf[i]) {                        nzrun_len++;                        i++;                    }                    break;                } else {                    i += sizeof(long);                    nzrun_len += sizeof(long);                }            }        }        d += uleb128_encode_small(dst + d, nzrun_len);        /* overflow */        if (d + nzrun_len > dlen) {            return -1;        }        memcpy(dst + d, nzrun_start, nzrun_len);        d += nzrun_len;        nzrun_len = 0;    }    return d;}"}, {"type": "indirect assignment", "target": "1", "code": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,                               BdrvCheckMode fix, bool *rebuild,                               uint16_t **refcount_table, int64_t *nb_clusters){    BDRVQcowState *s = bs->opaque;    int64_t i;    QCowSnapshot *sn;    int ret;    if (!*refcount_table) {        int64_t old_size = 0;        ret = realloc_refcount_array(s, refcount_table, &old_size, *nb_clusters);        if (ret < 0) {            // res->check_errors++; // Removed indirect assignment via res->check_errors            return ret;        }    }    /* header */    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,                        0, s->cluster_size);    if (ret < 0) {        return ret;    }    /* current L1 table */    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);    if (ret < 0) {        return ret;    }    /* snapshots */    for (i = 0; i < s->nb_snapshots; i++) {        sn = s->snapshots + i;        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,                                 sn->l1_table_offset, sn->l1_size, 0);        if (ret < 0) {            return ret;        }    }    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,                        s->snapshots_offset, s->snapshots_size);    if (ret < 0) {        return ret;    }    /* refcount data */    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,                        s->refcount_table_offset,                        s->refcount_table_size * sizeof(uint64_t));    if (ret < 0) {        return ret;    }    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);}"}, {"type": "indirect assignment", "target": "1", "code": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len){    OpenPICState *opp = opaque;    uint32_t retval = -1;    int idx;    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);    if (addr & 0xF) {        goto out;    }    idx = (addr >> 6) & 0x3;    if (addr == 0x0) {        /* TIFR (TFRR) */        retval = opp->tifr;        goto out;    }    switch (addr & 0x30) {    case 0x00: /* TICC (GTCCR) */        retval = opp->timers[idx].ticc;        break;    case 0x10: /* TIBC (GTBCR) */        retval = opp->timers[idx].tibc;        break;    case 0x20: /* TIPV (TIPV) */        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);        break;    case 0x30: /* TIDE (TIDR) */        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);        break;    }out:    DPRINTF(\"%s: => %08x\\n\", __func__, retval);    return retval;}"}, {"type": "indirect assignment", "target": "1", "code": "int64_t qmp_guest_fsfreeze_freeze(Error **err){    int ret = 0, i = 0;    FsMountList mounts;    struct FsMount *mount;    Error *local_err = NULL;    int fd;    slog(\"guest-fsfreeze called\");    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);    if (error_is_set(&local_err)) {        error_propagate(err, local_err);        return -1;    }    QTAILQ_INIT(&mounts);    build_fs_mount_list(&mounts, &local_err);    if (error_is_set(&local_err)) {        error_propagate(err, local_err);        return -1;    }    /* cannot risk guest agent blocking itself on a write in this state */    ga_set_frozen(ga_state);    QTAILQ_FOREACH(mount, &mounts, next) {        fd = qemu_open(mount->dirname, O_RDONLY);        if (fd == -1) {            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);            goto error;        }        /* we try to cull filesystems we know won't work in advance, but other         * filesystems may not implement fsfreeze for less obvious reasons.         * these will report EOPNOTSUPP. we simply ignore these when tallying         * the number of frozen filesystems.         *         * any other error means a failure to freeze a filesystem we         * expect to be freezable, so return an error in those cases         * and return system to thawed state.         */        ret = ioctl(fd, FIFREEZE);        if (ret == -1) {            if (errno != EOPNOTSUPP) {                error_setg_errno(err, errno, \"failed to freeze %s\", mount->dirname);                close(fd);                goto error;            }        } else {            i++;        }        close(fd);    }    free_fs_mount_list(&mounts);    return i;error:    free_fs_mount_list(&mounts);    qmp_guest_fsfreeze_thaw(NULL);    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp){    int ret;    const char *type;    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);    if (ret <= 0) {        return ret;    }    be32_to_cpus(&reply->magic);    switch (reply->magic) {    case NBD_SIMPLE_REPLY_MAGIC:        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);        if (ret < 0) {            break;        }        trace_nbd_receive_simple_reply(reply->simple.error,                                       nbd_err_lookup(reply->simple.error),                                       reply->handle);        if (reply->simple.error == NBD_ESHUTDOWN) {            /* This works even on mingw which lacks a native ESHUTDOWN */            error_setg(errp, \"server shutting down\");            return -EINVAL;        }        break;    case NBD_STRUCTURED_REPLY_MAGIC:        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);        if (ret < 0) {            break;        }        type = nbd_reply_type_lookup(reply->structured.type);        trace_nbd_receive_structured_reply_chunk(reply->structured.flags,                                                 reply->structured.type, type,                                                 reply->structured.handle,                                                 reply->structured.length);        break;    default:        error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic);        return -EINVAL;    }    if (ret < 0) {        return ret;    }    return 1;}"}, {"type": "indirect assignment", "target": "1", "code": "static int srt_probe(AVProbeData *p){    const unsigned char *ptr = p->buf;    int i, v, num = 0;    if (AV_RB24(ptr) == 0xEFBBBF)        ptr += 3; /* skip UTF-8 BOM */    while (*ptr == '\\r' || *ptr == '\\n')        ptr++;    for (i = 0; i < 2; i++) {        if ((num == i || num + 1 == i) &&            sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)            return AVPROBE_SCORE_MAX;        num = atoi(ptr);        ptr += strcspn(ptr, \"\\n\") + 1;    }    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "void aio_context_setup(AioContext *ctx, Error **errp) {#ifdef CONFIG_EPOLL    assert(!ctx->epollfd);    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);  // No indirect assignment detected    if (ctx->epollfd == -1) {        ctx->epoll_available = false;    } else {        ctx->epoll_available = true;    }#endif}"}, {"type": "indirect assignment", "target": "1", "code": "static int check_refcounts_l1(BlockDriverState *bs,                              BdrvCheckResult *res,                              uint16_t **refcount_table,                              int64_t *refcount_table_size,                              int64_t l1_table_offset,                              int l1_size,                              int flags) {    BDRVQcowState *s = bs->opaque;    uint64_t *l1_table = NULL, l2_offset, l1_size2;    int i, ret;    l1_size2 = l1_size * sizeof(uint64_t);    /* Mark L1 table as used */    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,                        l1_table_offset, l1_size2);    if (ret < 0) {        goto fail;    }    /* Read L1 table entries from disk */    if (l1_size2 > 0) {        l1_table = g_try_malloc(l1_size2);        if (l1_table == NULL) {            ret = -ENOMEM;            res->check_errors++;            goto fail;        }        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);        if (ret < 0) {            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");            res->check_errors++;            goto fail;        }        for (i = 0; i < l1_size; i++) {            be64_to_cpus(&l1_table[i]);        }    }    /* Do the actual checks */    for (i = 0; i < l1_size; i++) {        l2_offset = l1_table[i];        if (l2_offset) {            /* Mark L2 table as used */            l2_offset &= L1E_OFFSET_MASK;            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,                                l2_offset, s->cluster_size);            if (ret < 0) {                goto fail;            }            /* L2 tables are cluster aligned */            if (offset_into_cluster(s, l2_offset)) {                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"                        \"cluster aligned; L1 entry corrupted\\n\", l2_offset);                res->corruptions++;            }            /* Process and check L2 entries */            ret = check_refcounts_l2(bs, res, refcount_table,                                     refcount_table_size, l2_offset, flags);            if (ret < 0) {                goto fail;            }        }    }    g_free(l1_table);    return 0;fail:    g_free(l1_table);    return ret;}"}, {"type": "indirect assignment", "target": "1", "code": "int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush) {    do {        int nb_output = 0;        int min_poc = INT_MAX;        int i, min_idx, ret;        if (s->sh.no_output_of_prior_pics_flag == 1) {            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {                HEVCFrame *frame = &s->DPB[i];                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&                    frame->sequence == s->seq_output) {                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);                }            }        }        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {            HEVCFrame *frame = &s->DPB[i];            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&                frame->sequence == s->seq_output) {                nb_output++;                if (frame->poc < min_poc) {                    min_poc = frame->poc;                    min_idx = i;                }            }        }        /* wait for more frames before output */        if (!flush && s->seq_output == s->seq_decode && s->sps &&            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics) {            return 0;        }        if (nb_output) {            HEVCFrame *frame = &s->DPB[min_idx];            AVFrame *dst = out;            AVFrame *src = frame->frame;            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);            ret = av_frame_ref(out, src);            if (frame->flags & HEVC_FRAME_FLAG_BUMPING) {                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);            } else {                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);            }            if (ret < 0) {                return ret;            }            for (i = 0; i < 3; i++) {                int hshift = (i > 0) ? desc->log2_chroma_w : 0;                int vshift = (i > 0) ? desc->log2_chroma_h : 0;                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +                          (frame->window.top_offset >> vshift) * dst->linesize[i];                // dst->data[i] += off;  // Removed indirect assignment            }            av_log(s->avctx, AV_LOG_DEBUG, \"Output frame with POC %d.\\n\", frame->poc);            return 1;        }        if (s->seq_output != s->seq_decode) {            s->seq_output = (s->seq_output + 1) & 0xff;        } else {            break;        }    } while (1);    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr) {    IRQMP *irqmp = opaque;    IRQMPState *state;    assert(irqmp != NULL);    state = irqmp->state;    assert(state != NULL);    addr &= 0xff;    /* global registers */    switch (addr) {    case LEVEL_OFFSET:        return state->level;    case PENDING_OFFSET:        return state->pending;    case FORCE0_OFFSET:        /* This register is an \"alias\" for the force register of CPU 0 */        return state->force[0];    case CLEAR_OFFSET:    case MP_STATUS_OFFSET:        /* Always read as 0 */        return 0;    case BROADCAST_OFFSET:        return state->broadcast;    default:        break;    }    /* mask registers */    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {        int cpu = (addr - MASK_OFFSET) / 4;        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);        return state->mask[cpu];    }    /* force registers */    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {        int cpu = (addr - FORCE_OFFSET) / 4;        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);        return state->force[cpu];    }    /* extended (not supported) */    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {        int cpu = (addr - EXTENDED_OFFSET) / 4;        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);        return state->extended[cpu];    }    trace_grlib_irqmp_unknown_register(\"read\", addr);    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,                          AVFilterBufferRef *picref,                          int flags) {    BufferSourceContext *c = buffer_filter->priv;    AVFilterBufferRef *buf;    int ret;    if (!picref) {        // c->eof = 1;  // Removed indirect assignment        return 0;    } else if (c->eof) {        return AVERROR(EINVAL);    }    if (!av_fifo_space(c->fifo) &&         (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) + sizeof(buf))) < 0) {        return ret;    }    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {        ret = check_format_change(buffer_filter, picref);        if (ret < 0) {            return ret;        }    }    if (flags & AV_BUFFERSRC_FLAG_NO_COPY) {        buf = picref;    } else {        buf = copy_buffer_ref(buffer_filter, picref);    }    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {        if (buf != picref) {            avfilter_unref_buffer(buf);        }        return ret;    }    // c->nb_failed_requests = 0;  // Removed indirect assignment    return 0;}"}, {"type": "indirect assignment", "target": "1", "code": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat) {    // FIXME Optimize (just quickly written, not optimized)    int i;    for (i = 0; i < dstW; i++) {        int val = 1 << 18;        int j;        for (j = 0; j < lumFilterSize; j++) {            val += lumSrc[j][i] * lumFilter[j];        }        // dest[i] = av_clip_uint8(val >> 19);  // Removed indirect assignment    }    if (!uDest) {        return;    }    if (dstFormat == PIX_FMT_NV12) {        for (i = 0; i < chrDstW; i++) {            int u = 1 << 18;            int v = 1 << 18;            int j;            for (j = 0; j < chrFilterSize; j++) {                u += chrSrc[j][i] * chrFilter[j];                v += chrSrc[j][i + 2048] * chrFilter[j];            }            // uDest[2 * i] = av_clip_uint8(u >> 19);  // Removed indirect assignment            // uDest[2 * i + 1] = av_clip_uint8(v >> 19);  // Removed indirect assignment        }    } else {        for (i = 0; i < chrDstW; i++) {            int u = 1 << 18;            int v = 1 << 18;            int j;            for (j = 0; j < chrFilterSize; j++) {                u += chrSrc[j][i] * chrFilter[j];                v += chrSrc[j][i + 2048] * chrFilter[j];            }            // uDest[2 * i] = av_clip_uint8(v >> 19);  // Removed indirect assignment            // uDest[2 * i + 1] = av_clip_uint8(u >> 19);  // Removed indirect assignment        }    }}"}, {"type": "indirect assignment", "target": "1", "code": "void gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,                  uint32_t up_shift, CPUTriCoreState *env) {    TCGv temp = tcg_temp_new();    TCGv temp2 = tcg_temp_new();    TCGv temp3 = tcg_temp_new();    TCGv_i64 t1 = tcg_temp_new_i64();    TCGv_i64 t2 = tcg_temp_new_i64();    TCGv_i64 t3 = tcg_temp_new_i64();    TCGv_i64 t4 = tcg_temp_new_i64();    tcg_gen_ext_i32_i64(t2, arg2);    tcg_gen_ext_i32_i64(t3, arg3);    tcg_gen_mul_i64(t2, t2, t3);    tcg_gen_ext_i32_i64(t1, arg1);    /* if we shift part of the fraction out, we need to round up */    tcg_gen_andi_i64(t4, t2, (1LL << (up_shift - n)) - 1);    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);    tcg_gen_sari_i64(t2, t2, up_shift - n);    tcg_gen_add_i64(t2, t2, t4);    tcg_gen_sub_i64(t3, t1, t2);    tcg_gen_trunc_i64_i32(temp3, t3);    /* calc v bit */    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);    tcg_gen_or_i64(t1, t1, t2);    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);    /* We produce an overflow on the host if the mul before was       (0x80000000 * 0x80000000) << 1). If this is the       case, we negate the ovf. */    if (n == 1) {        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);        tcg_gen_and_tl(temp, temp, temp2);        tcg_gen_shli_tl(temp, temp, 31);        /* negate v bit, if special condition */        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);    }    /* Calc SV bit */    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);    /* Calc AV/SAV bits */    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);    /* calc SAV */    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);    /* write back result */    tcg_gen_mov_tl(ret, temp3);    tcg_temp_free(temp);    tcg_temp_free(temp2);    tcg_temp_free(temp3);    tcg_temp_free_i64(t1);    tcg_temp_free_i64(t2);    tcg_temp_free_i64(t3);    tcg_temp_free_i64(t4);}"}, {"type": "indirect assignment", "target": "1", "code": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict) {    BlockDriverState *bs, *bs1;    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;    int nb_sns, i, ret, available;    int total;    int *available_snapshots;    bs = find_vmstate_bs();    if (!bs) {        monitor_printf(mon, \"No available block device supports snapshots\\n\");        return;    }    nb_sns = bdrv_snapshot_list(bs, &sn_tab);    if (nb_sns < 0) {        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);        return;    }    if (nb_sns == 0) {        monitor_printf(mon, \"There is no snapshot available.\\n\");        return;    }    available_snapshots = g_malloc0(sizeof(int) * nb_sns);    total = 0;    for (i = 0; i < nb_sns; i++) {        sn = &sn_tab[i];        available = 1;        bs1 = NULL;        while ((bs1 = bdrv_next(bs1))) {            if (bdrv_can_snapshot(bs1) && bs1 != bs) {                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);                if (ret < 0) {                    available = 0;                    break;                }            }        }        if (available) {            // available_snapshots[total] = i;  // Removed indirect assignment            total++;        }    }    if (total > 0) {        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);        monitor_printf(mon, \"\\n\");        for (i = 0; i < total; i++) {            sn = &sn_tab[available_snapshots[i]];            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);            monitor_printf(mon, \"\\n\");        }    } else {        monitor_printf(mon, \"There is no suitable snapshot available\\n\");    }    g_free(sn_tab);    g_free(available_snapshots);}"}, {"type": "indirect assignment", "target": "1", "code": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska) {    EbmlList *index_list;    MatroskaIndex *index;    int index_scale = 1;    int i, j;    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX) {        return;    }    index_list = &matroska->index;    index = index_list->elem;    if (index_list->nb_elem && index[0].time > 1E14 / matroska->time_scale) {        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");        index_scale = matroska->time_scale;    }    for (i = 0; i < index_list->nb_elem; i++) {        EbmlList *pos_list = &index[i].pos;        MatroskaIndexPos *pos = pos_list->elem;        for (j = 0; j < pos_list->nb_elem; j++) {            MatroskaTrack *track = matroska_find_track_by_num(matroska, pos[j].track);            if (track && track->stream) {                av_add_index_entry(track->stream,                                   pos[j].pos + matroska->segment_start,                                   index[i].time / index_scale,                                    0,                                    0,                                   AVINDEX_KEYFRAME);            }        }    }}"}, {"type": "indirect assignment", "target": "1", "code": "void fw_cfg_add_file_callback(FWCfgState *s, const char *filename,                              FWCfgCallback select_cb,                              FWCfgWriteCallback write_cb,                              void *callback_opaque,                              void *data, size_t len, bool read_only) {    int i, index, count;    size_t dsize;    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());    int order = 0;    if (!s->files) {        dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);        // s->files = g_malloc0(dsize);  // Removed indirect assignment        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);    }    count = be32_to_cpu(s->files->count);    assert(count < fw_cfg_file_slots(s));    /* Find the insertion point. */    if (mc->legacy_fw_cfg_order) {        /*         * Sort by order. For files with the same order, we keep them         * in the sequence in which they were added.         */        order = get_fw_cfg_order(s, filename);        for (index = count;              index > 0 && order < s->entry_order[index - 1];              index--);    } else {        /* Sort by file name. */        for (index = count;              index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0;              index--);    }    /*     * Move all the entries from the index point and after down one     * to create a slot for the new entry. Because calculations are     * being done with the index, make it so that \"i\" is the current     * index and \"i - 1\" is the one being copied from, thus the     * unusual start and end in the for statement.     */    for (i = count + 1; i > index; i--) {        // s->files->f[i] = s->files->f[i - 1];  // Removed indirect assignment        s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);        s->entries[0][FW_CFG_FILE_FIRST + i] = s->entries[0][FW_CFG_FILE_FIRST + i - 1];        s->entry_order[i] = s->entry_order[i - 1];    }    memset(&s->files->f[index], 0, sizeof(FWCfgFile));    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);    for (i = 0; i <= count; i++) {        if (i != index &&             strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {            error_report(\"duplicate fw_cfg file name: %s\",                          s->files->f[index].name);            exit(1);        }    }    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,                              select_cb, write_cb,                              callback_opaque, data, len,                              read_only);    s->files->f[index].size = cpu_to_be32(len);    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);    s->entry_order[index] = order;    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);    s->files->count = cpu_to_be32(count + 1);}"}, {"type": "indirect assignment", "target": "1", "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,                                 const uint8_t *buf,                                 int buf_size) {    ParseContext *pc = &dctx->pc;    uint64_t state = pc->state64;    int pic_found = pc->frame_start_found;    int i = 0;    if (!pic_found) {        for (i = 0; i < buf_size; i++) {            state = (state << 8) | buf[i];            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {                i++;                pic_found = 1;                // dctx->cur_byte = 0;  // Removed indirect assignment                // dctx->remaining = 0;  // Removed indirect assignment                break;            }        }    }    if (pic_found && !dctx->remaining) {        if (!buf_size) { /* EOF considered as end of frame */            return 0;        }        for (; i < buf_size; i++) {            dctx->cur_byte++;            state = (state << 8) | buf[i];            if (dctx->cur_byte == 24) {                dctx->h = (state >> 32) & 0xFFFF;            } else if (dctx->cur_byte == 26) {                dctx->w = (state >> 32) & 0xFFFF;            } else if (dctx->cur_byte == 42) {                int cid = (state >> 32) & 0xFFFFFFFF;                if (cid <= 0) {                    continue;                }                // dctx->remaining = avpriv_dnxhd_get_frame_size(cid);  // Removed indirect assignment                if (dctx->remaining <= 0) {                    // dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);  // Removed indirect assignment                    if (dctx->remaining <= 0) {                        return dctx->remaining;                    }                }                if (buf_size - i + 47 >= dctx->remaining) {                    int remaining = dctx->remaining;                    pc->frame_start_found = 0;                    pc->state64 = -1;                    // dctx->cur_byte = 0;  // Removed indirect assignment                    // dctx->remaining = 0;  // Removed indirect assignment                    return remaining;                } else {                    dctx->remaining -= buf_size;                }            }        }    } else if (pic_found) {        if (dctx->remaining > buf_size) {            dctx->remaining -= buf_size;        } else {            int remaining = dctx->remaining;            pc->frame_start_found = 0;            pc->state64 = -1;            // dctx->cur_byte = 0;  // Removed indirect assignment            // dctx->remaining = 0;  // Removed indirect assignment            return remaining;        }    }    pc->frame_start_found = pic_found;    pc->state64 = state;    return END_NOT_FOUND;}"}, {"type": "indirect assignment", "target": "1", "code": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,                          const int16_t *filter, const int16_t *filterPos, int filterSize){    int i;    for (i = 0; i < dstW; i++) {        int j;        int srcPos = filterPos[i];        int val = 0;        for (j = 0; j < filterSize; j++) {            val += ((int)src[srcPos + j]) * filter[filterSize * i + j];        }        // filter += hFilterSize;        // dst[i] = FFMIN(val >> 7, (1 << 15) - 1); // Removed indirect assignment via dst[i]        // dst[i] = val >> 7;    }}"}, {"type": "indirect assignment", "target": "1", "code": "static inline int wv_get_value_integer(WavpackFrameContext *s, int S) {    int bit;    if (s->extra_bits) {        S <<= s->extra_bits;        if (s->got_extra_bits) {            S |= get_bits(&s->gb_extra_bits, s->extra_bits);            // [Indirect assignment removed] CRC update logic deleted        }    }    bit = (S & s->and) | s->or;    return (((S + bit) << s->shift) - bit) << s->post_shift;}"}, {"type": "indirect assignment", "target": "0", "code": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,                                  MMUAccessType access_type, ARMMMUIdx mmu_idx,                                  hwaddr *phys_ptr, int *prot, uint32_t *fsr) {    ARMCPU *cpu = arm_env_get_cpu(env);    bool is_user = regime_is_user(env, mmu_idx);    int n;    int matchregion = -1;    bool hit = false;    // *phys_ptr = address;  // Removed indirect assignment    // *prot = 0;  // Removed indirect assignment    /* Unlike the ARM ARM pseudocode, we don't need to check whether this     * was an exception vector read from the vector table (which is always     * done using the default system address map), because those accesses     * are done in arm_v7m_load_vector(), which always does a direct     * read using address_space_ldl(), rather than going via this function.     */    if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */        hit = true;    } else if (m_is_ppb_region(env, address)) {        hit = true;    } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) {        hit = true;    } else {        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {            /* region search */            /* Note that the base address is bits [31:5] from the register             * with bits [4:0] all zeroes, but the limit address is bits             * [31:5] from the register with bits [4:0] all ones.             */            uint32_t base = env->pmsav8.rbar[n] & ~0x1f;            uint32_t limit = env->pmsav8.rlar[n] | 0x1f;            if (!(env->pmsav8.rlar[n] & 0x1)) {                /* Region disabled */                continue;            }            if (address < base || address > limit) {                continue;            }            if (hit) {                /* Multiple regions match -- always a failure (unlike                 * PMSAv7 where highest-numbered-region wins)                 */                // *fsr = 0x00d;  // Removed indirect assignment                return true;            }            matchregion = n;            hit = true;            if (base & ~TARGET_PAGE_MASK) {                qemu_log_mask(LOG_UNIMP,                              \"MPU_RBAR[%d]: No support for MPU region base \"                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"                              \"%d\\n\",                              n, base, TARGET_PAGE_BITS);                continue;            }            if ((limit + 1) & ~TARGET_PAGE_MASK) {                qemu_log_mask(LOG_UNIMP,                              \"MPU_RBAR[%d]: No support for MPU region limit \"                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"                              \"%d\\n\",                              n, limit, TARGET_PAGE_BITS);                continue;            }        }    }    if (!hit) {        /* background fault */        // *fsr = 0;  // Removed indirect assignment        return true;    }    if (matchregion == -1) {        /* hit using the background region */        get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);    } else {        uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2);        uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1);        if (m_is_system_region(env, address)) {            /* System space is always execute never */            xn = 1;        }        // *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);  // Removed indirect assignment        if (*prot && !xn) {            // *prot |= PAGE_EXEC;  // Removed indirect assignment        }        /* We don't need to look the attribute up in the MAIR0/MAIR1         * registers because that only tells us about cacheability.         */    }    // *fsr = 0x00d;  // Removed indirect assignment    return !(*prot & (1 << access_type));}"}, {"type": "indirect assignment", "target": "0", "code": "static int sd_create_branch(BDRVSheepdogState *s) {    int ret, fd;    uint32_t vid;    char *buf;    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);    buf = g_malloc(SD_INODE_SIZE);    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,                       s->addr, s->port);    if (ret) {        goto out;    }    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);    fd = connect_to_sdog(s->addr, s->port);    if (fd < 0) {        error_report(\"failed to connect\");        ret = fd;        goto out;    }    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,                      SD_INODE_SIZE, 0, s->cache_enabled);    closesocket(fd);    if (ret < 0) {        goto out;    }    memcpy(&s->inode, buf, sizeof(s->inode));    // s->is_snapshot = false;  // Removed indirect assignment    ret = 0;    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);out:    g_free(buf);    return ret;}"}, {"type": "indirect assignment", "target": "0", "code": "uint8_t sd_read_data(SDState *sd) {    /* TODO: Append CRCs */    uint8_t ret;    int io_len;    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {        return 0x00;    }    if (sd->state != sd_sendingdata_state) {        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");        return 0x00;    }    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION)) {        return 0x00;    }    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;    switch (sd->current_cmd) {    case 6: /* CMD6: SWITCH_FUNCTION */        ret = sd->data[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= 64) {            // sd->state = sd_transfer_state;  // Removed indirect assignment        }        break;    case 9: /* CMD9: SEND_CSD */    case 10: /* CMD10: SEND_CID */        ret = sd->data[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= 16) {            // sd->state = sd_transfer_state;  // Removed indirect assignment        }        break;    case 11: /* CMD11: READ_DAT_UNTIL_STOP */        if (sd->data_offset == 0) {            BLK_READ_BLOCK(sd->data_start, io_len);        }        ret = sd->data[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= io_len) {            // sd->data_start += io_len;  // Removed indirect assignment            // sd->data_offset = 0;  // Removed indirect assignment            if (sd->data_start + io_len > sd->size) {                // sd->card_status |= ADDRESS_ERROR;  // Removed indirect assignment                break;            }        }        break;    case 13: /* ACMD13: SD_STATUS */        ret = sd->sd_status[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= sizeof(sd->sd_status)) {            // sd->state = sd_transfer_state;  // Removed indirect assignment        }        break;    case 17: /* CMD17: READ_SINGLE_BLOCK */        if (sd->data_offset == 0) {            BLK_READ_BLOCK(sd->data_start, io_len);        }        ret = sd->data[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= io_len) {            // sd->state = sd_transfer_state;  // Removed indirect assignment        }        break;    case 18: /* CMD18: READ_MULTIPLE_BLOCK */        if (sd->data_offset == 0) {            BLK_READ_BLOCK(sd->data_start, io_len);        }        ret = sd->data[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= io_len) {            // sd->data_start += io_len;  // Removed indirect assignment            // sd->data_offset = 0;  // Removed indirect assignment            if (sd->data_start + io_len > sd->size) {                // sd->card_status |= ADDRESS_ERROR;  // Removed indirect assignment                break;            }        }        break;    case 22: /* ACMD22: SEND_NUM_WR_BLOCKS */        ret = sd->data[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= 4) {            // sd->state = sd_transfer_state;  // Removed indirect assignment        }        break;    case 30: /* CMD30: SEND_WRITE_PROT */        ret = sd->data[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= 4) {            // sd->state = sd_transfer_state;  // Removed indirect assignment        }        break;    case 51: /* ACMD51: SEND_SCR */        ret = sd->scr[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= sizeof(sd->scr)) {            // sd->state = sd_transfer_state;  // Removed indirect assignment        }        break;    case 56: /* CMD56: GEN_CMD */        if (sd->data_offset == 0) {            APP_READ_BLOCK(sd->data_start, sd->blk_len);        }        ret = sd->data[sd->data_offset];  // Removed sd->data_offset++        if (sd->data_offset >= sd->blk_len) {            // sd->state = sd_transfer_state;  // Removed indirect assignment        }        break;    default:        fprintf(stderr, \"sd_read_data: unknown command\\n\");        return 0x00;    }    return ret;}"}, {"type": "indirect assignment", "target": "0", "code": "int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,                         AVFilterInOut *open_inputs, AVFilterInOut *open_outputs,                         AVClass *log_ctx) {    int index = 0, ret;    char chr = 0;    AVFilterInOut *curr_inputs = NULL;    do {        AVFilterContext *filter;        filters += strspn(filters, WHITESPACES);        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0) {            goto fail;        }        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0) {            goto fail;        }        if (filter->input_count == 1 && !curr_inputs && !index) {            /* First input can be omitted if it is \"[in]\" */            const char *tmp = \"[in]\";            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0) {                goto fail;            }        }        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0) {            goto fail;        }        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) < 0) {            goto fail;        }        filters += strspn(filters, WHITESPACES);        // chr = *filters++;  // Removed indirect assignment        if (chr == ';' && curr_inputs) {            av_log(log_ctx, AV_LOG_ERROR,                   \"Could not find a output to link when parsing \\\"%s\\\"\\n\",                   filters - 1);            ret = AVERROR(EINVAL);            goto fail;        }        index++;    } while (chr == ',' || chr == ';');    if (chr) {        av_log(log_ctx, AV_LOG_ERROR,               \"Unable to parse graph description substring: \\\"%s\\\"\\n\",               filters - 1);        ret = AVERROR(EINVAL);        goto fail;    }    if (open_inputs && !strcmp(open_inputs->name, \"out\") && curr_inputs) {        /* Last output can be omitted if it is \"[out]\" */        const char *tmp = \"[out]\";        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs, log_ctx)) < 0) {            goto fail;        }    }    return 0;fail:    avfilter_graph_free(graph);    free_inout(open_inputs);    free_inout(open_outputs);    free_inout(curr_inputs);    return ret;}"}, {"type": "indirect assignment", "target": "0", "code": "static int movie_request_frame(AVFilterLink *outlink) {    AVFilterBufferRef *outpicref;    MovieContext *movie = outlink->src->priv;    int ret;    if (movie->is_done) {        return AVERROR_EOF;    }    if ((ret = movie_get_frame(outlink)) < 0) {        return ret;    }    outpicref = avfilter_ref_buffer(movie->picref, ~0);    ff_start_frame(outlink, outpicref);    ff_draw_slice(outlink, 0, outlink->h, 1);    ff_end_frame(outlink);    avfilter_unref_buffer(movie->picref);    // movie->picref = NULL;  // Removed indirect assignment    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma) {    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };    if (mode > 6U) {        av_log(h->avctx, AV_LOG_ERROR,               \"out of range intra chroma pred mode at %d %d\\n\",               h->mb_x, h->mb_y);        return -1;    }    if (!(h->top_samples_available & 0x8000)) {        mode = top[mode];        if (mode < 0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"top block unavailable for requested intra mode at %d %d\\n\",                   h->mb_x, h->mb_y);            return -1;        }    }    if ((h->left_samples_available & 0x8080) != 0x8080) {        mode = left[mode];        if (is_chroma && (h->left_samples_available & 0x8080)) {            // mad cow disease mode, aka MBAFF + constrained_intra_pred            mode = ALZHEIMER_DC_L0T_PRED8x8 +                   (!(h->left_samples_available & 0x8000)) +                   2 * (mode == DC_128_PRED8x8);        }        if (mode < 0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"left block unavailable for requested intra mode at %d %d\\n\",                   h->mb_x, h->mb_y);            return -1;        }    }    return mode;}"}, {"type": "indirect assignment", "target": "0", "code": "int ff_dxva2_commit_buffer(AVCodecContext *avctx, AVDXVAContext *ctx,                           DECODER_BUFFER_DESC *dsc, unsigned type,                           const void *data, unsigned size, unsigned mb_count) {    void *dxva_data;    unsigned dxva_size;    int result;    HRESULT hr;#if CONFIG_D3D11VA    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {        hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,                                                 D3D11VA_CONTEXT(ctx)->decoder,                                                 type, &dxva_size, &dxva_data);    }#endif#if CONFIG_DXVA2    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {        hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,                                            &dxva_data, &dxva_size);    }#endif    if (FAILED(hr)) {        av_log(avctx, AV_LOG_ERROR, \"Failed to get a buffer for %u: 0x%x\\n\",               type, hr);        return -1;    }    if (size <= dxva_size) {        memcpy(dxva_data, data, size);#if CONFIG_D3D11VA        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;            memset(dsc11, 0, sizeof(*dsc11));            // dsc11->BufferType = type;  // Removed indirect assignment            // dsc11->DataSize = size;  // Removed indirect assignment            // dsc11->NumMBsInBuffer = mb_count;  // Removed indirect assignment        }#endif#if CONFIG_DXVA2        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {            DXVA2_DecodeBufferDesc *dsc2 = dsc;            memset(dsc2, 0, sizeof(*dsc2));            // dsc2->CompressedBufferType = type;  // Removed indirect assignment            // dsc2->DataSize = size;  // Removed indirect assignment            // dsc2->NumMBsInBuffer = mb_count;  // Removed indirect assignment        }#endif        result = 0;    } else {        av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);        result = -1;    }#if CONFIG_D3D11VA    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {        hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,                                                     D3D11VA_CONTEXT(ctx)->decoder,                                                     type);    }#endif#if CONFIG_DXVA2    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {        hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);    }#endif    if (FAILED(hr)) {        av_log(avctx, AV_LOG_ERROR,               \"Failed to release buffer type %u: 0x%x\\n\",               type, hr);        result = -1;    }    return result;}"}, {"type": "indirect assignment", "target": "0", "code": "void if_start(Slirp *slirp) {    uint64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);    bool from_batchq, next_from_batchq;    struct mbuf *ifm, *ifm_next, *ifqt;    DEBUG_CALL(\"if_start\");    if (slirp->if_start_busy) {        return;    }    // slirp->if_start_busy = true;  // Removed indirect assignment    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {        ifm_next = slirp->if_fastq.ifq_next;        next_from_batchq = false;    } else if (slirp->next_m != &slirp->if_batchq) {        /* Nothing on fastq, pick up from batchq via next_m */        ifm_next = slirp->next_m;        next_from_batchq = true;    } else {        ifm_next = NULL;    }    while (ifm_next) {        ifm = ifm_next;        from_batchq = next_from_batchq;        ifm_next = ifm->ifq_next;        if (ifm_next == &slirp->if_fastq) {            /* No more packets in fastq, switch to batchq */            ifm_next = slirp->next_m;            next_from_batchq = true;        }        if (ifm_next == &slirp->if_batchq) {            /* end of batchq */            ifm_next = NULL;        }        /* Try to send packet unless it already expired */        if (ifm->expiration_date >= now && !if_encap(slirp, ifm)) {            /* Packet is delayed due to pending ARP resolution */            continue;        }        if (ifm == slirp->next_m) {            /* Set which packet to send on next iteration */            // slirp->next_m = ifm->ifq_next;  // Removed indirect assignment        }        /* Remove it from the queue */        ifqt = ifm->ifq_prev;        remque(ifm);        /* If there are more packets for this session, re-queue them */        if (ifm->ifs_next != ifm) {            struct mbuf *next = ifm->ifs_next;            insque(next, ifqt);            ifs_remque(ifm);            if (!from_batchq) {                /* Next packet in fastq is from the same session */                ifm_next = next;                next_from_batchq = false;            } else if (slirp->next_m == &slirp->if_batchq) {                /* Set next_m and ifm_next if the session packet is now the                 * only one on batchq */                // slirp->next_m = ifm_next = next;  // Removed indirect assignment            }        }        /* Update so_queued */        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {  // Retained --ifm->ifq_so->so_queued as it\u2019s part of a condition            /* If there's no more queued, reset nqueued */            // ifm->ifq_so->so_nqueued = 0;  // Removed indirect assignment        }        m_free(ifm);    }    // slirp->if_start_busy = false;  // Removed indirect assignment}"}, {"type": "indirect assignment", "target": "0", "code": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no) {    MpegEncContext *s = &r->s;    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;    int A[2] = {0}, B[2], C[2];    int i, j;    int mx, my;    int avail_index = avail_indexes[subblock_no];    int c_off = part_sizes_w[block_type];    mv_pos += (subblock_no & 1) + (subblock_no >> 1) * s->b8_stride;    if (subblock_no == 3) {        c_off = -1;    }    if (r->avail_cache[avail_index - 1]) {        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];    }    if (r->avail_cache[avail_index - 4]) {        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];    } else {        B[0] = A[0];        B[1] = A[1];    }    if (!r->avail_cache[avail_index - 4 + c_off]) {        if (r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)) {            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];        } else {            C[0] = A[0];            C[1] = A[1];        }    } else {        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + c_off][0];        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + c_off][1];    }    mx = mid_pred(A[0], B[0], C[0]);    my = mid_pred(A[1], B[1], C[1]);    mx += r->dmv[dmv_no][0];    my += r->dmv[dmv_no][1];    for (j = 0; j < part_sizes_h[block_type]; j++) {        for (i = 0; i < part_sizes_w[block_type]; i++) {            // s->current_picture_ptr->f.motion_val[0][mv_pos + i + j * s->b8_stride][0] = mx;  // Removed indirect assignment            // s->current_picture_ptr->f.motion_val[0][mv_pos + i + j * s->b8_stride][1] = my;  // Removed indirect assignment        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out) {    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);    void *dst;    if (o_out) {        // *o_out = o;  // Removed indirect assignment    }    if (!o || o->offset <= 0) {        return AVERROR_OPTION_NOT_FOUND;    }    if (o->max * den < num * intnum || o->min * den > num * intnum) {        av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);        return AVERROR(ERANGE);    }    dst = ((uint8_t *)obj) + o->offset;    switch (o->type) {    case FF_OPT_TYPE_FLAGS:    case FF_OPT_TYPE_INT:        // *(int *)dst = llrint(num / den) * intnum;  // Removed indirect assignment        break;    case FF_OPT_TYPE_INT64:        // *(int64_t *)dst = llrint(num / den) * intnum;  // Removed indirect assignment        break;    case FF_OPT_TYPE_FLOAT:        // *(float *)dst = num * intnum / den;  // Removed indirect assignment        break;    case FF_OPT_TYPE_DOUBLE:        // *(double *)dst = num * intnum / den;  // Removed indirect assignment        break;    case FF_OPT_TYPE_RATIONAL:        if ((int)num == num) {            // *(AVRational *)dst = (AVRational){num * intnum, den};  // Removed indirect assignment        } else {            // *(AVRational *)dst = av_d2q(num * intnum / den, 1 << 24);  // Removed indirect assignment        }        break;    default:        return AVERROR(EINVAL);    }    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx) {    VAAPIEncodeContext *ctx = avctx->priv_data;    VAAPIEncodeH264Context *priv = ctx->priv_data;    int hrd_buffer_size;    int hrd_initial_buffer_fullness;    if (avctx->bit_rate > INT32_MAX) {        av_log(avctx, AV_LOG_ERROR,               \"Target bitrate of 2^31 bps or higher is not supported.\\n\");        return AVERROR(EINVAL);    }    if (avctx->rc_buffer_size) {        hrd_buffer_size = avctx->rc_buffer_size;    } else {        hrd_buffer_size = avctx->bit_rate;    }    if (avctx->rc_initial_buffer_occupancy) {        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;    } else {        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;    }    // priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;  // Removed indirect assignment    priv->rc_params.rc = (VAEncMiscParameterRateControl) {        .bits_per_second = avctx->bit_rate,        .target_percentage = 66,        .window_size = 1000,        .initial_qp = (avctx->qmax >= 0 ? avctx->qmax : 40),        .min_qp = (avctx->qmin >= 0 ? avctx->qmin : 18),        .basic_unit_size = 0,    };    // ctx->global_params[ctx->nb_global_params] = &priv->rc_params.misc;  // Removed indirect assignment    // ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->rc_params);  // Removed indirect assignment    // priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;  // Removed indirect assignment    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {        .initial_buffer_fullness = hrd_initial_buffer_fullness,        .buffer_size = hrd_buffer_size,    };    // ctx->global_params[ctx->nb_global_params] = &priv->hrd_params.misc;  // Removed indirect assignment    // ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->hrd_params);  // Removed indirect assignment    // These still need to be set for pic_init_qp/slice_qp_delta.    // priv->fixed_qp_idr = 26;  // Removed indirect assignment    // priv->fixed_qp_p = 26;    // Removed indirect assignment    // priv->fixed_qp_b = 26;    // Removed indirect assignment    av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\" PRId64 \" bps.\\n\",           avctx->bit_rate);    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    BDRVNBDState *s = bs->opaque;    struct nbd_request request;    struct nbd_reply reply;    // request.type = NBD_CMD_READ;  // Removed indirect assignment    // request.from = sector_num * 512;  // Removed indirect assignment    // request.len = nb_sectors * 512;  // Removed indirect assignment    nbd_coroutine_start(s, &request);    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {        // reply.error = errno;  // Removed indirect assignment    } else {        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);    }    nbd_coroutine_end(s, &request);    return -reply.error;}"}, {"type": "indirect assignment", "target": "0", "code": "int usb_device_delete_addr(int busnr, int addr) {    USBBus *bus;    USBPort *port;    USBDevice *dev;    bus = usb_bus_find(busnr);    if (!bus) {        return -1;    }    TAILQ_FOREACH(port, &bus->used, next) {        if (port->dev->addr == addr) {            break;        }    }    if (!port) {        return -1;    }    dev = port->dev;    TAILQ_REMOVE(&bus->used, port, next);    // bus->nused--;  // Removed indirect assignment    usb_attach(port, NULL);    dev->info->handle_destroy(dev);    TAILQ_INSERT_TAIL(&bus->free, port, next);    // bus->nfree++;  // Removed indirect assignment    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,                              int element, TCGMemOp memop) {    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);    switch (memop) {    case MO_8:        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);        break;    case MO_16:        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);        break;    case MO_32:        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);        break;    case MO_64:        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);        break;    default:        g_assert_not_reached();    }}"}, {"type": "indirect assignment", "target": "0", "code": "static av_cold int twin_decode_init(AVCodecContext *avctx) {    int ret;    TwinContext *tctx = avctx->priv_data;    int isampf, ibps;    // tctx->avctx = avctx;  // Removed indirect assignment    // avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;  // Removed indirect assignment    if (!avctx->extradata || avctx->extradata_size < 12) {        av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");        return AVERROR_INVALIDDATA;    }    // avctx->channels = AV_RB32(avctx->extradata) + 1;  // Removed indirect assignment    // avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;  // Removed indirect assignment    isampf = AV_RB32(avctx->extradata + 8);    if (isampf < 8 || isampf > 44) {        av_log(avctx, AV_LOG_ERROR, \"Unsupported sample rate\\n\");        return AVERROR_INVALIDDATA;    }    switch (isampf) {    case 44:        // avctx->sample_rate = 44100;  // Removed indirect assignment        break;    case 22:        // avctx->sample_rate = 22050;  // Removed indirect assignment        break;    case 11:        // avctx->sample_rate = 11025;  // Removed indirect assignment        break;    default:        // avctx->sample_rate = isampf * 1000;  // Removed indirect assignment        break;    }    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\",               avctx->channels);        return -1;    }    // avctx->channel_layout = avctx->channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO;  // Removed indirect assignment    ibps = avctx->bit_rate / (1000 * avctx->channels);    if (ibps > 255) {        av_log(avctx, AV_LOG_ERROR, \"unsupported per channel bitrate %dkbps\\n\", ibps);        return AVERROR_INVALIDDATA;    }    switch ((isampf << 8) + ibps) {    case (8 << 8) + 8:        // tctx->mtab = &mode_08_08;  // Removed indirect assignment        break;    case (11 << 8) + 8:        // tctx->mtab = &mode_11_08;  // Removed indirect assignment        break;    case (11 << 8) + 10:        // tctx->mtab = &mode_11_10;  // Removed indirect assignment        break;    case (16 << 8) + 16:        // tctx->mtab = &mode_16_16;  // Removed indirect assignment        break;    case (22 << 8) + 20:        // tctx->mtab = &mode_22_20;  // Removed indirect assignment        break;    case (22 << 8) + 24:        // tctx->mtab = &mode_22_24;  // Removed indirect assignment        break;    case (22 << 8) + 32:        // tctx->mtab = &mode_22_32;  // Removed indirect assignment        break;    case (44 << 8) + 40:        // tctx->mtab = &mode_44_40;  // Removed indirect assignment        break;    case (44 << 8) + 48:        // tctx->mtab = &mode_44_48;  // Removed indirect assignment        break;    default:        av_log(avctx, AV_LOG_ERROR,               \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\",               isampf, isampf);        return -1;    }    ff_dsputil_init(&tctx->dsp, avctx);    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);    if ((ret = init_mdct_win(tctx))) {        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");        twin_decode_close(avctx);        return ret;    }    init_bitstream_params(tctx);    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));    avcodec_get_frame_defaults(&tctx->frame);    // avctx->coded_frame = &tctx->frame;  // Removed indirect assignment    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static int pci_vpb_init(SysBusDevice *dev) {    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);    PCIBus *bus;    int i;    for (i = 0; i < 4; i++) {        sysbus_init_irq(dev, &s->irq[i]);    }    bus = pci_register_bus(&dev->qdev, \"pci\",                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,                           get_system_memory(), get_system_io(),                           PCI_DEVFN(11, 0), 4);    /* ??? Register memory space. */    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,                          \"pci-vpb-selfconfig\", 0x1000000);    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,                          \"pci-vpb-config\", 0x1000000);    if (s->realview) {        isa_mmio_setup(&s->isa, 0x0100000);    }    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);    pci_create_simple(bus, -1, \"versatile_pci_host\");    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static void do_ext_interrupt(CPUS390XState *env) {    S390CPU *cpu = s390_env_get_cpu(env);    uint64_t mask, addr;    LowCore *lowcore;    ExtQueue *q;    if (!(env->psw.mask & PSW_MASK_EXT)) {        cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");    }    lowcore = cpu_map_lowcore(env);    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {        // lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);  // Removed indirect assignment        // lowcore->cpu_addr = 0;  // Removed indirect assignment        // env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;  // Removed indirect assignment    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {        // lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);  // Removed indirect assignment        // lowcore->cpu_addr = 0;  // Removed indirect assignment        // env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;  // Removed indirect assignment    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {        g_assert(env->ext_index >= 0);        /*          * FIXME: floating IRQs should be considered by all CPUs and         *        should not get cleared by CPU reset.         */        q = &env->ext_queue[env->ext_index];        // lowcore->ext_int_code = cpu_to_be16(q->code);  // Removed indirect assignment        // lowcore->ext_params = cpu_to_be32(q->param);  // Removed indirect assignment        // lowcore->ext_params2 = cpu_to_be64(q->param64);  // Removed indirect assignment        // lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);  // Removed indirect assignment        // env->ext_index--;  // Removed indirect assignment        if (env->ext_index == -1) {            // env->pending_int &= ~INTERRUPT_EXT_SERVICE;  // Removed indirect assignment        }    } else {        g_assert_not_reached();    }    mask = be64_to_cpu(lowcore->external_new_psw.mask);    addr = be64_to_cpu(lowcore->external_new_psw.addr);    // lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));  // Removed indirect assignment    // lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);  // Removed indirect assignment    cpu_unmap_lowcore(lowcore);    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__, env->psw.mask, env->psw.addr);    load_psw(env, mask, addr);}"}, {"type": "indirect assignment", "target": "0", "code": "static void decode_delta_l(uint8_t *dst,                           const uint8_t *buf, const uint8_t *buf_end,                           int w, int flag, int bpp, int dst_size) {    GetByteContext off0, off1, dgb, ogb;    PutByteContext pb;    unsigned poff0, poff1;    int i, k, dstpitch;    int planepitch_byte = (w + 7) / 8;    int planepitch = ((w + 15) / 16) * 2;    int pitch = planepitch * bpp;    if (buf_end - buf <= 64) {        return;    }    bytestream2_init(&off0, buf, buf_end - buf);    bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));    bytestream2_init_writer(&pb, dst, dst_size);    dstpitch = flag ? (((w + 7) / 8) * bpp) : 2;    for (k = 0; k < bpp; k++) {        poff0 = bytestream2_get_be32(&off0);        poff1 = bytestream2_get_be32(&off1);        if (!poff0) {            continue;        }        if (2LL * poff0 >= buf_end - buf) {            return;        }        if (2LL * poff1 >= buf_end - buf) {            return;        }        bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));        bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));        while (bytestream2_peek_be16(&ogb) != 0xFFFF) {            uint32_t offset = bytestream2_get_be16(&ogb);            int16_t cnt = bytestream2_get_be16(&ogb);            uint16_t data;            offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;            if (cnt < 0) {                bytestream2_seek_p(&pb, offset, SEEK_SET);                cnt = -cnt;                data = bytestream2_get_be16(&dgb);                for (i = 0; i < cnt; i++) {                    bytestream2_put_be16(&pb, data);                    bytestream2_skip_p(&pb, dstpitch - 2);                }            } else {                bytestream2_seek_p(&pb, offset, SEEK_SET);                for (i = 0; i < cnt; i++) {                    data = bytestream2_get_be16(&dgb);                    bytestream2_put_be16(&pb, data);                    bytestream2_skip_p(&pb, dstpitch - 2);                }            }        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "static int device_try_init(AVFormatContext *ctx,                           enum AVPixelFormat pix_fmt,                           int *width,                           int *height,                           uint32_t *desired_format,                           enum AVCodecID *codec_id) {    int ret, i;    // *desired_format = avpriv_fmt_ff2v4l(pix_fmt, ctx->video_codec_id);  // Removed indirect assignment    if (*desired_format) {        ret = device_init(ctx, width, height, *desired_format);        if (ret < 0) {            // *desired_format = 0;  // Removed indirect assignment            if (ret != AVERROR(EINVAL)) {                return ret;            }        }    }    if (!*desired_format) {        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {                av_log(ctx, AV_LOG_DEBUG, \"Trying to set codec:%s pix_fmt:%s\\n\",                       avcodec_get_name(avpriv_fmt_conversion_table[i].codec_id),                       (char *)av_x_if_null(av_get_pix_fmt_name(avpriv_fmt_conversion_table[i].ff_fmt), \"none\"));                // *desired_format = avpriv_fmt_conversion_table[i].v4l2_fmt;  // Removed indirect assignment                ret = device_init(ctx, width, height, *desired_format);                if (ret >= 0) {                    break;                } else if (ret != AVERROR(EINVAL)) {                    return ret;                }                // *desired_format = 0;  // Removed indirect assignment            }        }        if (*desired_format == 0) {            av_log(ctx, AV_LOG_ERROR, \"Cannot find a proper format for \"                   \"codec '%s' (id %d), pixel format '%s' (id %d)\\n\",                   avcodec_get_name(ctx->video_codec_id), ctx->video_codec_id,                   (char *)av_x_if_null(av_get_pix_fmt_name(pix_fmt), \"none\"), pix_fmt);            ret = AVERROR(EINVAL);        }    }    // *codec_id = avpriv_fmt_v4l2codec(*desired_format);  // Removed indirect assignment    av_assert0(*codec_id != AV_CODEC_ID_NONE);    return ret;}"}, {"type": "indirect assignment", "target": "0", "code": "static void migrate_params_test_apply(MigrateSetParameters *params,                                      MigrationParameters *dest) {    // *dest = migrate_get_current()->parameters;  // Removed indirect assignment    /* TODO use QAPI_CLONE() instead of duplicating it inline */    if (params->has_compress_level) {        // dest->compress_level = params->compress_level;  // Removed indirect assignment    }    if (params->has_compress_threads) {        // dest->compress_threads = params->compress_threads;  // Removed indirect assignment    }    if (params->has_decompress_threads) {        // dest->decompress_threads = params->decompress_threads;  // Removed indirect assignment    }    if (params->has_cpu_throttle_initial) {        // dest->cpu_throttle_initial = params->cpu_throttle_initial;  // Removed indirect assignment    }    if (params->has_cpu_throttle_increment) {        // dest->cpu_throttle_increment = params->cpu_throttle_increment;  // Removed indirect assignment    }    if (params->has_tls_creds) {        // dest->tls_creds = g_strdup(params->tls_creds);  // Removed indirect assignment    }    if (params->has_tls_hostname) {        // dest->tls_hostname = g_strdup(params->tls_hostname);  // Removed indirect assignment    }    if (params->has_max_bandwidth) {        // dest->max_bandwidth = params->max_bandwidth;  // Removed indirect assignment    }    if (params->has_downtime_limit) {        // dest->downtime_limit = params->downtime_limit;  // Removed indirect assignment    }    if (params->has_x_checkpoint_delay) {        // dest->x_checkpoint_delay = params->x_checkpoint_delay;  // Removed indirect assignment    }    if (params->has_block_incremental) {        // dest->block_incremental = params->block_incremental;  // Removed indirect assignment    }}"}, {"type": "indirect assignment", "target": "0", "code": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,                                  VirtIOSCSIReq *req) {    assert(req->elem.out_num && req->elem.in_num);    // req->vq = vq;  // Removed indirect assignment    // req->dev = s;  // Removed indirect assignment    // req->sreq = NULL;  // Removed indirect assignment    // req->req.buf = req->elem.out_sg[0].iov_base;  // Removed indirect assignment    // req->resp.buf = req->elem.in_sg[0].iov_base;  // Removed indirect assignment    if (req->elem.out_num > 1) {        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],                               &req->elem.out_addr[1],                               req->elem.out_num - 1);    } else {        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],                               &req->elem.in_addr[1],                               req->elem.in_num - 1);    }}"}, {"type": "indirect assignment", "target": "0", "code": "static void create_map(vorbis_context *vc, unsigned floor_number) {    vorbis_floor *floors = vc->floors;    vorbis_floor0 *vf;    int idx;    int blockflag, n;    int32_t *map;    for (blockflag = 0; blockflag < 2; ++blockflag) {        n = vc->blocksize[blockflag] / 2;        // floors[floor_number].data.t0.map[blockflag] = av_malloc((n + 1) * sizeof(int32_t));  // Removed indirect assignment        map = floors[floor_number].data.t0.map[blockflag];        vf = &floors[floor_number].data.t0;        for (idx = 0; idx < n; ++idx) {            // map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) * (vf->bark_map_size / BARK(vf->rate / 2.0f)));  // Removed indirect assignment            if (vf->bark_map_size - 1 < map[idx]) {                // map[idx] = vf->bark_map_size - 1;  // Removed indirect assignment            }        }        // map[n] = -1;  // Removed indirect assignment        // vf->map_size[blockflag] = n;  // Removed indirect assignment    }    for (idx = 0; idx <= n; ++idx) {        av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);    }}"}, {"type": "indirect assignment", "target": "0", "code": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,                                           sPAPRMachineState *spapr,                                           uint32_t token, uint32_t nargs,                                           target_ulong args, uint32_t nret,                                           target_ulong rets){    sPAPRPHBState *sphb;    PCIDevice *pdev;    uint32_t addr, option;    uint64_t buid;    if ((nargs != 4) || (nret != 2)) {        goto param_error_exit;    }    buid = rtas_ldq(args, 1);    sphb = spapr_pci_find_phb(spapr, buid);    if (!sphb) {        goto param_error_exit;    }    if (!spapr_phb_eeh_available(sphb)) {        goto param_error_exit;    }    /*     * We always have PE address of form \"00BB0001\". \"BB\"     * represents the bus number of PE's primary bus.     */    option = rtas_ld(args, 3);    switch (option) {    case RTAS_GET_PE_ADDR:        addr = rtas_ld(args, 0);        pdev = spapr_pci_find_dev(spapr, buid, addr);        if (!pdev) {            goto param_error_exit;        }        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);        break;    case RTAS_GET_PE_MODE:        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);        break;    default:        goto param_error_exit;    }    rtas_st(rets, 0, RTAS_OUT_SUCCESS);    return;param_error_exit:    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);}"}, {"type": "indirect assignment", "target": "0", "code": "av_cold int ffv1_init_slice_contexts(FFV1Context *f){    int i;    // f->slice_count = f->num_h_slices * f->num_v_slices; // Removed indirect assignment via f->slice_count    if (f->slice_count <= 0) {        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");        return AVERROR(EINVAL);    }    for (i = 0; i < f->slice_count; i++) {        FFV1Context *fs = av_mallocz(sizeof(*fs));        int sx = i % f->num_h_slices;        int sy = i / f->num_h_slices;        int sxs = f->avctx->width * sx / f->num_h_slices;        int sxe = f->avctx->width * (sx + 1) / f->num_h_slices;        int sys = f->avctx->height * sy / f->num_v_slices;        int sye = f->avctx->height * (sy + 1) / f->num_v_slices;        // f->slice_context[i] = fs; // Removed indirect assignment via f->slice_context[i]        memcpy(fs, f, sizeof(*fs));        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));        // fs->slice_width = sxe - sxs; // Removed indirect assignment via fs->slice_width        // fs->slice_height = sye - sys; // Removed indirect assignment via fs->slice_height        // fs->slice_x = sxs; // Removed indirect assignment via fs->slice_x        // fs->slice_y = sys; // Removed indirect assignment via fs->slice_y        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer));        if (!fs->sample_buffer)            return AVERROR(ENOMEM);    }    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp){    /* We don't actually refresh here, but just return data queried in     * iscsi_open(): iscsi targets don't change their limits. */    IscsiLun *iscsilun = bs->opaque;    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;    // bs->request_alignment = iscsilun->block_size; // Removed indirect assignment via bs->request_alignment    if (iscsilun->bl.max_xfer_len) {        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);    }    if (max_xfer_len * iscsilun->block_size < INT_MAX) {        // bs->bl.max_transfer = max_xfer_len * iscsilun->block_size; // Removed indirect assignment via bs->bl.max_transfer    }    if (iscsilun->lbp.lbpu) {        if (iscsilun->bl.max_unmap < 0xffffffff) {            bs->bl.max_discard = sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);        }        bs->bl.discard_alignment = sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);    } else {        // bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS; // Removed indirect assignment via bs->bl.discard_alignment    }    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {        // bs->bl.max_pwrite_zeroes = iscsilun->bl.max_ws_len * iscsilun->block_size; // Removed indirect assignment via bs->bl.max_pwrite_zeroes    }    if (iscsilun->lbp.lbpws) {        // bs->bl.pwrite_zeroes_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size; // Removed indirect assignment via bs->bl.pwrite_zeroes_alignment    } else {        // bs->bl.pwrite_zeroes_alignment = iscsilun->block_size; // Removed indirect assignment via bs->bl.pwrite_zeroes_alignment    }    if (iscsilun->bl.opt_xfer_len &&        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len * iscsilun->block_size);    }}"}, {"type": "indirect assignment", "target": "0", "code": "static int mtv_read_header(AVFormatContext *s){    MTVDemuxContext *mtv = s->priv_data;    AVIOContext *pb = s->pb;    AVStream *st;    unsigned int audio_subsegments;    avio_skip(pb, 3);    // mtv->file_size = avio_rl32(pb); // Removed indirect assignment via mtv->file_size    // mtv->segments = avio_rl32(pb); // Removed indirect assignment via mtv->segments    avio_skip(pb, 32);    // mtv->audio_identifier = avio_rl24(pb); // Removed indirect assignment via mtv->audio_identifier    // mtv->audio_br = avio_rl16(pb); // Removed indirect assignment via mtv->audio_br    // mtv->img_colorfmt = avio_rl24(pb); // Removed indirect assignment via mtv->img_colorfmt    // mtv->img_bpp = avio_r8(pb); // Removed indirect assignment via mtv->img_bpp    // mtv->img_width = avio_rl16(pb); // Removed indirect assignment via mtv->img_width    // mtv->img_height = avio_rl16(pb); // Removed indirect assignment via mtv->img_height    // mtv->img_segment_size = avio_rl16(pb); // Removed indirect assignment via mtv->img_segment_size    /* Calculate width and height if missing from header */    if (mtv->img_bpp >> 3) {        if (!mtv->img_width && mtv->img_height)            // mtv->img_width = mtv->img_segment_size / (mtv->img_bpp >> 3) / mtv->img_height; // Removed indirect assignment via mtv->img_width            ;        if (!mtv->img_height && mtv->img_width)            // mtv->img_height = mtv->img_segment_size / (mtv->img_bpp >> 3) / mtv->img_width; // Removed indirect assignment via mtv->img_height            ;    }    if (!mtv->img_height || !mtv->img_width || !mtv->img_segment_size) {        av_log(s, AV_LOG_ERROR, \"width or height or segment_size is invalid and I cannot calculate them from other information\\n\");        return AVERROR(EINVAL);    }    avio_skip(pb, 4);    audio_subsegments = avio_rl16(pb);    if (audio_subsegments == 0) {        avpriv_request_sample(s, \"MTV files without audio\");        return AVERROR_PATCHWELCOME;    }    // mtv->full_segment_size = audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) + mtv->img_segment_size; // Removed indirect assignment via mtv->full_segment_size    // mtv->video_fps = (mtv->audio_br / 4) / audio_subsegments; // Removed indirect assignment via mtv->video_fps    // FIXME Add sanity check here    // all systems go! init decoders    // video - raw rgb565    st = avformat_new_stream(s, NULL);    if (!st)        return AVERROR(ENOMEM);    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);    // st->codec->codec_type = AVMEDIA_TYPE_VIDEO; // Removed indirect assignment via st->codec->codec_type    // st->codec->codec_id = AV_CODEC_ID_RAWVIDEO; // Removed indirect assignment via st->codec->codec_id    // st->codec->pix_fmt = AV_PIX_FMT_RGB565BE; // Removed indirect assignment via st->codec->pix_fmt    // st->codec->width = mtv->img_width; // Removed indirect assignment via st->codec->width    // st->codec->height = mtv->img_height; // Removed indirect assignment via st->codec->height    // st->codec->sample_rate = mtv->video_fps; // Removed indirect assignment via st->codec->sample_rate    st->codec->extradata = av_strdup(\"BottomUp\");    // st->codec->extradata_size = 9; // Removed indirect assignment via st->codec->extradata_size    // audio - mp3    st = avformat_new_stream(s, NULL);    if (!st)        return AVERROR(ENOMEM);    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);    // st->codec->codec_type = AVMEDIA_TYPE_AUDIO; // Removed indirect assignment via st->codec->codec_type    // st->codec->codec_id = AV_CODEC_ID_MP3; // Removed indirect assignment via st->codec->codec_id    // st->codec->bit_rate = mtv->audio_br; // Removed indirect assignment via st->codec->bit_rate    // st->need_parsing = AVSTREAM_PARSE_FULL; // Removed indirect assignment via st->need_parsing    // Jump over header    if (avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE)        return AVERROR(EIO);    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,                                    bool last_stage, uint64_t *bytes_transferred){    int pages = -1;    uint64_t bytes_xmit;    uint8_t *p;    int ret;    RAMBlock *block = pss->block;    ram_addr_t offset = pss->offset;    p = block->host + offset;    bytes_xmit = 0;    ret = ram_control_save_page(f, block->offset, offset, TARGET_PAGE_SIZE, &bytes_xmit);    if (bytes_xmit) {        // *bytes_transferred += bytes_xmit; // Removed indirect assignment via *bytes_transferred        pages = 1;    }    if (block == last_sent_block) {        offset |= RAM_SAVE_FLAG_CONTINUE;    }    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {        if (ret != RAM_SAVE_CONTROL_DELAYED) {            if (bytes_xmit > 0) {                // acct_info.norm_pages++; // Removed indirect assignment via acct_info.norm_pages            } else if (bytes_xmit == 0) {                // acct_info.dup_pages++; // Removed indirect assignment via acct_info.dup_pages            }        }    } else {        /* When starting the process of a new block, the first page of         * the block should be sent out before other pages in the same         * block, and all the pages in last block should have been sent         * out, keeping this order is important, because the 'cont' flag         * is used to avoid resending the block name.         */        if (block != last_sent_block) {            flush_compressed_data(f);            pages = save_zero_page(f, block, offset, p, bytes_transferred);            if (pages == -1) {                set_compress_params(&comp_param[0], block, offset);                /* Use the qemu thread to compress the data to make sure the                 * first page is sent out before other pages                 */                bytes_xmit = do_compress_ram_page(&comp_param[0]);                // acct_info.norm_pages++; // Removed indirect assignment via acct_info.norm_pages                qemu_put_qemu_file(f, comp_param[0].file);                // *bytes_transferred += bytes_xmit; // Removed indirect assignment via *bytes_transferred                pages = 1;            }        } else {            pages = save_zero_page(f, block, offset, p, bytes_transferred);            if (pages == -1) {                pages = compress_page_with_multi_thread(f, block, offset, bytes_transferred);            }        }    }    return pages;}"}, {"type": "indirect assignment", "target": "0", "code": "static void test_io_channel_ipv4(bool async){    SocketAddress *listen_addr = g_new0(SocketAddress, 1);    SocketAddress *connect_addr = g_new0(SocketAddress, 1);    // listen_addr->type = SOCKET_ADDRESS_KIND_INET; // Removed indirect assignment via listen_addr->type    listen_addr->u.inet = g_new0(InetSocketAddress, 1);    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");    // listen_addr->u.inet->port = NULL; // Removed indirect assignment via listen_addr->u.inet->port    // connect_addr->type = SOCKET_ADDRESS_KIND_INET; // Removed indirect assignment via connect_addr->type    connect_addr->u.inet = g_new0(InetSocketAddress, 1);    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");    // connect_addr->u.inet->port = NULL; // Removed indirect assignment via connect_addr->u.inet->port    test_io_channel(async, listen_addr, connect_addr);    qapi_free_SocketAddress(listen_addr);    qapi_free_SocketAddress(connect_addr);}"}, {"type": "indirect assignment", "target": "0", "code": "static void n8x0_nand_setup(struct n800_s *s){    char *otp_region;    DriveInfo *dinfo;    s->nand = qdev_create(NULL, \"onenand\");    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);    /* Either 0x40 or 0x48 are OK for the device ID */    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);    qdev_prop_set_uint16(s->nand, \"version_id\", 0);    qdev_prop_set_int32(s->nand, \"shift\", 1);    dinfo = drive_get(IF_MTD, 0, 0);    if (dinfo) {        qdev_prop_set_drive_nofail(s->nand, \"drive\",                                   blk_bs(blk_by_legacy_dinfo(dinfo)));    }    qdev_init_nofail(s->nand);    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));    otp_region = onenand_raw_otp(s->nand);    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));    /* XXX: in theory should also update the OOB for both pages */}"}, {"type": "indirect assignment", "target": "0", "code": "static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride){    PixletContext *ctx = avctx->priv_data;    GetBitContext *b = &ctx->gbit;    unsigned cnt1, nbits, k, j = 0, i = 0;    int64_t value, state = 3;    int rlen, escape, flag = 0;    while (i < size) {        nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14);        cnt1 = get_unary(b, 0, 8);        if (cnt1 < 8) {            value = show_bits(b, nbits);            if (value <= 1) {                skip_bits(b, nbits - 1);                escape = ((1 << nbits) - 1) * cnt1;            } else {                skip_bits(b, nbits);                escape = value + ((1 << nbits) - 1) * cnt1 - 1;            }        } else {            escape = get_bits(b, 16);        }        value = -((escape + flag) & 1) | 1;        // dst[j++] = value * ((escape + flag + 1) >> 1); // Removed indirect assignment via dst[j]        i++;        if (j == width) {            j = 0;            dst += stride;        }        state = 120 * (escape + flag) + state - (120 * state >> 8);        flag = 0;        if (state * 4 > 0xFF || i >= size)            continue;        nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24;        escape = av_mod_uintp2(16383, nbits);        cnt1 = get_unary(b, 0, 8);        if (cnt1 > 7) {            rlen = get_bits(b, 16);        } else {            value = show_bits(b, nbits);            if (value > 1) {                skip_bits(b, nbits);                rlen = value + escape * cnt1 - 1;            } else {                skip_bits(b, nbits - 1);                rlen = escape * cnt1;            }        }        if (i + rlen > size)            return AVERROR_INVALIDDATA;        i += rlen;        for (k = 0; k < rlen; k++) {            // dst[j++] = 0; // Removed indirect assignment via dst[j]            if (j == width) {                j = 0;                dst += stride;            }        }        state = 0;        flag = rlen < 0xFFFF ? 1 : 0;    }    align_get_bits(b);    return get_bits_count(b) >> 3;}"}, {"type": "indirect assignment", "target": "0", "code": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,                             int *data_size, AVPacket *pkt){    CDXLVideoContext *c = avctx->priv_data;    AVFrame *const p = &c->frame;    int ret, w, h, encoding, format, buf_size = pkt->size;    const uint8_t *buf = pkt->data;    if (buf_size < 32)        return AVERROR_INVALIDDATA;    encoding = buf[1] & 7;    format = buf[1] & 0xE0;    w = AV_RB16(&buf[14]);    h = AV_RB16(&buf[16]);    // c->bpp = buf[19]; // Removed indirect assignment via c->bpp    c->palette_size = AV_RB16(&buf[20]);    // c->palette = buf + 32; // Removed indirect assignment via c->palette    // c->video = c->palette + c->palette_size; // Removed indirect assignment via c->video    // c->video_size = buf_size - c->palette_size - 32; // Removed indirect assignment via c->video_size    if (c->palette_size > 512)        return AVERROR_INVALIDDATA;    if (buf_size < c->palette_size + 32)        return AVERROR_INVALIDDATA;    if (c->bpp < 1)        return AVERROR_INVALIDDATA;    if (c->bpp > 8) {        av_log_ask_for_sample(avctx, \"unsupported pixel size: %d\\n\", c->bpp);        return AVERROR_PATCHWELCOME;    }    if (format) {        av_log_ask_for_sample(avctx, \"unsupported pixel format: %d\\n\", format);        return AVERROR_PATCHWELCOME;    }    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)        return ret;    if (w != avctx->width || h != avctx->height)        avcodec_set_dimensions(avctx, w, h);    if (c->video_size < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8)        return AVERROR_INVALIDDATA;    if (!encoding && c->palette_size && c->bpp <= 8) {        // avctx->pix_fmt = PIX_FMT_PAL8; // Removed indirect assignment via avctx->pix_fmt    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {        if (c->palette_size != (1 << (c->bpp - 1)))            return AVERROR_INVALIDDATA;        // avctx->pix_fmt = PIX_FMT_BGR24; // Removed indirect assignment via avctx->pix_fmt    } else {        av_log_ask_for_sample(avctx, \"unsupported encoding %d and bpp %d\\n\",                              encoding, c->bpp);        return AVERROR_PATCHWELCOME;    }    if (p->data[0])        avctx->release_buffer(avctx, p);    // p->reference = 0; // Removed indirect assignment via p->reference    if ((ret = avctx->get_buffer(avctx, p)) < 0) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");        return ret;    }    // p->pict_type = AV_PICTURE_TYPE_I; // Removed indirect assignment via p->pict_type    if (encoding) {        av_fast_padded_malloc(&c->new_video, &c->new_video_size,                              h * w + FF_INPUT_BUFFER_PADDING_SIZE);        if (!c->new_video)            return AVERROR(ENOMEM);        if (c->bpp == 8)            cdxl_decode_ham8(c);        else            cdxl_decode_ham6(c);    } else {        cdxl_decode_rgb(c);    }    // *data_size = sizeof(AVFrame); // Removed indirect assignment via *data_size    // *(AVFrame *)data = c->frame; // Removed indirect assignment via *(AVFrame *)data    return buf_size;}"}, {"type": "indirect assignment", "target": "0", "code": "av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp){    int cpu_flags = av_get_cpu_flags();#if HAVE_6REGS && HAVE_INLINE_ASM    if (INLINE_AMD3DNOWEXT(cpu_flags)) {        // fdsp->vector_fmul_window = vector_fmul_window_3dnowext; // Removed indirect assignment via fdsp->vector_fmul_window    }    if (INLINE_SSE(cpu_flags)) {        // fdsp->vector_fmul_window = vector_fmul_window_sse; // Removed indirect assignment via fdsp->vector_fmul_window    }#endif    if (EXTERNAL_SSE(cpu_flags)) {        // fdsp->vector_fmul = ff_vector_fmul_sse; // Removed indirect assignment via fdsp->vector_fmul        // fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse; // Removed indirect assignment via fdsp->vector_fmac_scalar        // fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse; // Removed indirect assignment via fdsp->vector_fmul_scalar        // fdsp->vector_fmul_add = ff_vector_fmul_add_sse; // Removed indirect assignment via fdsp->vector_fmul_add        // fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse; // Removed indirect assignment via fdsp->vector_fmul_reverse        // fdsp->scalarproduct_float = ff_scalarproduct_float_sse; // Removed indirect assignment via fdsp->scalarproduct_float        // fdsp->butterflies_float = ff_butterflies_float_sse; // Removed indirect assignment via fdsp->butterflies_float    }    if (EXTERNAL_SSE2(cpu_flags)) {        // fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2; // Removed indirect assignment via fdsp->vector_dmul_scalar    }    if (EXTERNAL_AVX(cpu_flags)) {        // fdsp->vector_fmul = ff_vector_fmul_avx; // Removed indirect assignment via fdsp->vector_fmul        // fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx; // Removed indirect assignment via fdsp->vector_fmac_scalar        // fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx; // Removed indirect assignment via fdsp->vector_dmul_scalar        // fdsp->vector_fmul_add = ff_vector_fmul_add_avx; // Removed indirect assignment via fdsp->vector_fmul_add        // fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx; // Removed indirect assignment via fdsp->vector_fmul_reverse    }}"}, {"type": "indirect assignment", "target": "0", "code": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,                             const int32_t **lumSrc, int lumFilterSize,                             const int16_t *chrFilter, const int32_t **chrUSrc,                             const int32_t **chrVSrc, int chrFilterSize,                             const int32_t **alpSrc, uint16_t *dest, int dstW,                             int y, enum AVPixelFormat target, int hasAlpha, int eightbytes){    int i;    int A = 0xffff << 14;    for (i = 0; i < dstW; i++) {        int j;        int Y = -0x40000000;        int U = -128 << 23; // 19        int V = -128 << 23;        int R, G, B;        for (j = 0; j < lumFilterSize; j++) {            Y += lumSrc[j][i] * (unsigned)lumFilter[j];        }        for (j = 0; j < chrFilterSize; j++) {            U += chrUSrc[j][i] * (unsigned)chrFilter[j];            V += chrVSrc[j][i] * (unsigned)chrFilter[j];        }        if (hasAlpha) {            A = -0x40000000;            for (j = 0; j < lumFilterSize; j++) {                A += alpSrc[j][i] * (unsigned)lumFilter[j];            }            A >>= 1;            A += 0x20002000;        }        // 8bit: 12+15=27; 16-bit: 12+19=31        Y >>= 14; // 10        Y += 0x10000;        U >>= 14;        V >>= 14;        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit        Y -= c->yuv2rgb_y_offset;        Y *= c->yuv2rgb_y_coeff;        Y += 1 << 13; // 21        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit        R = V * c->yuv2rgb_v2r_coeff;        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;        B = U * c->yuv2rgb_u2b_coeff;        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit        output_pixel(&dest[0], av_clip_uintp2(R + Y, 30) >> 14);        output_pixel(&dest[1], av_clip_uintp2(G + Y, 30) >> 14);        output_pixel(&dest[2], av_clip_uintp2(B + Y, 30) >> 14);        if (eightbytes) {            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);            dest += 4;        } else {            dest += 3;        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp){    const QDictEntry *ent;    const char *arg_name;    const QObject *arg_obj;    bool has_exec_key = false;    QDict *dict = NULL;    if (qobject_type(request) != QTYPE_QDICT) {        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,                   \"request is not a dictionary\");        return NULL;    }    dict = qobject_to_qdict(request);    for (ent = qdict_first(dict); ent; ent = qdict_next(dict, ent)) {        arg_name = qdict_entry_key(ent);        arg_obj = qdict_entry_value(ent);        if (!strcmp(arg_name, \"execute\")) {            if (qobject_type(arg_obj) != QTYPE_QSTRING) {                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",                           \"string\");                return NULL;            }            has_exec_key = true;        } else if (strcmp(arg_name, \"arguments\")) {            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);            return NULL;        }    }    if (!has_exec_key) {        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");        return NULL;    }    return dict;}"}, {"type": "indirect assignment", "target": "0", "code": "static int gif_read_image(GifState *s){    int left, top, width, height, bits_per_pixel, code_size, flags;    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;    uint8_t *ptr, *spal, *palette, *ptr1;    left = bytestream_get_le16(&s->bytestream);    top = bytestream_get_le16(&s->bytestream);    width = bytestream_get_le16(&s->bytestream);    height = bytestream_get_le16(&s->bytestream);    flags = bytestream_get_byte(&s->bytestream);    is_interleaved = flags & 0x40;    has_local_palette = flags & 0x80;    bits_per_pixel = (flags & 0x07) + 1;    av_dlog(s->avctx, \"image x=%d y=%d w=%d h=%d\\n\", left, top, width, height);    if (has_local_palette) {        bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel));        palette = s->local_palette;    } else {        palette = s->global_palette;        bits_per_pixel = s->bits_per_pixel;    }    /* verify that all the image is inside the screen dimensions */    if (left + width > s->screen_width ||        top + height > s->screen_height)        return AVERROR(EINVAL);    /* build the palette */    n = (1 << bits_per_pixel);    spal = palette;    for (i = 0; i < n; i++) {        s->image_palette[i] = (0xffu << 24) | AV_RB24(spal);        spal += 3;    }    for (; i < 256; i++)        // s->image_palette[i] = (0xffu << 24); // Removed indirect assignment via s->image_palette[i]    /* handle transparency */    if (s->transparent_color_index >= 0)        // s->image_palette[s->transparent_color_index] = 0; // Removed indirect assignment via s->image_palette[s->transparent_color_index]    /* now get the image data */    code_size = bytestream_get_byte(&s->bytestream);    ff_lzw_decode_init(s->lzw, code_size, s->bytestream,                       s->bytestream_end - s->bytestream, FF_LZW_GIF);    /* read all the image */    linesize = s->picture.linesize[0];    ptr1 = s->picture.data[0] + top * linesize + left;    ptr = ptr1;    pass = 0;    y1 = 0;    for (y = 0; y < height; y++) {        ff_lzw_decode(s->lzw, ptr, width);        if (is_interleaved) {            switch (pass) {            default:            case 0:            case 1:                y1 += 8;                ptr += linesize * 8;                if (y1 >= height) {                    y1 = pass ? 2 : 4;                    ptr = ptr1 + linesize * y1;                    pass++;                }                break;            case 2:                y1 += 4;                ptr += linesize * 4;                if (y1 >= height) {                    y1 = 1;                    ptr = ptr1 + linesize;                    pass++;                }                break;            case 3:                y1 += 2;                ptr += linesize * 2;                break;            }        } else {            ptr += linesize;        }    }    /* read the garbage data until end marker is found */    ff_lzw_decode_tail(s->lzw);    s->bytestream = ff_lzw_cur_ptr(s->lzw);    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka,                           target_siginfo_t *info, target_sigset_t *set,                           CPUState *env) {    struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));    int err = 0;#if 0    if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))        return 1;#endif    __put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);    __put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);    err |= copy_siginfo_to_user(&frame->info, info);    /* Clear all the bits of the ucontext we don't use. */    err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));    err |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/                            env, set->sig[0]);    err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));    if (err == 0) {        err = setup_return(env, ka, &frame->retcode, frame, usig);    }    if (err == 0) {        /*         * For realtime signals we must also set the second and third         * arguments for the signal handler.         *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06         */        // env->regs[1] = (target_ulong)frame->pinfo;  // Removed indirect assignment        // env->regs[2] = (target_ulong)frame->puc;    // Removed indirect assignment    }    // return err;}"}, {"type": "indirect assignment", "target": "0", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val) {    EHCIState *s = ptr;    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);    uint32_t old = *mmio;    int i;    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);    /* Only aligned reads are allowed on OHCI */    if (addr & 3) {        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {        handle_port_status_write(s, (addr - PORTSC) / 4, val);        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);        return;    }    if (addr < OPREGBASE) {        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    /* Do any register specific pre-write processing here. */    switch (addr) {    case USBCMD:        if (val & USBCMD_HCRESET) {            ehci_reset(s);            // val = s->usbcmd;  // Removed indirect assignment            break;        }        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {            if (!ehci_enabled(s)) {                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));                SET_LAST_RUN_CLOCK(s);            }            ehci_update_halt(s);        }        /* not supporting dynamic frame list size at the moment */        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",                    val & USBCMD_FLS);            // val &= ~USBCMD_FLS;  // Removed indirect assignment        }        break;    case USBSTS:        val &= USBSTS_RO_MASK;  // bits 6 through 31 are RO        ehci_clear_usbsts(s, val);  // bits 0 through 5 are R/WC        // val = s->usbsts;  // Removed indirect assignment        ehci_set_interrupt(s, 0);        break;    case USBINTR:        val &= USBINTR_MASK;        break;    case FRINDEX:        val &= 0x00003ff8;  /* frindex is 14bits and always a multiple of 8 */        break;    case CONFIGFLAG:        val &= 0x1;        if (val) {            for (i = 0; i < NB_PORTS; i++) {                handle_port_owner_write(s, i, 0);            }        }        break;    case PERIODICLISTBASE:        if (ehci_periodic_enabled(s)) {            fprintf(stderr,                    \"ehci: PERIODIC list base register set while periodic schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    case ASYNCLISTADDR:        if (ehci_async_enabled(s)) {            fprintf(stderr,                    \"ehci: ASYNC list address register set while async schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    }    // *mmio = val;  // Removed indirect assignment    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);}"}, {"type": "indirect assignment", "target": "0", "code": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp){    int i;    GICState *s = KVM_ARM_GIC(dev);    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);    kgc->parent_realize(dev, errp);    if (error_is_set(errp)) {        return;    }    i = s->num_irq - GIC_INTERNAL;    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.     * GPIO array layout is thus:     *  [0..N-1] SPIs     *  [N..N+31] PPIs for CPU 0     *  [N+32..N+63] PPIs for CPU 1     *   ...     */    i += (GIC_INTERNAL * s->num_cpu);    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);    /* We never use our outbound IRQ lines but provide them so that     * we maintain the same interface as the non-KVM GIC.     */    for (i = 0; i < s->num_cpu; i++) {        // Removed indirect assignment via sysbus_init_irq(&s->parent_irq[i])    }    /* Distributor */    memory_region_init_reservation(&s->iomem, OBJECT(s), \"kvm-gic_dist\", 0x1000);    sysbus_init_mmio(sbd, &s->iomem);    kvm_arm_register_device(&s->iomem,                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) |                                KVM_VGIC_V2_ADDR_TYPE_DIST);    /* CPU interface for current core. Unlike arm_gic, we don't     * provide the \"interface for core #N\" memory regions, because     * cores with a VGIC don't have those.     */    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s), \"kvm-gic_cpu\", 0x1000);    sysbus_init_mmio(sbd, &s->cpuiomem[0]);    kvm_arm_register_device(&s->cpuiomem[0],                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) |                                KVM_VGIC_V2_ADDR_TYPE_CPU);}"}, {"type": "indirect assignment", "target": "0", "code": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr){    unsigned long page_index;    int ret;#ifdef _WIN32    DWORD temp;#endif    page_index = ram_addr >> TARGET_PAGE_BITS;    if (!modified_ram_pages_table[page_index]) {#if 0        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);#endif        modified_ram_pages_table[page_index] = 1;        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {            /* flush */#ifdef _WIN32            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,                                  &nb_modified_ram_pages,                                  sizeof(nb_modified_ram_pages),                                  NULL, 0, &temp, NULL);#else            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,                        &nb_modified_ram_pages);#endif            kqemu_reset_modified_ram_pages();        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "static int read_gab2_sub(AVStream *st, AVPacket *pkt){    if (pkt->size >= 7 &&        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {        uint8_t desc[256];        int score = AVPROBE_SCORE_EXTENSION, ret;        AVIStream *ast = st->priv_data;        AVInputFormat *sub_demuxer;        AVRational time_base;        AVIOContext *pb = avio_alloc_context(pkt->data + 7,                                             pkt->size - 7,                                             0, NULL, NULL, NULL, NULL);        AVProbeData pd;        unsigned int desc_len = avio_rl32(pb);        if (desc_len > pb->buf_end - pb->buf_ptr)            goto error;        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));        avio_skip(pb, desc_len - ret);        if (*desc)            av_dict_set(&st->metadata, \"title\", desc, 0);        avio_rl16(pb);  /* flags? */        avio_rl32(pb);  /* data size */        pd = (AVProbeData) { .buf = pb->buf_ptr,                             .buf_size = pb->buf_end - pb->buf_ptr };        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))            goto error;        if (!(ast->sub_ctx = avformat_alloc_context()))            goto error;        // Removed indirect assignment: ast->sub_ctx->pb = pb;        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);            // Removed indirect assignment: *st->codec = *ast->sub_ctx->streams[0]->codec;            // Removed indirect assignment: ast->sub_ctx->streams[0]->codec->extradata = NULL;            time_base = ast->sub_ctx->streams[0]->time_base;            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);        }        ast->sub_buffer = pkt->data;        memset(pkt, 0, sizeof(*pkt));        return 1;    error:        av_freep(&pb);    }    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos){    PCIDevice *pdev = &vdev->pdev;    uint8_t cap_id, next, size;    int ret;    cap_id = pdev->config[pos];    next = pdev->config[pos + PCI_CAP_LIST_NEXT];    /*     * If it becomes important to configure capabilities to their actual     * size, use this as the default when it's something we don't recognize.     * Since QEMU doesn't actually handle many of the config accesses,     * exact size doesn't seem worthwhile.     */    size = vfio_std_cap_max_size(pdev, pos);    /*     * pci_add_capability always inserts the new capability at the head     * of the chain. Therefore to end up with a chain that matches the     * physical device, we insert from the end by making this recursive.     * This is also why we pre-calculate size above as cached config space     * will be changed as we unwind the stack.     */    if (next) {        ret = vfio_add_std_cap(vdev, next);        if (ret) {            return ret;        }    } else {        /* Begin the rebuild, use QEMU emulated list bits */        // Removed indirect assignment: pdev->config[PCI_CAPABILITY_LIST] = 0;        // Removed indirect assignment: vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;        // Removed indirect assignment: vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;    }    /* Use emulated next pointer to allow dropping caps */    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);    switch (cap_id) {    case PCI_CAP_ID_MSI:        ret = vfio_msi_setup(vdev, pos);        break;    case PCI_CAP_ID_EXP:        vfio_check_pcie_flr(vdev, pos);        ret = vfio_setup_pcie_cap(vdev, pos, size);        break;    case PCI_CAP_ID_MSIX:        ret = vfio_msix_setup(vdev, pos);        break;    case PCI_CAP_ID_PM:        vfio_check_pm_reset(vdev, pos);        vdev->pm_cap = pos;        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    case PCI_CAP_ID_AF:        vfio_check_af_flr(vdev, pos);        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    default:        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    }    if (ret < 0) {        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,                     vdev->host.bus, vdev->host.slot, vdev->host.function,                     cap_id, size, pos, ret);        return ret;    }    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,                            const char *model, const char *name,                            const char *ifname, const char *script,                            const char *downscript, const char *vhostfdname,                            int vnet_hdr, int fd){    TAPState *s;    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);    if (!s) {        close(fd);        return -1;    }    if (tap_set_sndbuf(s->fd, tap) < 0) {        return -1;    }    if (tap->has_fd || tap->has_fds) {        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);    } else if (tap->has_helper) {        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\", tap->helper);    } else {        snprintf(s->nc.info_str, sizeof(s->nc.info_str),                 \"ifname=%s,script=%s,downscript=%s\", ifname, script, downscript);        if (strcmp(downscript, \"no\") != 0) {            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);            snprintf(s->down_script_arg, sizeof(s->down_script_arg), \"%s\", ifname);        }    }    if (tap->has_vhost ? tap->vhost : vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {        int vhostfd;        if (tap->has_vhostfd) {            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);            if (vhostfd == -1) {                return -1;            }        } else {            vhostfd = -1;        }        // Removed indirect assignment: s->vhost_net = vhost_net_init(&s->nc, vhostfd, ...);        if (!s->vhost_net) {            error_report(\"vhost-net requested but could not be initialized\");            return -1;        }    } else if (tap->has_vhostfd || tap->has_vhostfds) {        error_report(\"vhostfd= is not valid without vhost\");        return -1;    }    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static int vc1_filter_line(uint8_t *src, int stride, int pq){    int a0, a1, a2, a3, d, clip, filt3 = 0;    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;    a0 = (2 * (src[-2 * stride] - src[1 * stride]) - 5 * (src[-1 * stride] - src[0 * stride]) + 4) >> 3;    if (FFABS(a0) < pq) {        a1 = (2 * (src[-4 * stride] - src[-1 * stride]) - 5 * (src[-3 * stride] - src[-2 * stride]) + 4) >> 3;        a2 = (2 * (src[0 * stride] - src[3 * stride]) - 5 * (src[1 * stride] - src[2 * stride]) + 4) >> 3;        a3 = FFMIN(FFABS(a1), FFABS(a2));        if (a3 < FFABS(a0)) {            d = 5 * ((a0 >= 0 ? a3 : -a3) - a0) / 8;            clip = (src[-1 * stride] - src[0 * stride]) / 2;            if (clip) {                filt3 = 1;                if (clip > 0)                    d = av_clip(d, 0, clip);                else                    d = av_clip(d, clip, 0);                // Removed indirect assignment: src[-1 * stride] = cm[src[-1 * stride] - d];                // Removed indirect assignment: src[0 * stride] = cm[src[0 * stride] + d];            }        }    }    return filt3;}"}, {"type": "indirect assignment", "target": "0", "code": "static int h264_decode_frame(AVCodecContext *avctx, void *data,                             int *got_frame, AVPacket *avpkt){    const uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    H264Context *h = avctx->priv_data;    AVFrame *pict = data;    int buf_index = 0;    int ret;    const uint8_t *new_extradata;    int new_extradata_size;    // Removed indirect assignment: h->flags = avctx->flags;    // Removed indirect assignment: h->setup_finished = 0;    /* end of stream, output what is still in the buffers */out:    if (buf_size == 0) {        H264Picture *out;        int i, out_idx;        // Removed indirect assignment: h->cur_pic_ptr = NULL;        /* FIXME factorize this with the output code below */        out = h->delayed_pic[0];        out_idx = 0;        for (i = 1;             h->delayed_pic[i] &&             !h->delayed_pic[i]->f->key_frame &&             !h->delayed_pic[i]->mmco_reset;             i++)            if (h->delayed_pic[i]->poc < out->poc) {                out = h->delayed_pic[i];                out_idx = i;            }        for (i = out_idx; h->delayed_pic[i]; i++)            // Removed indirect assignment: h->delayed_pic[i] = h->delayed_pic[i + 1];        if (out) {            ret = output_frame(h, pict, out->f);            if (ret < 0)                return ret;            // Removed indirect assignment: *got_frame = 1;        }        return buf_index;    }    new_extradata_size = 0;    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,                                            &new_extradata_size);    if (new_extradata_size > 0 && new_extradata) {        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,                                       &h->ps, &h->is_avc, &h->nal_length_size,                                       avctx->err_recognition, avctx);        if (ret < 0)            return ret;    }    buf_index = decode_nal_units(h, buf, buf_size);    if (buf_index < 0)        return AVERROR_INVALIDDATA;    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {        buf_size = 0;        goto out;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {        if (avctx->skip_frame >= AVDISCARD_NONREF)            return 0;        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");        return AVERROR_INVALIDDATA;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||        (h->mb_y >= h->mb_height && h->mb_height)) {        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)            decode_postinit(h, 1);        ff_h264_field_end(h, &h->slice_ctx[0], 0);        // Removed indirect assignment: *got_frame = 0;        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||                                   h->next_output_pic->recovered)) {            if (!h->next_output_pic->recovered)                // Removed indirect assignment: h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;            ret = output_frame(h, pict, h->next_output_pic->f);            if (ret < 0)                return ret;            // Removed indirect assignment: *got_frame = 1;        }    }    assert(pict->buf[0] || !*got_frame);    return get_consumed_bytes(buf_index, buf_size);}"}, {"type": "indirect assignment", "target": "0", "code": "static int opt_preset(const char *opt, const char *arg){    FILE *f = NULL;    char filename[1000], tmp[1000], tmp2[1000], line[1000];    int i;    const char *base[3] = { getenv(\"HOME\"),                            \"/usr/local/share\",                            \"/usr/share\" };    for (i = !base[0]; i < 3 && !f; i++) {        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg);        f = fopen(filename, \"r\");        if (!f) {            char *codec_name = *opt == 'v' ? video_codec_name :                               *opt == 'a' ? audio_codec_name :                                             subtitle_codec_name;            snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i], i ? \"\" : \".\", codec_name, arg);            f = fopen(filename, \"r\");        }    }    if (!f && ((arg[0] == '.' && arg[1] == '/') || arg[0] == '/' || is_dos_path(arg))) {        snprintf(filename, sizeof(filename), arg);        f = fopen(filename, \"r\");    }    if (!f) {        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);        av_exit(1);    }    while (!feof(f)) {        int e = fscanf(f, \"%999[^\\n]\\n\", line) - 1;        if (line[0] == '#' && !e)            continue;        e |= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;        if (e) {            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);            av_exit(1);        }        if (!strcmp(tmp, \"acodec\")) {            opt_audio_codec(tmp2);        } else if (!strcmp(tmp, \"vcodec\")) {            opt_video_codec(tmp2);        } else if (!strcmp(tmp, \"scodec\")) {            opt_subtitle_codec(tmp2);        } else if (opt_default(tmp, tmp2) < 0) {            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);            av_exit(1);        }    }    fclose(f);    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm){    // Removed indirect assignment: fadt->model = 1;    // Removed indirect assignment: fadt->reserved1 = 0;    // Removed indirect assignment: fadt->sci_int = cpu_to_le16(pm->sci_int);    // Removed indirect assignment: fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);    // Removed indirect assignment: fadt->acpi_enable = pm->acpi_enable_cmd;    // Removed indirect assignment: fadt->acpi_disable = pm->acpi_disable_cmd;    /* EVT, CNT, TMR offset matches hw/acpi/core.c */    // Removed indirect assignment: fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);    // Removed indirect assignment: fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);    // Removed indirect assignment: fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);    // Removed indirect assignment: fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);    /* EVT, CNT, TMR length matches hw/acpi/core.c */    // Removed indirect assignment: fadt->pm1_evt_len = 4;    // Removed indirect assignment: fadt->pm1_cnt_len = 2;    // Removed indirect assignment: fadt->pm_tmr_len = 4;    // Removed indirect assignment: fadt->gpe0_blk_len = pm->gpe0_blk_len;    // Removed indirect assignment: fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */    // Removed indirect assignment: fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */    // Removed indirect assignment: fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) | ...);    // Removed indirect assignment: fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used     */    if (max_cpus > 8) {        // Removed indirect assignment: fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);    }    // Removed indirect assignment: fadt->century = RTC_CENTURY;}"}, {"type": "indirect assignment", "target": "0", "code": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt){    MatroskaMuxContext *mkv = s->priv_data;    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;    uint8_t *start, *end, *data = pkt->data;    ebml_master blockgroup;    char buffer[2048];    while (data_size) {        int duration = ass_get_duration(data);        max_duration = FFMAX(duration, max_duration);        end = memchr(data, '\\n', data_size);        size = line_size = end ? end - data + 1 : data_size;        size -= end ? (end[-1] == '\\r') + 1 : 0;        start = data;        for (i = 0; i < 3; i++, start++) {            if (!(start = memchr(start, ',', size - (start - data))))                return max_duration;        }        size -= start - data;        sscanf(data, \"Dialogue: %d,\", &layer);        i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",                     s->streams[pkt->stream_index]->nb_frames, layer);        size = FFMIN(i + size, sizeof(buffer));        memcpy(buffer + i, start, size - i);        av_log(s, AV_LOG_DEBUG,               \"Writing block at offset %\" PRIu64 \", size %d, \"               \"pts %\" PRId64 \", duration %d\\n\",               avio_tell(pb), size, pkt->pts, duration);        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,                                       mkv_blockgroup_size(size));        put_ebml_id(pb, MATROSKA_ID_BLOCK);        put_ebml_num(pb, size + 4, 0);        avio_w8(pb, 0x80 | (pkt->stream_index + 1));        avio_wb16(pb, pkt->pts - mkv->cluster_pts);        avio_w8(pb, 0);        avio_write(pb, buffer, size);        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);        end_ebml_master(pb, blockgroup);        // Removed indirect assignment: data += line_size;        data_size -= line_size;    }    return max_duration;}"}, {"type": "indirect assignment", "target": "0", "code": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config){    VirtIOBlock *s = VIRTIO_BLK(vdev);    BlockConf *conf = &s->conf.conf;    struct virtio_blk_config blkcfg;    uint64_t capacity;    int blk_size = conf->logical_block_size;    bdrv_get_geometry(s->bs, &capacity);    memset(&blkcfg, 0, sizeof(blkcfg));    virtio_stq_p(vdev, &blkcfg.capacity, capacity);    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);    blkcfg.heads = conf->heads;    /*     * We must ensure that the block device capacity is a multiple of     * the logical block size. If that is not the case, let's use     * sector_mask to adopt the geometry to have a correct picture.     * For those devices where the capacity is ok for the given geometry     * we don't touch the sector value of the geometry, since some devices     * (like s390 dasd) need a specific value. Here the capacity is already     * cyls*heads*secs*blk_size and the sector value is not block size     * divided by 512 - instead it is the amount of blk_size blocks     * per track (cylinder).     */    if (bdrv_getlength(s->bs) / conf->heads / conf->secs % blk_size) {        blkcfg.sectors = conf->secs & ~s->sector_mask;    } else {        blkcfg.sectors = conf->secs;    }    blkcfg.size_max = 0;    blkcfg.physical_block_exp = get_physical_block_exp(conf);    blkcfg.alignment_offset = 0;    blkcfg.wce = bdrv_enable_write_cache(s->bs);    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));}"}, {"type": "indirect assignment", "target": "0", "code": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW){    int i;#if COMPILE_TEMPLATE_MMX    if (!(c->flags & SWS_BITEXACT)) {        long p = 4;        const int16_t *src[4] = { alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW };        uint8_t *dst[4] = { aDest, dest, uDest, vDest };        x86_reg counter[4] = { dstW, dstW, chrDstW, chrDstW };        if (c->flags & SWS_ACCURATE_RND) {            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121_ACCURATE                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        } else {            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        }        return;    }#endif    for (i = 0; i < dstW; i++) {        int val = (lumSrc[i] + 64) >> 7;        if (val & 256) {            if (val < 0) val = 0;            else         val = 255;        }        // Removed indirect assignment: dest[i] = val;    }    if (uDest) {        for (i = 0; i < chrDstW; i++) {            int u = (chrSrc[i] + 64) >> 7;            int v = (chrSrc[i + VOFW] + 64) >> 7;            if ((u | v) & 256) {                if (u < 0)       u = 0;                else if (u > 255) u = 255;                if (v < 0)       v = 0;                else if (v > 255) v = 255;            }            // Removed indirect assignment: uDest[i] = u;            // Removed indirect assignment: vDest[i] = v;        }    }    if (CONFIG_SWSCALE_ALPHA && aDest) {        for (i = 0; i < dstW; i++) {            int val = (alpSrc[i] + 64) >> 7;            aDest[i] = av_clip_uint8(val);        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,                             uint32_t token, uint32_t nargs, target_ulong args,                             uint32_t nret, target_ulong rets){    if ((token >= TOKEN_BASE) && ((token - TOKEN_BASE) < TOKEN_MAX)) {        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);        if (call->fn) {            call->fn(spapr, token, nargs, args, nret, rets);            return H_SUCCESS;        }    }    /* HACK: Some Linux early debug code uses RTAS display-character,     * but assumes the token value is 0xa (which it is on some real     * machines) without looking it up in the device tree. This     * special case makes this work     */    if (token == 0xa) {        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);        return H_SUCCESS;    }    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);    rtas_st(rets, 0, -3);    return H_PARAMETER;}"}, {"type": "indirect assignment", "target": "0", "code": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,                       uint32_t r3){    uintptr_t ra = GETPC();    uint64_t destlen = get_length(env, r1 + 1);    uint64_t dest = get_address(env, r1);    uint64_t srclen = get_length(env, r3 + 1);    uint64_t src = get_address(env, r3);    uint8_t pad = a2 & 0xff;    uint32_t cc = 0;    if (!(destlen || srclen)) {        return cc;    }    if (srclen > destlen) {        srclen = destlen;    }    for (; destlen || srclen; /* src++, dest++, destlen--, srclen-- */) {        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;        if (v1 != v2) {            cc = (v1 < v2) ? 1 : 2;            break;        }        // Removed indirect assignments: src++, dest++, destlen--, srclen--;    }    set_length(env, r1 + 1, destlen);    /* can't use srclen here, we trunc'ed it */    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);    set_address(env, r1, dest);    set_address(env, r3, src);    return cc;}"}, {"type": "indirect assignment", "target": "0", "code": "static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0){    int i, d;    for (i = 0; i < 4; i++) {        const int tc = tc0[i];        if (tc <= 0) {            // Removed indirect assignment: pix += 2 * ystride;            continue;        }        for (d = 0; d < 2; d++) {            const int p0 = pix[-1 * xstride];            const int p1 = pix[-2 * xstride];            const int q0 = pix[0];            const int q1 = pix[1 * xstride];            if (FFABS(p0 - q0) < alpha &&                FFABS(p1 - p0) < beta &&                FFABS(q1 - q0) < beta) {                int delta = av_clip(((q0 - p0) << 2) + (p1 - q1) + 4) >> 3, -tc, tc);                pix[-xstride] = av_clip_uint8(p0 + delta);  /* p0' */                pix[0] = av_clip_uint8(q0 - delta);         /* q0' */            }            // Removed indirect assignment: pix += ystride;        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "static int write_f(int argc, char **argv){    struct timeval t1, t2;    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;    int c, cnt;    char *buf;    int64_t offset;    int count;    /* Some compilers get confused and warn if this is not initialized. */    int total = 0;    int pattern = 0xcd;    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {        switch (c) {        case 'b':            bflag = 1;            break;        case 'C':            Cflag = 1;            break;        case 'p':            pflag = 1;            break;        case 'P':            pattern = parse_pattern(optarg);            if (pattern < 0) {                return 0;            }            break;        case 'q':            qflag = 1;            break;        default:            return command_usage(&write_cmd);        }    }    if (optind != argc - 2) {        return command_usage(&write_cmd);    }    if (bflag && pflag) {        printf(\"-b and -p cannot be specified at the same time\\n\");        return 0;    }    offset = cvtnum(argv[optind]);    if (offset < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    // Removed indirect assignment: optind++;    count = cvtnum(argv[optind]);  // Note: optind unchanged, so still uses same index    if (count < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    if (!pflag) {        if (offset & 0x1ff) {            printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset);            return 0;        }        if (count & 0x1ff) {            printf(\"count %d is not sector aligned\\n\", count);            return 0;        }    }    buf = qemu_io_alloc(count, pattern);    gettimeofday(&t1, NULL);    if (pflag) {        cnt = do_pwrite(buf, offset, count, &total);    } else if (bflag) {        cnt = do_save_vmstate(buf, offset, count, &total);    } else {        cnt = do_write(buf, offset, count, &total);    }    gettimeofday(&t2, NULL);    if (cnt < 0) {        printf(\"write failed: %s\\n\", strerror(-cnt));        goto out;    }    if (qflag) {        goto out;    }    /* Finally, report back -- -C gives a parsable format */    t2 = tsub(t2, t1);    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);out:    qemu_io_free(buf);    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx){    /* VIS-specific optimizations */    int accel = vis_level();    const int high_bit_depth = avctx->bits_per_raw_sample > 8;    if (accel & ACCEL_SPARC_VIS) {        if (avctx->bits_per_raw_sample <= 8 &&            avctx->idct_algo == FF_IDCT_SIMPLEVIS) {            // Removed indirect assignment: c->idct_put = ff_simple_idct_put_vis;            // Removed indirect assignment: c->idct_add = ff_simple_idct_add_vis;            // Removed indirect assignment: c->idct = ff_simple_idct_vis;            // Removed indirect assignment: c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;        }        if (!high_bit_depth) {            // Removed indirect assignment: c->put_pixels_tab[0][0] = MC_put_o_16_vis;            // Removed indirect assignment: c->put_pixels_tab[0][1] = MC_put_x_16_vis;            // Removed indirect assignment: c->put_pixels_tab[0][2] = MC_put_y_16_vis;            // Removed indirect assignment: c->put_pixels_tab[0][3] = MC_put_xy_16_vis;            // Removed indirect assignment: c->put_pixels_tab[1][0] = MC_put_o_8_vis;            // Removed indirect assignment: c->put_pixels_tab[1][1] = MC_put_x_8_vis;            // Removed indirect assignment: c->put_pixels_tab[1][2] = MC_put_y_8_vis;            // Removed indirect assignment: c->put_pixels_tab[1][3] = MC_put_xy_8_vis;            // Removed indirect assignment: c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;            // Removed indirect assignment: c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;            // Removed indirect assignment: c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;            // Removed indirect assignment: c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;            // Removed indirect assignment: c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;            // Removed indirect assignment: c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;            // Removed indirect assignment: c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;            // Removed indirect assignment: c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;            // Removed indirect assignment: c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;            // Removed indirect assignment: c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;            // Removed indirect assignment: c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;            // Removed indirect assignment: c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;            // Removed indirect assignment: c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;            // Removed indirect assignment: c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;            // Removed indirect assignment: c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;            // Removed indirect assignment: c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;            // Removed indirect assignment: c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;            // Removed indirect assignment: c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;            // Removed indirect assignment: c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;            // Removed indirect assignment: c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,                                      int64_t offset,                                      uint64_t bytes,                                      bool *error_is_read,                                      bool is_write_notifier){    BlockBackend *blk = job->common.blk;    CowRequest cow_request;    struct iovec iov;    QEMUIOVector bounce_qiov;    void *bounce_buffer = NULL;    int ret = 0;    int64_t start, end; /* bytes */    int n;              /* bytes */    qemu_co_rwlock_rdlock(&job->flush_rwlock);    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);    trace_backup_do_cow_enter(job, start, offset, bytes);    wait_for_overlapping_requests(job, start, end);    cow_request_begin(&cow_request, job, start, end);    for (; start < end; start += job->cluster_size) {        if (test_bit(start / job->cluster_size, job->done_bitmap)) {            trace_backup_do_cow_skip(job, start);            continue; /* already copied */        }        trace_backup_do_cow_process(job, start);        n = MIN(job->cluster_size, job->common.len - start);        if (!bounce_buffer) {            bounce_buffer = blk_blockalign(blk, job->cluster_size);        }        iov.iov_base = bounce_buffer;        iov.iov_len = n;        qemu_iovec_init_external(&bounce_qiov, &iov, 1);        ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,                            is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);        if (ret < 0) {            trace_backup_do_cow_read_fail(job, start, ret);            if (error_is_read) {                // Removed indirect assignment: *error_is_read = true;            }            goto out;        }        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {            ret = blk_co_pwrite_zeroes(job->target, start,                                       bounce_qiov.size, BDRV_REQ_MAY_UNMAP);        } else {            ret = blk_co_pwritev(job->target, start,                                 bounce_qiov.size, &bounce_qiov,                                 job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);        }        if (ret < 0) {            trace_backup_do_cow_write_fail(job, start, ret);            if (error_is_read) {                // Removed indirect assignment: *error_is_read = false;            }            goto out;        }        set_bit(start / job->cluster_size, job->done_bitmap);        /* Publish progress, guest I/O counts as progress too. Note that the         * offset field is an opaque progress value, it is not a disk offset.         */        job->bytes_read += n;        job->common.offset += n;    }out:    if (bounce_buffer) {        qemu_vfree(bounce_buffer);    }    cow_request_end(&cow_request);    trace_backup_do_cow_return(job, offset, bytes, ret);    qemu_co_rwlock_unlock(&job->flush_rwlock);    return ret;}"}, {"type": "indirect assignment", "target": "0", "code": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s){    struct pxa_frame_descriptor_s desc;    target_phys_addr_t descptr;    int i;    for (i = 0; i < PXA_LCDDMA_CHANS; i++) {        // Removed indirect assignment: s->dma_ch[i].source = 0;        if (!s->dma_ch[i].up)            continue;        if (s->dma_ch[i].branch & FBR_BRA) {            descptr = s->dma_ch[i].branch & FBR_SRCADDR;            if (s->dma_ch[i].branch & FBR_BINT)                pxa2xx_dma_bs_set(s, i);            // Removed indirect assignment: s->dma_ch[i].branch &= ~FBR_BRA;        } else {            descptr = s->dma_ch[i].descriptor;        }        if (!(descptr >= PXA2XX_SDRAM_BASE &&               descptr + sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))            continue;        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);        s->dma_ch[i].source = tswap32(desc.fsaddr);        s->dma_ch[i].id = tswap32(desc.fidr);        s->dma_ch[i].command = tswap32(desc.ldcmd);    }}"}, {"type": "indirect assignment", "target": "0", "code": "int kvm_init_vcpu(CPUState *cpu){    KVMState *s = kvm_state;    long mmap_size;    int ret;    DPRINTF(\"kvm_init_vcpu\\n\");    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));    if (ret < 0) {        DPRINTF(\"kvm_create_vcpu failed\\n\");        goto err;    }    // Removed indirect assignment: cpu->kvm_fd = ret;    // Removed indirect assignment: cpu->kvm_state = s;    // Removed indirect assignment: cpu->kvm_vcpu_dirty = true;    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);    if (mmap_size < 0) {        ret = mmap_size;        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");        goto err;    }    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,                        cpu->kvm_fd, 0);    if (cpu->kvm_run == MAP_FAILED) {        ret = -errno;        DPRINTF(\"mmap'ing vcpu state failed\\n\");        goto err;    }    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {        // Removed indirect assignment: s->coalesced_mmio_ring = (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;    }    ret = kvm_arch_init_vcpu(cpu);err:    return ret;}"}, {"type": "indirect assignment", "target": "0", "code": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr, uint8_t ar){    CPUS390XState *env = &cpu->env;    S390PCIBusDevice *pbdev;    MemoryRegion *mr;    int i;    uint32_t fh;    uint8_t pcias;    uint8_t len;    uint8_t buffer[128];    if (env->psw.mask & PSW_MASK_PSTATE) {        program_interrupt(env, PGM_PRIVILEGED, 6);        return 0;    }    // Removed indirect assignment: fh = env->regs[r1] >> 32;    // Removed indirect assignment: pcias = (env->regs[r1] >> 16) & 0xf;    // Removed indirect assignment: len = env->regs[r1] & 0xff;    if (pcias > 5) {        DPRINTF(\"pcistb invalid space\\n\");        setcc(cpu, ZPCI_PCI_LS_ERR);        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);        return 0;    }    switch (len) {    case 16:    case 32:    case 64:    case 128:        break;    default:        program_interrupt(env, PGM_SPECIFICATION, 6);        return 0;    }    pbdev = s390_pci_find_dev_by_fh(fh);    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);        return 0;    }    if (pbdev->lgstg_blocked) {        setcc(cpu, ZPCI_PCI_LS_ERR);        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);        return 0;    }    // Removed indirect assignment: mr = pbdev->pdev->io_regions[pcias].memory;    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {        program_interrupt(env, PGM_ADDRESSING, 6);        return 0;    }    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {        return 0;    }    for (i = 0; i < len / 8; i++) {        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,                                     ldq_p(buffer + i * 8), 8,                                     MEMTXATTRS_UNSPECIFIED);    }    setcc(cpu, ZPCI_PCI_LS_OK);    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static int ogg_buffer_data(AVFormatContext *s, AVStream *st,                           uint8_t *data, unsigned size, int64_t granule,                           int header){    OGGStreamContext *oggstream = st->priv_data;    OGGContext *ogg = s->priv_data;    int total_segments = size / 255 + 1;    uint8_t *p = data;    int i, segments, len, flush = 0;    if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header &&        (ogg_granule_to_timestamp(oggstream, granule) >         ogg_granule_to_timestamp(oggstream, oggstream->last_granule) + 1 ||         ogg_key_granule(oggstream, granule))) {        if (oggstream->page.granule != -1)            ogg_buffer_page(s, oggstream);        flush = 1;    }    if (!header && oggstream->page.size > 0 &&        MAX_PAGE_SIZE - oggstream->page.size < size) {        ogg_buffer_page(s, oggstream);    }    for (i = 0; i < total_segments;) {        OGGPage *page = &oggstream->page;        segments = FFMIN(total_segments - i, 255 - page->segments_count);        if (i && !page->segments_count) {            // Removed indirect assignment: page->flags |= 1;        }        memset(page->segments + page->segments_count, 255, segments - 1);        // Removed indirect assignment: page->segments_count += segments - 1;        len = FFMIN(size, segments * 255);        // Removed indirect assignment: page->segments[page->segments_count++] = len - (segments - 1) * 255;        memcpy(page->data + page->size, p, len);        // Removed indirect assignment: p += len;        size -= len;        i += segments;        // Removed indirect assignment: page->size += len;        if (i == total_segments) {            // Removed indirect assignment: page->granule = granule;        }        if (!header) {            AVStream *st = s->streams[page->stream_index];            int64_t start = av_rescale_q(page->start_granule, st->time_base,                                         AV_TIME_BASE_Q);            int64_t next = av_rescale_q(page->granule, st->time_base,                                        AV_TIME_BASE_Q);            if (page->segments_count == 255 ||                (ogg->pref_size > 0 && page->size >= ogg->pref_size) ||                (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) {                ogg_buffer_page(s, oggstream);            }        }    }    if (flush && oggstream->page.granule != -1)        ogg_buffer_page(s, oggstream);    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static void tcx_blit_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size){    TCXState *s = opaque;    uint32_t adsr, len;    int i;    if (!(addr & 4)) {        // Removed indirect assignment: s->tmpblit = val;    } else {        addr = (addr >> 3) & 0xfffff;        adsr = val & 0xffffff;        len = ((val >> 24) & 0x1f) + 1;        if (adsr == 0xffffff) {            memset(&s->vram[addr], s->tmpblit, len);            if (s->depth == 24) {                val = s->tmpblit & 0xffffff;                val = cpu_to_be32(val);                for (i = 0; i < len; i++) {                    // Removed indirect assignment: s->vram24[addr + i] = val;                }            }        } else {            memcpy(&s->vram[addr], &s->vram[adsr], len);            if (s->depth == 24) {                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);            }        }        memory_region_set_dirty(&s->vram_mem, addr, len);    }}"}, {"type": "indirect assignment", "target": "0", "code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid){    if (cid != ctx->cid) {        int index;        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %d\\n\", cid);            return AVERROR(ENOSYS);        }        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",                   ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);            return AVERROR_INVALIDDATA;        }        // Removed indirect assignment: ctx->cid_table = &ff_dnxhd_cid_table[index];        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %d.\\n\", cid);        ff_free_vlc(&ctx->ac_vlc);        ff_free_vlc(&ctx->dc_vlc);        ff_free_vlc(&ctx->run_vlc);        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,                 ctx->cid_table->ac_bits, 1, 1,                 ctx->cid_table->ac_codes, 2, 2, 0);        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,                 ctx->cid_table->dc_bits, 1, 1,                 ctx->cid_table->dc_codes, 1, 1, 0);        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,                 ctx->cid_table->run_bits, 1, 1,                 ctx->cid_table->run_codes, 2, 2, 0);        // Removed indirect assignment: ctx->cid = cid;    }    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr){    DeviceState *d;    APICCommonState *s;    uint32_t val;    int index;    d = cpu_get_current_apic();    if (!d) {        return 0;    }    s = DO_UPCAST(APICCommonState, busdev.qdev, d);    index = (addr >> 4) & 0xff;    switch (index) {    case 0x02: /* id */        val = s->id << 24;        break;    case 0x03: /* version */        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */        break;    case 0x08:        apic_sync_vapic(s, SYNC_FROM_VAPIC);        if (apic_report_tpr_access) {            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);        }        val = s->tpr;        break;    case 0x09:        val = apic_get_arb_pri(s);        break;    case 0x0a: /* ppr */        val = apic_get_ppr(s);        break;    case 0x0b:        val = 0;        break;    case 0x0d:        val = s->log_dest << 24;        break;    case 0x0e:        val = s->dest_mode << 28;        break;    case 0x0f:        val = s->spurious_vec;        break;    case 0x10 ... 0x17:        val = s->isr[index & 7];        break;    case 0x18 ... 0x1f:        val = s->tmr[index & 7];        break;    case 0x20 ... 0x27:        val = s->irr[index & 7];        break;    case 0x28:        val = s->esr;        break;    case 0x30:    case 0x31:        val = s->icr[index & 1];        break;    case 0x32 ... 0x37:        val = s->lvt[index - 0x32];        break;    case 0x38:        val = s->initial_count;        break;    case 0x39:        val = apic_get_current_count(s);        break;    case 0x3e:        val = s->divide_conf;        break;    default:        // Removed indirect assignment: s->esr |= ESR_ILLEGAL_ADDRESS;        val = 0;        break;    }    trace_apic_mem_readl(addr, val);    return val;}"}, {"type": "indirect assignment", "target": "0", "code": "void ff_fix_long_b_mvs(MpegEncContext *s, int16_t (*mv_table)[2], int f_code, int type){    int y;    uint8_t *fcode_tab = s->fcode_tab;    // RAL: 8 in MPEG-1, 16 in MPEG-4    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);    /* clip / convert to intra 16x16 type MVs */    for (y = 0; y < s->mb_height; y++) {        int x;        int xy = (y + 1) * (s->mb_width + 2) + 1;        int i = y * s->mb_width;        for (x = 0; x < s->mb_width; x++) {            if (s->mb_type[i] & type) { // RAL: \"type\" test added...                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code ||                    fcode_tab[mv_table[xy][0] + MAX_MV] == 0) {                    if (mv_table[xy][0] > 0)                        mv_table[xy][0] = range - 1;                    else                        mv_table[xy][0] = -range;                }                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code ||                    fcode_tab[mv_table[xy][1] + MAX_MV] == 0) {                    if (mv_table[xy][1] > 0)                        mv_table[xy][1] = range - 1;                    else                        mv_table[xy][1] = -range;                }            }            xy++;            i++;        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,                             const AVFrame *frame, int *got_packet_ptr){    G722Context *c = avctx->priv_data;    const int16_t *samples = (const int16_t *)frame->data[0];    int nb_samples, out_size, ret;    out_size = (frame->nb_samples + 1) / 2;    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))        return ret;    nb_samples = frame->nb_samples - (frame->nb_samples & 1);    if (avctx->trellis)        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);    else        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);    /* handle last frame with odd frame_size */    if (nb_samples < frame->nb_samples) {        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);    }    if (frame->pts != AV_NOPTS_VALUE) {        // Removed indirect assignment: avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);    }    // Removed indirect assignment: *got_packet_ptr = 1;    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "uint64_t helper_fnmsub(uint64_t arg1, uint64_t arg2, uint64_t arg3){    CPU_DoubleU farg1, farg2, farg3;    // Removed indirect assignment: farg1.ll = arg1;    // Removed indirect assignment: farg2.ll = arg2;    // Removed indirect assignment: farg3.ll = arg3;    if (unlikely(float64_is_signaling_nan(farg1.d) ||                 float64_is_signaling_nan(farg2.d) ||                 float64_is_signaling_nan(farg3.d))) {        /* sNaN operation */        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {        /* Multiplication of zero by infinity */        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);    } else {#if USE_PRECISE_EMULATION#ifdef FLOAT128        /* This is the way the PowerPC specification defines it */        float128 ft0_128, ft1_128;        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {            /* Magnitude subtraction of infinities */            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);        } else {            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);            farg1.d = float128_to_float64(ft0_128, &env->fp_status);        }#else        /* This is OK on x86 hosts */        // Removed indirect assignment: farg1.d = (farg1.d * farg2.d) - farg3.d;#endif#else        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);#endif        if (likely(!float64_is_nan(farg1.d)))            farg1.d = float64_chs(farg1.d);    }    return farg1.ll;}"}, {"type": "indirect assignment", "target": "0", "code": "static void start_children(FFStream *feed){    if (no_launch)        return;    for (; feed; feed = feed->next) { // Note: feed->next assignment cannot be removed without breaking loop        if (feed->child_argv && !feed->pid) {            // Removed indirect assignment: feed->pid_start = time(0);            feed->pid = fork();            if (feed->pid < 0) {                http_log(\"Unable to create children\\n\");                exit(1);            }            if (!feed->pid) {                /* In child */                char pathname[1024];                char *slash;                int i;                av_strlcpy(pathname, my_program_name, sizeof(pathname));                slash = strrchr(pathname, '/');                if (!slash) {                    // Removed indirect assignment: slash = pathname;                } else {                    // Removed indirect assignment: slash++;                }                strcpy(slash, \"ffmpeg\");                http_log(\"Launch command line: \");                http_log(\"%s \", pathname);                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)                    http_log(\"%s \", feed->child_argv[i]);                http_log(\"\\n\");                for (i = 3; i < 256; i++)                    close(i);                if (!ffserver_debug) {                    i = open(\"/dev/null\", O_RDWR);                    if (i != -1) {                        dup2(i, 0);                        dup2(i, 1);                        dup2(i, 2);                        close(i);                    }                }                /* This is needed to make relative pathnames work */                chdir(my_program_dir);                signal(SIGPIPE, SIG_DFL);                execvp(pathname, feed->child_argv);                _exit(1);            }        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "static int decode_plane(UtvideoContext *c, int plane_no,                        uint8_t *dst, int step, ptrdiff_t stride,                        int width, int height,                        const uint8_t *src, int use_pred){    int i, j, slice, pix;    int sstart, send;    VLC vlc;    GetBitContext gb;    int prev, fsym;    const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P))                                    : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);    if (build_huff(src, &vlc, &fsym)) {        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");        return AVERROR_INVALIDDATA;    }    if (fsym >= 0) { // build_huff reported a symbol to fill slices with        send = 0;        for (slice = 0; slice < c->slices; slice++) {            uint8_t *dest;            sstart = send;            send   = (height * (slice + 1) / c->slices) & cmask;            dest   = dst + sstart * stride;            prev = 0x80;            for (j = sstart; j < send; j++) {                for (i = 0; i < width * step; i += step) {                    pix = fsym;                    if (use_pred) {                        prev += pix;                        pix   = prev;                    }                    // Removed indirect assignment: dest[i] = pix;                }                // Removed indirect assignment: dest += stride;            }        }        return 0;    }    src += 256;    send = 0;    for (slice = 0; slice < c->slices; slice++) {        uint8_t *dest;        int slice_data_start, slice_data_end, slice_size;        sstart = send;        send   = (height * (slice + 1) / c->slices) & cmask;        dest   = dst + sstart * stride;        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;        slice_data_end   = AV_RL32(src + slice * 4);        slice_size       = slice_data_end - slice_data_start;        if (!slice_size) {            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"                   \"yet a slice has a length of zero.\\n\");            goto fail;        }        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);        c->bdsp.bswap_buf((uint32_t *)c->slice_bits,                          (uint32_t *)(src + slice_data_start + c->slices * 4),                          (slice_data_end - slice_data_start + 3) >> 2);        init_get_bits(&gb, c->slice_bits, slice_size * 8);        prev = 0x80;        for (j = sstart; j < send; j++) {            for (i = 0; i < width * step; i += step) {                pix = get_vlc2(&gb, vlc.table, VLC_BITS, 3);                if (pix < 0) {                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");                    goto fail;                }                if (use_pred) {                    prev += pix;                    pix   = prev;                }                // Removed indirect assignment: dest[i] = pix;            }            if (get_bits_left(&gb) < 0) {                av_log(c->avctx, AV_LOG_ERROR, \"Slice decoding ran out of bits\\n\");                goto fail;            }            // Removed indirect assignment: dest += stride;        }        if (get_bits_left(&gb) > 32)            av_log(c->avctx, AV_LOG_WARNING,                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));    }    ff_free_vlc(&vlc);    return 0;fail:    ff_free_vlc(&vlc);    return AVERROR_INVALIDDATA;}"}, {"type": "indirect assignment", "target": "0", "code": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn, void *src){    int result = 0;    if (secn > 0) {        uint32_t size = (uint32_t)secn * 512;        const uint8_t *sp = (const uint8_t *)src;        uint8_t *dp = 0;        if (s->bdrv_cur) {            dp = g_malloc(size);            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {                result = 1;            }        } else {            if (sec + secn > s->secs_cur) {                result = 1;            } else {                // Removed indirect assignment: dp = (uint8_t *)s->current + (sec << 9);            }        }        if (!result) {            uint32_t i;            for (i = 0; i < size; i++) {                // Removed indirect assignment: dp[i] &= sp[i];            }            if (s->bdrv_cur) {                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;            }        }        if (dp && s->bdrv_cur) {            g_free(dp);        }    }    return result;}"}, {"type": "indirect assignment", "target": "0", "code": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,                  target_ulong *raddr, int *flags){    int r = -1;    uint8_t *sk;    // Removed indirect assignment: *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;    vaddr &= TARGET_PAGE_MASK;    if (!(env->psw.mask & PSW_MASK_DAT)) {        // Removed indirect assignment: *raddr = vaddr;        r = 0;        goto out;    }    switch (asc) {    case PSW_ASC_PRIMARY:    case PSW_ASC_HOME:        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);        break;    case PSW_ASC_SECONDARY:        /*         * Instruction: Primary         * Data: Secondary         */        if (rw == 2) {            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags, rw);            // Removed indirect assignment: *flags &= ~(PAGE_READ | PAGE_WRITE);        } else {            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags, rw);            // Removed indirect assignment: *flags &= ~(PAGE_EXEC);        }        break;    case PSW_ASC_ACCREG:    default:        hw_error(\"guest switched to unknown asc mode\\n\");        break;    }out:    *raddr = mmu_real2abs(env, *raddr);    if (*raddr <= ram_size) {        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];        if (*flags & PAGE_READ) {            // Removed indirect assignment: *sk |= SK_R;        }        if (*flags & PAGE_WRITE) {            // Removed indirect assignment: *sk |= SK_C;        }    }    return r;}"}, {"type": "indirect assignment", "target": "0", "code": "static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size){    Mpeg1Context *s1 = avctx->priv_data;    MpegEncContext *s = &s1->mpeg_enc_ctx;    int width, height, i, v, j;    float aspect;    init_get_bits(&s->gb, buf, buf_size);    width = get_bits(&s->gb, 12);    height = get_bits(&s->gb, 12);    s->aspect_ratio_info = get_bits(&s->gb, 4);    if (!s->mpeg2) {        aspect = mpeg1_aspect[s->aspect_ratio_info];        if (aspect != 0.0) {            // Removed indirect assignment: avctx->aspect_ratio = width / (aspect * height);        }    }    s->frame_rate_index = get_bits(&s->gb, 4);    if (s->frame_rate_index == 0)        return -1;    s->bit_rate = get_bits(&s->gb, 18) * 400;    if (get_bits1(&s->gb) == 0) /* marker */        return -1;    if (width <= 0 || height <= 0 ||        (width % 2) != 0 || (height % 2) != 0)        return -1;    if (width != s->width || height != s->height) {        /* start new mpeg1 context decoding */        // Removed indirect assignment: s->out_format = FMT_MPEG1;        if (s1->mpeg_enc_ctx_allocated) {            MPV_common_end(s);        }        // Removed indirect assignment: s->width = width;        // Removed indirect assignment: s->height = height;        // Removed indirect assignment: avctx->has_b_frames = 1;        // Removed indirect assignment: s->avctx = avctx;        // Removed indirect assignment: avctx->width = width;        // Removed indirect assignment: avctx->height = height;        if (s->frame_rate_index >= 9) {            /* at least give a valid frame rate (some old mpeg1 have this) */            // Removed indirect assignment: avctx->frame_rate = 25 * FRAME_RATE_BASE;        } else {            // Removed indirect assignment: avctx->frame_rate = frame_rate_tab[s->frame_rate_index];        }        // Removed indirect assignment: s->frame_rate = avctx->frame_rate;        // Removed indirect assignment: avctx->bit_rate = s->bit_rate;        if (MPV_common_init(s) < 0)            return -1;        // Removed indirect assignment: s1->mpeg_enc_ctx_allocated = 1;    }    skip_bits(&s->gb, 10); /* vbv_buffer_size */    skip_bits(&s->gb, 1);    /* get matrix */    if (get_bits1(&s->gb)) {        for (i = 0; i < 64; i++) {            v = get_bits(&s->gb, 8);            j = s->intra_scantable.permutated[i];            // Removed indirect assignment: s->intra_matrix[j] = v;            // Removed indirect assignment: s->chroma_intra_matrix[j] = v;        }#ifdef DEBUG        dprintf(\"intra matrix present\\n\");        for (i = 0; i < 64; i++)            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);        printf(\"\\n\");#endif    } else {        for (i = 0; i < 64; i++) {            int j = s->idct_permutation[i];            v = ff_mpeg1_default_intra_matrix[i];            // Removed indirect assignment: s->intra_matrix[j] = v;            // Removed indirect assignment: s->chroma_intra_matrix[j] = v;        }    }    if (get_bits1(&s->gb)) {        for (i = 0; i < 64; i++) {            v = get_bits(&s->gb, 8);            j = s->intra_scantable.permutated[i];            // Removed indirect assignment: s->inter_matrix[j] = v;            // Removed indirect assignment: s->chroma_inter_matrix[j] = v;        }#ifdef DEBUG        dprintf(\"non intra matrix present\\n\");        for (i = 0; i < 64; i++)            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);        printf(\"\\n\");#endif    } else {        for (i = 0; i < 64; i++) {            int j = s->idct_permutation[i];            v = ff_mpeg1_default_non_intra_matrix[i];            // Removed indirect assignment: s->inter_matrix[j] = v;            // Removed indirect assignment: s->chroma_inter_matrix[j] = v;        }    }    // Removed indirect assignment: s->progressive_sequence = 1;    // Removed indirect assignment: s->progressive_frame = 1;    // Removed indirect assignment: s->picture_structure = PICT_FRAME;    // Removed indirect assignment: s->frame_pred_frame_dct = 1;    // Removed indirect assignment: s->mpeg2 = 0;    // Removed indirect assignment: avctx->sub_id = 1; /* indicates mpeg1 */    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br){    PCIDevice *pd = PCI_DEVICE(br);    PCIBus *parent;    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);    // Removed indirect assignment: parent = pd->bus;    pci_bridge_init_alias(br, &w->alias_pref_mem,                          PCI_BASE_ADDRESS_MEM_PREFETCH,                          \"pci_bridge_pref_mem\",                          &br->address_space_mem,                          parent->address_space_mem,                          cmd & PCI_COMMAND_MEMORY);    pci_bridge_init_alias(br, &w->alias_mem,                          PCI_BASE_ADDRESS_SPACE_MEMORY,                          \"pci_bridge_mem\",                          &br->address_space_mem,                          parent->address_space_mem,                          cmd & PCI_COMMAND_MEMORY);    pci_bridge_init_alias(br, &w->alias_io,                          PCI_BASE_ADDRESS_SPACE_IO,                          \"pci_bridge_io\",                          &br->address_space_io,                          parent->address_space_io,                          cmd & PCI_COMMAND_IO);    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);    return w;}"}, {"type": "indirect assignment", "target": "0", "code": "static int decode_ics(AACContext *ac, SingleChannelElement *sce, GetBitContext *gb,                      int common_window, int scale_flag){    Pulse pulse;    TemporalNoiseShaping *tns = &sce->tns;    IndividualChannelStream *ics = &sce->ics;    float *out = sce->coeffs;    int global_gain, pulse_present = 0;    /* This assignment is to silence a GCC warning about the variable being used     * uninitialized when in fact it always is.     */    // Removed indirect assignment: pulse.num_pulse = 0;    global_gain = get_bits(gb, 8);    if (!common_window && !scale_flag) {        if (decode_ics_info(ac, ics, gb, 0) < 0)            return -1;    }    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)        return -1;    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type,                            sce->band_type_run_end) < 0)        return -1;    pulse_present = 0;    if (!scale_flag) {        if ((pulse_present = get_bits1(gb))) {            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {                av_log(ac->avccontext, AV_LOG_ERROR,                       \"Pulse tool not allowed in eight short sequence.\\n\");                return -1;            }            decode_pulses(&pulse, gb, ics->swb_offset);        }        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))            return -1;        if (get_bits1(gb)) {            av_log_missing_feature(ac->avccontext, \"SSR\", 1);            return -1;        }    }    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse,                                    ics, sce->band_type) < 0)        return -1;    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset){    arm_sysctl_state *s = (arm_sysctl_state *)opaque;    switch (offset) {    case 0x00: /* ID */        return s->sys_id;    case 0x04: /* SW */        /* General purpose hardware switches.           We don't have a useful way of exposing these to the user. */        return 0;    case 0x08: /* LED */        return s->leds;    case 0x20: /* LOCK */        return s->lockval;    case 0x0c: /* OSC0 */    case 0x10: /* OSC1 */    case 0x14: /* OSC2 */    case 0x18: /* OSC3 */    case 0x1c: /* OSC4 */    case 0x24: /* 100HZ */        /* ??? Implement these. */        return 0;    case 0x28: /* CFGDATA1 */        return s->cfgdata1;    case 0x2c: /* CFGDATA2 */        return s->cfgdata2;    case 0x30: /* FLAGS */        return s->flags;    case 0x38: /* NVFLAGS */        return s->nvflags;    case 0x40: /* RESETCTL */        return s->resetlevel;    case 0x44: /* PCICTL */        return 1;    case 0x48: /* MCI */        return 0;    case 0x4c: /* FLASH */        return 0;    case 0x50: /* CLCD */        return 0x1000;    case 0x54: /* CLCDSER */        return 0;    case 0x58: /* BOOTCS */        return 0;    case 0x5c: /* 24MHz */        return muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec());    case 0x60: /* MISC */        return 0;    case 0x84: /* PROCID0 */        /* ??? Don't know what the proper value for the core tile ID is. */        Goreturn 0x02000000;    case 0x88: /* PROCID1 */        return 0xff000000;    case 0x64: /* DMAPSR0 */    case 0x68: /* DMAPSR1 */    case 0x6c: /* DMAPSR2 */    case 0x70: /* IOSEL */    case 0x74: /* PLDCTL */    case 0x80: /* BUSID */    case 0x8c: /* OSCRESET0 */    case 0x90: /* OSCRESET1 */    case 0x94: /* OSCRESET2 */    case 0x98: /* OSCRESET3 */    case 0x9c: /* OSCRESET4 */    case 0xc0: /* SYS_TEST_OSC0 */    case 0xc4: /* SYS_TEST_OSC1 */    case 0xc8: /* SYS_TEST_OSC2 */    case 0xcc: /* SYS_TEST_OSC3 */    case 0xd0: /* SYS_TEST_OSC4 */        return 0;    default:        printf(\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset);        return 0;    }}"}, {"type": "indirect assignment", "target": "0", "code": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts, int *duration) {    int64_t out_pts = AV_NOPTS_VALUE;    int removed_samples = 0;#ifdef DEBUG    ff_af_queue_log_state(afq);#endif    /* get output pts from the next frame or generated pts */    if (afq->frame_queue) {        if (afq->frame_queue->pts != AV_NOPTS_VALUE)            out_pts = afq->frame_queue->pts - afq->remaining_delay;    } else {        if (afq->next_pts != AV_NOPTS_VALUE)            out_pts = afq->next_pts - afq->remaining_delay;    }    if (pts) {        if (out_pts != AV_NOPTS_VALUE)            ; // *pts = ff_samples_to_time_base(afq->avctx, out_pts); // Removed indirect assignment        else            ; // *pts = AV_NOPTS_VALUE; // Removed indirect assignment    }    /* if the delay is larger than the packet duration, we use up delay samples       for the output packet and leave all frames in the queue */    if (afq->remaining_delay >= nb_samples) {        removed_samples += nb_samples;        afq->remaining_delay -= nb_samples;    }    /* remove frames from the queue until we have enough to cover the       requested number of samples or until the queue is empty */    while (removed_samples < nb_samples && afq->frame_queue) {        removed_samples += afq->frame_queue->duration;        delete_next_frame(afq);    }    afq->remaining_samples -= removed_samples;    /* if there are no frames left and we have room for more samples, use       any remaining delay samples */    if (removed_samples < nb_samples && afq->remaining_samples > 0) {        int add_samples = FFMIN(afq->remaining_samples, nb_samples - removed_samples);        removed_samples += add_samples;        afq->remaining_samples -= add_samples;    }    if (removed_samples > nb_samples)        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");    if (duration)        ; // *duration = ff_samples_to_time_base(afq->avctx, removed_samples); // Removed indirect assignment}"}, {"type": "indirect assignment", "target": "0", "code": "void ide_atapi_cmd(IDEState *s) {    uint8_t *buf;    buf = s->io_buffer;#ifdef DEBUG_IDE_ATAPI    {        int i;        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));        for (i = 0; i < ATAPI_PACKET_SIZE; i++) {            printf(\" %02x\", buf[i]);        }        printf(\"\\n\");    }#endif    /*     * If there's a UNIT_ATTENTION condition pending, only command flagged with     * ALLOW_UA are allowed to complete. with other commands getting a CHECK     * condition response unless a higher priority status, defined by the drive     * here, is pending.     */    if (s->sense_key == UNIT_ATTENTION &&        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {        ide_atapi_cmd_check_status(s);        return;    }    /*     * When a CD gets changed, we have to report an ejected state and     * then a loaded state to guests so that they detect tray     * open/close and media change events. Guests that do not use     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close     * states rely on this behavior.     */    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {        if (s->cdrom_changed == 1) {            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);            s->cdrom_changed = 2;        } else {            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);            s->cdrom_changed = 0;        }        return;    }    /* Report a Not Ready condition if appropriate for the command */    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&        (!media_present(s) || !bdrv_is_inserted(s->bs))) {        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);        return;    }    /* Execute the command */    if (atapi_cmd_table[s->io_buffer[0]].handler) {        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);        return;    }    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);}"}, {"type": "indirect assignment", "target": "0", "code": "static int parse_presentation_segment(AVCodecContext *avctx,                                      const uint8_t *buf,                                      int buf_size,                                      int64_t pts) {    PGSSubContext *ctx = avctx->priv_data;    int x, y, ret;    int w = bytestream_get_be16(&buf);    int h = bytestream_get_be16(&buf);    ctx->presentation.pts = pts;    av_dlog(avctx, \"Video Dimensions %dx%d\\n\", w, h);    ret = ff_set_dimensions(avctx, w, h);    if (ret < 0)        return ret;    /* Skip 1 byte of unknown, frame rate? */    buf++;    ctx->presentation.id_number = bytestream_get_be16(&buf);    /*     * Skip 3 bytes of unknown:     *     state     *     palette_update_flag (0x80),     *     palette_id_to_use,     */    buf += 3;    ctx->presentation.object_number = bytestream_get_byte(&buf);    ctx->presentation.composition_flag = 0;    if (!ctx->presentation.object_number)        return 0;    /*     * Skip 3 bytes of unknown:     *     object_id_ref (2 bytes),     *     window_id_ref,     */    buf += 3;    ctx->presentation.composition_flag = bytestream_get_byte(&buf);    x = bytestream_get_be16(&buf);    y = bytestream_get_be16(&buf);    /* TODO: If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes). */    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);    if (x > avctx->width || y > avctx->height) {        av_log(avctx, AV_LOG_ERROR,               \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\",               x, y, avctx->width, avctx->height);        x = 0;        y = 0;    }    /* Fill in dimensions */    ctx->presentation.x = x;    ctx->presentation.y = y;    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static void sdhci_write_block_to_card(SDHCIState *s) {    int index = 0;    if (s->prnsts & SDHC_SPACE_AVAILABLE) {        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {            s->norintsts |= SDHC_NIS_WBUFRDY;        }        sdhci_update_irq(s);        return;    }    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {        if (s->blkcnt == 0) {            return;        } else {            s->blkcnt--;        }    }    for (index = 0; index < (s->blksize & 0x0fff); index++) {        sd_write_data(s->card, s->fifo_buffer[index]);    }    /* Next data can be written through BUFFER DATORT register */    s->prnsts |= SDHC_SPACE_AVAILABLE;    /* Finish transfer if that was the last block of data */    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||        ((s->trnmod & SDHC_TRNS_MULTI) &&         (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {        SDHCI_GET_CLASS(s)->end_data_transfer(s);    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {        s->norintsts |= SDHC_NIS_WBUFRDY;    }    /* Generate Block Gap Event if requested and if not the last block */    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&        s->blkcnt > 0) {        s->prnsts &= ~SDHC_DOING_WRITE;        if (s->norintstsen & SDHC_EISEN_BLKGAP) {            s->norintsts |= SDHC_EIS_BLKGAP;        }        SDHCI_GET_CLASS(s)->end_data_transfer(s);    }    sdhci_update_irq(s);}"}, {"type": "indirect assignment", "target": "0", "code": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,                                      unsigned int size, int mem_index) {    int l1 = gen_new_label();    TCGv taddr = tcg_temp_local_new();    TCGv tval = tcg_temp_local_new();    TCGv t1 = tcg_temp_local_new();    dc->postinc = 0;    cris_evaluate_flags(dc);    tcg_gen_mov_tl(taddr, addr);    tcg_gen_mov_tl(tval, val);    /* Store only if F flag isn't set */    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);    if (size == 1) {        tcg_gen_qemu_st8(tval, taddr, mem_index);    } else if (size == 2) {        tcg_gen_qemu_st16(tval, taddr, mem_index);    } else {        tcg_gen_qemu_st32(tval, taddr, mem_index);    }    gen_set_label(l1);    tcg_gen_shri_tl(t1, t1, 1); /* shift F to P position */    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /* P=F */    tcg_temp_free(t1);    tcg_temp_free(tval);    tcg_temp_free(taddr);}"}, {"type": "indirect assignment", "target": "0", "code": "int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,                                   GetBitContext *gb) {    int i;    MMCO *mmco = sl->mmco;    int nb_mmco = 0;    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields        skip_bits1(gb); // broken_link        if (get_bits1(gb)) {            mmco[0].opcode = MMCO_LONG;            mmco[0].long_arg = 0;            nb_mmco = 1;        }        sl->explicit_ref_marking = 1;    } else {        sl->explicit_ref_marking = get_bits1(gb);        if (sl->explicit_ref_marking) {            for (i = 0; i < MAX_MMCO_COUNT; i++) {                MMCOOpcode opcode = get_ue_golomb_31(gb);                mmco[i].opcode = opcode;                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {                    mmco[i].short_pic_num =                        (sl->curr_pic_num - get_ue_golomb(gb) - 1) &                        (sl->max_pic_num - 1);#if 0                    if (mmco[i].short_pic_num >= h->short_ref_count ||                        !h->short_ref[mmco[i].short_pic_num]) {                        av_log(s->avctx, AV_LOG_ERROR,                               \"illegal short ref in memory management control \"                               \"operation %d\\n\", mmco);                        return -1;                    }#endif                }                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {                    unsigned int long_arg = get_ue_golomb_31(gb);                    if (long_arg >= 32 ||                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&                                             long_arg == 16) &&                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {                        av_log(h->avctx, AV_LOG_ERROR,                               \"illegal long ref in memory management control \"                               \"operation %d\\n\", opcode);                        return -1;                    }                    mmco[i].long_arg = long_arg;                }                if (opcode > (unsigned) MMCO_LONG) {                    av_log(h->avctx, AV_LOG_ERROR,                           \"illegal memory management control operation %d\\n\",                           opcode);                    return -1;                }                if (opcode == MMCO_END)                    break;            }            nb_mmco = i;        }    }    sl->nb_mmco = nb_mmco;    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len) {    const USBDesc *desc = dev->info->usb_desc;    uint8_t buf[256];    uint8_t type = value >> 8;    uint8_t index = value & 0xff;    int ret = -1;    switch (type) {    case USB_DT_DEVICE:        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));        trace_usb_desc_device(dev->addr, len, ret);        break;    case USB_DT_CONFIG:        if (index < desc->full->bNumConfigurations) {            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));        }        trace_usb_desc_config(dev->addr, index, len, ret);        break;    case USB_DT_STRING:        ret = usb_desc_string(dev, index, buf, sizeof(buf));        trace_usb_desc_string(dev->addr, index, len, ret);        break;    default:        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,                dev->addr, type, len);        break;    }    if (ret > 0) {        if (ret > len) {            ret = len;        }        // memcpy(dest, buf, ret); // Removed: Indirect assignment via memcpy    }    return ret;}"}, {"type": "indirect assignment", "target": "0", "code": "static void reverse_matrixing(float *su1, float *su2, int *prev_code, int *curr_code) {    int i, nsample, band;    float mc1_l, mc1_r, mc2_l, mc2_r;    for (i = 0, band = 0; band < 4 * 256; band += 256, i++) {        int s1 = prev_code[i];        int s2 = curr_code[i];        nsample = 0;        if (s1 != s2) {            /* Selector value changed, interpolation needed. */            mc1_l = matrix_coeffs[s1 * 2];            mc1_r = matrix_coeffs[s1 * 2 + 1];            mc2_l = matrix_coeffs[s2 * 2];            mc2_r = matrix_coeffs[s2 * 2 + 1];            /* Interpolation is done over the first eight samples. */            for (; nsample < 8; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +                     c2 * INTERPOLATE(mc1_r, mc2_r, nsample);                // su1[band + nsample] = c2; // Removed: Indirect assignment                // su2[band + nsample] = c1 * 2.0 - c2; // Removed: Indirect assignment            }        }        /* Apply the matrix without interpolation. */        switch (s2) {        case 0: /* M/S decoding */            for (; nsample < 256; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                // su1[band + nsample] = c2 * 2.0; // Removed: Indirect assignment                // su2[band + nsample] = (c1 - c2) * 2.0; // Removed: Indirect assignment            }            break;        case 1:            for (; nsample < 256; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                // su1[band + nsample] = (c1 + c2) * 2.0; // Removed: Indirect assignment                // su2[band + nsample] = c2 * -2.0; // Removed: Indirect assignment            }            break;        case 2:        case 3:            for (; nsample < 256; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                // su1[band + nsample] = c1 + c2; // Removed: Indirect assignment                // su2[band + nsample] = c1 - c2; // Removed: Indirect assignment            }            break;        default:            assert(0);        }    }}"}, {"type": "indirect assignment", "target": "0", "code": "static void *do_data_decompress(void *opaque) {    DecompressParam *param = opaque;    unsigned long pagesize;    while (!quit_decomp_thread) {        qemu_mutex_lock(param->mutex);        while (!param->start && !quit_decomp_thread) {            qemu_cond_wait(param->cond, param->mutex);        }        if (!quit_decomp_thread) {            pagesize = TARGET_PAGE_SIZE;            /* uncompress() will return failed in some case, especially             * when the page is dirted when doing the compression, it's             * not a problem because the dirty page will be retransferred             * and uncompress() won't break the data in other pages.             */            uncompress((Bytef *)param->des, &pagesize,                       (const Bytef *)param->compbuf, param->len);        }        // param->start = false; // Removed: Indirect assignment        qemu_mutex_unlock(param->mutex);        qemu_mutex_lock(&decomp_done_lock);        // param->done = true; // Removed: Indirect assignment        qemu_cond_signal(&decomp_done_cond);        qemu_mutex_unlock(&decomp_done_lock);    }    return NULL;}"}, {"type": "indirect assignment", "target": "0", "code": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s, struct vmsvga_cursor_definition_s *c) {    QEMUCursor *qc;    int i, pixels;    qc = cursor_alloc(c->width, c->height);    // qc->hot_x = c->hot_x; // Removed: Indirect assignment    // qc->hot_y = c->hot_y; // Removed: Indirect assignment    switch (c->bpp) {    case 1:        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image, 1, (void*)c->mask);#ifdef DEBUG        cursor_print_ascii_art(qc, \"vmware/mono\");#endif        break;    case 32:        /* fill alpha channel from mask, set color to zero */        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask, 1, (void*)c->mask);        /* add in rgb values */        pixels = c->width * c->height;        for (i = 0; i < pixels; i++) {            // qc->data[i] |= c->image[i] & 0xffffff; // Removed: Indirect assignment        }#ifdef DEBUG        cursor_print_ascii_art(qc, \"vmware/32bit\");#endif        break;    default:        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\", __FUNCTION__, c->bpp);        cursor_put(qc);        qc = cursor_builtin_left_ptr();    }    dpy_cursor_define(s->vga.ds, qc);    cursor_put(qc);}"}, {"type": "indirect assignment", "target": "0", "code": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset, unsigned int nb_clusters) {    BDRVQcowState *s = bs->opaque;    uint64_t *l2_table;    int l2_index;    int ret;    int i;    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);    if (ret < 0) {        return ret;    }    /* Limit nb_clusters to one L2 table */    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);    for (i = 0; i < nb_clusters; i++) {        uint64_t old_offset;        old_offset = be64_to_cpu(l2_table[l2_index + i]);        /* Update L2 entries */        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);        if (old_offset & QCOW_OFLAG_COMPRESSED) {            // l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO); // Removed: Indirect assignment            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);        } else {            // l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO); // Removed: Indirect assignment        }    }    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);    if (ret < 0) {        return ret;    }    return nb_clusters;}"}, {"type": "indirect assignment", "target": "0", "code": "static int scsi_initfn(SCSIDevice *dev) {    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);    Error *err = NULL;    if (!s->qdev.conf.bs) {        error_report(\"drive property not set\");        return -1;    }    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !bdrv_is_inserted(s->qdev.conf.bs)) {        error_report(\"Device needs media, but drive is empty\");        return -1;    }    blkconf_serial(&s->qdev.conf, &s->serial);    if (dev->type == TYPE_DISK) {        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);        if (err) {            error_report(\"%s\", error_get_pretty(err));            error_free(err);            return -1;        }    }    if (s->qdev.conf.discard_granularity == -1) {        // s->qdev.conf.discard_granularity = MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY); // Removed: Indirect assignment    }    if (!s->version) {        s->version = g_strdup(qemu_get_version());    }    if (!s->vendor) {        s->vendor = g_strdup(\"QEMU\");    }    if (bdrv_is_sg(s->qdev.conf.bs)) {        error_report(\"unwanted /dev/sg*\");        return -1;    }    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);    } else {        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);    }    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);    bdrv_iostatus_enable(s->qdev.conf.bs);    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap) {    QObject *token;    const char *val;    if (ap == NULL) {        return NULL;    }    token = parser_context_pop_token(ctxt);    assert(token && token_get_type(token) == JSON_ESCAPE);    val = token_get_value(token);    if (!strcmp(val, \"%p\")) {        return va_arg(*ap, QObject *);    } else if (!strcmp(val, \"%i\")) {        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));    } else if (!strcmp(val, \"%d\")) {        return QOBJECT(qint_from_int(va_arg(*ap, int)));    } else if (!strcmp(val, \"%ld\")) {        return QOBJECT(qint_from_int(va_arg(*ap, long)));    } else if (!strcmp(val, \"%lld\") || !strcmp(val, \"%I64d\")) {        return QOBJECT(qint_from_int(va_arg(*ap, long long)));    } else if (!strcmp(val, \"%s\")) {        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));    } else if (!strcmp(val, \"%f\")) {        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));    }    return NULL;}"}, {"type": "indirect assignment", "target": "0", "code": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev) {#ifdef CONFIG_KVM    struct kvm_irqfd irqfd = {        .fd = event_notifier_get_fd(&vdev->intx.interrupt),        .gsi = vdev->intx.route.irq,        .flags = KVM_IRQFD_FLAG_RESAMPLE,    };    struct vfio_irq_set *irq_set;    int ret, argsz;    int32_t *pfd;    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||        vdev->intx.route.mode != PCI_INTX_ENABLED || !kvm_resamplefds_enabled()) {        return;    }    /* Get to a known interrupt state */    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);    // vdev->intx.pending = false; // Removed: Indirect assignment    pci_irq_deassert(&vdev->pdev);    /* Get an eventfd for resample/unmask */    if (event_notifier_init(&vdev->intx.unmask, 0)) {        error_report(\"vfio: Error: event_notifier_init failed eoi\");        goto fail;    }    /* KVM triggers it, VFIO listens for it */    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {        error_report(\"vfio: Error: Failed to setup resample irqfd: %m\");        goto fail_irqfd;    }    argsz = sizeof(*irq_set) + sizeof(*pfd);    irq_set = g_malloc0(argsz);    // irq_set->argsz = argsz; // Removed: Indirect assignment    // irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK; // Removed: Indirect assignment    // irq_set->index = VFIO_PCI_INTX_IRQ_INDEX; // Removed: Indirect assignment    // irq_set->start = 0; // Removed: Indirect assignment    // irq_set->count = 1; // Removed: Indirect assignment    pfd = (int32_t *)&irq_set->data;    // *pfd = irqfd.resamplefd; // Removed: Indirect assignment    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);    g_free(irq_set);    if (ret) {        error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");        goto fail_vfio;    }    /* Let'em rip */    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);    // vdev->intx.kvm_accel = true; // Removed: Indirect assignment    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);    return;fail_vfio:    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);fail_irqfd:    event_notifier_cleanup(&vdev->intx.unmask);fail:    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);#endif}"}, {"type": "indirect assignment", "target": "0", "code": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {    uint32_t v, spf;    MPADecodeHeader c;    int vbrtag_size = 0;    MP3DecContext *mp3 = s->priv_data;    ffio_init_checksum(s->pb, ff_crcA001_update, 0);    v = avio_rb32(s->pb);    if (ff_mpa_check_header(v) < 0)        return -1;    if (avpriv_mpegaudio_decode_header(&c, v) == 0)        vbrtag_size = c.frame_size;    if (c.layer != 3)        return -1;    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */    // mp3->frames = 0; // Removed: Indirect assignment    // mp3->size = 0;   // Removed: Indirect assignment    mp3_parse_info_tag(s, st, &c, spf);    mp3_parse_vbri_tag(s, st, base);    if (!mp3->frames && !mp3->size)        return -1;    /* Skip the vbr tag frame */    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);    if (mp3->frames)        // st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate}, st->time_base); // Removed: Indirect assignment    if (mp3->size && mp3->frames && !mp3->is_cbr)        // st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf); // Removed: Indirect assignment    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static void setup_frame(int sig, struct emulated_sigaction *ka, target_sigset_t *set, CPUX86State *env) {    struct sigframe *frame;    int err = 0;    frame = get_sigframe(ka, env, sizeof(*frame));#if 0    if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))        goto give_sigsegv;#endif    err |= __put_user((/*current->exec_domain                       && current->exec_domain->signal_invmap                       && sig < 32                       ? current->exec_domain->signal_invmap[sig]                       : */ sig),                      &frame->sig);    if (err)        goto give_sigsegv;    setup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);    if (err)        goto give_sigsegv;    if (TARGET_NSIG_WORDS > 1) {        err |= __copy_to_user(frame->extramask, &set->sig[1], sizeof(frame->extramask));    }    if (err)        goto give_sigsegv;    /* Set up to return from userspace.  If provided, use a stub already in userspace. */    if (ka->sa.sa_flags & TARGET_SA_RESTORER) {        err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);    } else {        err |= __put_user(frame->retcode, &frame->pretcode);        /* This is popl %eax ; movl $,%eax ; int $0x80 */        err |= __put_user(0xb858, (short *)(frame->retcode + 0));        err |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode + 2));        err |= __put_user(0x80cd, (short *)(frame->retcode + 6));    }    if (err)        goto give_sigsegv;    /* Set up registers for signal handler */    // env->regs[R_ESP] = (unsigned long) frame; // Removed: Indirect assignment    // env->eip = (unsigned long) ka->sa._sa_handler; // Removed: Indirect assignment    cpu_x86_load_seg(env, R_DS, __USER_DS);    cpu_x86_load_seg(env, R_ES, __USER_DS);    cpu_x86_load_seg(env, R_SS, __USER_DS);    cpu_x86_load_seg(env, R_CS, __USER_CS);    // env->eflags &= ~TF_MASK; // Removed: Indirect assignment    return;give_sigsegv:    if (sig == TARGET_SIGSEGV)        // ka->sa._sa_handler = TARGET_SIG_DFL; // Removed: Indirect assignment    force_sig(TARGET_SIGSEGV /* , current */);}"}, {"type": "indirect assignment", "target": "0", "code": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl) {    VGACommonState *vga = &qxl->vga;    int i;    if (qxl->guest_primary.resized) {        // qxl->guest_primary.resized = 0; // Removed: Indirect assignment        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);        // qxl->num_dirty_rects = 1; // Removed: Indirect assignment        trace_qxl_render_guest_primary_resized(            qxl->guest_primary.surface.width,            qxl->guest_primary.surface.height,            qxl->guest_primary.qxl_stride,            qxl->guest_primary.bytes_pp,            qxl->guest_primary.bits_pp        );        if (qxl->guest_primary.qxl_stride > 0) {            qemu_free_displaysurface(vga->ds);            qemu_create_displaysurface_from(                qxl->guest_primary.surface.width,                qxl->guest_primary.surface.height,                qxl->guest_primary.bits_pp,                qxl->guest_primary.abs_stride,                qxl->guest_primary.data            );        } else {            qemu_resize_displaysurface(                vga->ds,                qxl->guest_primary.surface.width,                qxl->guest_primary.surface.height            );        }        dpy_gfx_resize(vga->ds);    }    for (i = 0; i < qxl->num_dirty_rects; i++) {        if (qemu_spice_rect_is_empty(qxl->dirty + i)) {            break;        }        qxl_blit(qxl, qxl->dirty + i);        dpy_gfx_update(            vga->ds,            qxl->dirty[i].left,            qxl->dirty[i].top,            qxl->dirty[i].right - qxl->dirty[i].left,            qxl->dirty[i].bottom - qxl->dirty[i].top        );    }    // qxl->num_dirty_rects = 0; // Removed: Indirect assignment}"}, {"type": "indirect assignment", "target": "0", "code": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom) {    AVStream *st;    MOVStreamContext *sc;    unsigned int i, entries;    if (c->fc->nb_streams < 1)        return 0;    st = c->fc->streams[c->fc->nb_streams - 1];    sc = st->priv_data;    avio_r8(pb); /* version */    avio_rb24(pb); /* flags */    entries = avio_rb32(pb);    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams - 1, entries);    if (!entries)        return 0;    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))        return AVERROR_INVALIDDATA;    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));    if (!sc->stsc_data)        return AVERROR(ENOMEM);    for (i = 0; i < entries && !pb->eof_reached; i++) {        // sc->stsc_data[i].first = avio_rb32(pb); // Removed: Indirect assignment        // sc->stsc_data[i].count = avio_rb32(pb); // Removed: Indirect assignment        // sc->stsc_data[i].id = avio_rb32(pb); // Removed: Indirect assignment        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {            // sc->stsc_data[i].id = 0; // Removed: Indirect assignment            if (c->fc->error_recognition & AV_EF_EXPLODE) {                av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\");                return AVERROR_INVALIDDATA;            }        }    }    // sc->stsc_count = i; // Removed: Indirect assignment    if (pb->eof_reached)        return AVERROR_EOF;    return 0;}"}, {"type": "indirect assignment", "target": "0", "code": "static int create_stream(AVFormatContext *s) {    XCBGrabContext *c = s->priv_data;    AVStream *st = avformat_new_stream(s, NULL);    xcb_get_geometry_cookie_t gc;    xcb_get_geometry_reply_t *geo;    int ret;    if (!st)        return AVERROR(ENOMEM);    ret = av_parse_video_size(&c->width, &c->height, c->video_size);    if (ret < 0)        return ret;    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);    if (ret < 0)        return ret;    avpriv_set_pts_info(st, 64, 1, 1000000);    gc = xcb_get_geometry(c->conn, c->screen->root);    geo = xcb_get_geometry_reply(c->conn, gc, NULL);    // c->width = FFMIN(geo->width, c->width); // Removed: Indirect assignment    // c->height = FFMIN(geo->height, c->height); // Removed: Indirect assignment    // c->time_base = (AVRational){st->avg_frame_rate.den, st->avg_frame_rate.num}; // Removed: Indirect assignment    c->time_frame = av_gettime();    // st->codec->codec_type = AVMEDIA_TYPE_VIDEO; // Removed: Indirect assignment    // st->codec->codec_id = AV_CODEC_ID_RAWVIDEO; // Removed: Indirect assignment    // st->codec->width = c->width; // Removed: Indirect assignment    // st->codec->height = c->height; // Removed: Indirect assignment    // st->codec->time_base = c->time_base; // Removed: Indirect assignment    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);    free(geo);    return ret;}"}, {"type": "indirect assignment", "target": "0", "code": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,                                    sPAPRDRConnectorType drc_type, uint32_t drc){    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());    struct hp_log_full *new_hp;    struct rtas_error_log *hdr;    struct rtas_event_log_v6 *v6hdr;    struct rtas_event_log_v6_maina *maina;    struct rtas_event_log_v6_mainb *mainb;    struct rtas_event_log_v6_hp *hp;    new_hp = g_malloc0(sizeof(struct hp_log_full));    hdr = &new_hp->hdr;     // Retained as it\u2019s a pointer initialization, not modification    v6hdr = &new_hp->v6hdr; // Retained as it\u2019s a pointer initialization, not modification    maina = &new_hp->maina; // Retained as it\u2019s a pointer initialization, not modification    mainb = &new_hp->mainb; // Retained as it\u2019s a pointer initialization, not modification    hp = &new_hp->hp;       // Retained as it\u2019s a pointer initialization, not modification    // hdr->summary = cpu_to_be32(...); // Removed indirect assignment    // hdr->extended_length = cpu_to_be32(...); // Removed indirect assignment    spapr_init_v6hdr(v6hdr);    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);    // mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB); // Removed indirect assignment    // mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb)); // Removed indirect assignment    // mainb->subsystem_id = 0x80; // Removed indirect assignment    // mainb->event_severity = 0x00; // Removed indirect assignment    // mainb->event_subtype = 0x00; // Removed indirect assignment    // hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG); // Removed indirect assignment    // hp->hdr.section_length = cpu_to_be16(sizeof(*hp)); // Removed indirect assignment    // hp->hdr.section_version = 1; // Removed indirect assignment    // hp->hotplug_action = hp_action; // Removed indirect assignment    // hp->hotplug_identifier = hp_id; // Removed indirect assignment    switch (drc_type) {    case SPAPR_DR_CONNECTOR_TYPE_PCI:        // hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI; // Removed indirect assignment        if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {            spapr_hotplug_set_signalled(drc);        }        break;    case SPAPR_DR_CONNECTOR_TYPE_LMB:        // hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY; // Removed indirect assignment        break;    case SPAPR_DR_CONNECTOR_TYPE_CPU:        // hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU; // Removed indirect assignment        break;    default:        /* we shouldn't be signaling hotplug events for resources         * that don't support them         */        g_assert(false);        return;    }    if (hp_id == RTAS_LOG_V6_HP_ID_DRC_COUNT) {        // hp->drc.count = cpu_to_be32(drc); // Removed indirect assignment    } else if (hp_id == RTAS_LOG_V6_HP_ID_DRC_INDEX) {        // hp->drc.index = cpu_to_be32(drc); // Removed indirect assignment    }    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));}"}, {"type": "indirect assignment", "target": "0", "code": "static inline bool regime_translation_disabled(CPUARMState *env, ARMMMUIdx mmu_idx){    if (arm_feature(env, ARM_FEATURE_M)) {        switch (0) { // Replaced env->v7m.mpu_ctrl & ... with fixed value 0        case R_V7M_MPU_CTRL_ENABLE_MASK:            /* Enabled, but not for HardFault and NMI */            return mmu_idx == ARMMMUIdx_MNegPri || mmu_idx == ARMMMUIdx_MSNegPri;        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:            /* Enabled for all cases */            return false;        case 0:        default:            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but             * we warned about that in armv7m_nvic.c when the guest set it.             */            return true;        }    }    if (mmu_idx == ARMMMUIdx_S2NS) {        return 0; // Replaced (env->cp15.hcr_el2 & HCR_VM) == 0 with fixed value    }    return 0; // Replaced (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0 with fixed value}"}, {"type": "indirect assignment", "target": "0", "code": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,                                 int *got_frame_ptr, AVPacket *avpkt){    EightSvxContext *esc = avctx->priv_data;    int n, out_data_size;    int ch, ret;    uint8_t *src;    /* decode and interleave the first packet */    if (!esc->samples && avpkt) {        int packet_size = avpkt->size;        if (packet_size % avctx->channels) {            av_log(avctx, AV_LOG_WARNING, \"Packet with odd size, ignoring last byte\\n\");            if (packet_size < avctx->channels)                return packet_size;            packet_size -= packet_size % avctx->channels;        }        esc->samples_size = !esc->table ?                            packet_size : avctx->channels + (packet_size - avctx->channels) * 2;        // esc->samples = av_malloc(esc->samples_size); // Removed indirect assignment        if (!esc->samples)            return AVERROR(ENOMEM);        /* decompress */        if (esc->table) {            const uint8_t *buf = avpkt->data;            uint8_t *dst;            int buf_size = avpkt->size;            int i, n = esc->samples_size;            if (buf_size < 2) {                av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\");                return AVERROR(EINVAL);            }            /* the uncompressed starting value is contained in the first byte */            dst = esc->samples;            for (i = 0; i < avctx->channels; i++) {                // *(dst++) = buf[0] + 128; // Removed indirect assignment                delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0] + 128) & 0xFF, esc->table);                buf += buf_size / avctx->channels;                dst += n / avctx->channels - 1;            }        } else {            raw_decode(esc->samples, avpkt->data, esc->samples_size);        }    }    /* get output buffer */    av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));    // esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx) / avctx->channels; // Removed indirect assignment    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");        return ret;    }    // *got_frame_ptr = 1; // Removed indirect assignment    // *(AVFrame *)data = esc->frame; // Removed indirect assignment    out_data_size = esc->frame.nb_samples;    for (ch = 0; ch < avctx->channels; ch++) {        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;        memcpy(esc->frame.data[ch], src, out_data_size);    }    out_data_size *= avctx->channels;    // esc->samples_idx += out_data_size; // Removed indirect assignment    return esc->table ?           (avctx->frame_number == 0) * 2 + out_data_size / 2 :           out_data_size;}"}, {"type": "indirect assignment", "target": "0", "code": "static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref){    AResampleContext *aresample = inlink->dst->priv;    const int n_in = insamplesref->audio->nb_samples;    int n_out = FFMAX(n_in * aresample->ratio * 2, 1);    AVFilterLink *const outlink = inlink->dst->outputs[0];    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);    int ret;    if (!outsamplesref)        return AVERROR(ENOMEM);    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);    // Removed indirect assignment: outsamplesref->format = outlink->format;    // Removed indirect assignment: outsamplesref->audio->channel_layout = outlink->channel_layout;    // Removed indirect assignment: outsamplesref->audio->sample_rate = outlink->sample_rate;    if (insamplesref->pts != AV_NOPTS_VALUE) {        int64_t inpts = av_rescale(insamplesref->pts,                                   inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate,                                   inlink->time_base.den);        int64_t outpts = swr_next_pts(aresample->swr, inpts);        // Removed indirect assignment: aresample->next_pts = outsamplesref->pts = (outpts + inlink->sample_rate / 2) / inlink->sample_rate;    } else {        // Removed indirect assignment: outsamplesref->pts = AV_NOPTS_VALUE;    }    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,                        (void *)insamplesref->extended_data, n_in);    if (n_out <= 0) {        avfilter_unref_buffer(outsamplesref);        avfilter_unref_buffer(insamplesref);        return 0;    }    // Removed indirect assignment: outsamplesref->audio->nb_samples = n_out;    ret = ff_filter_samples(outlink, outsamplesref);    // Removed indirect assignment: aresample->req_fullfilled = 1;    avfilter_unref_buffer(insamplesref);    return ret;}"}, {"type": "indirect assignment", "target": "0", "code": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd){    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);    int ret;    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));        scsi_req_complete(&r->req, CHECK_CONDITION);        return 0;    }    if (-1 == scsi_req_parse(&r->req, cmd)) {        BADF(\"Unsupported command length, command %x\\n\", cmd[0]);        scsi_command_complete(r, -EINVAL);        return 0;    }    scsi_req_fixup(&r->req);    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag,            r->req.cmd.xfer, cmd[0]);#ifdef DEBUG_SCSI    {        int i;        for (i = 1; i < r->req.cmd.len; i++) {            printf(\" 0x%02x\", cmd[i]);        }        printf(\"\\n\");    }#endif    if (r->req.cmd.xfer == 0) {        if (r->buf != NULL)            qemu_free(r->buf);        // Removed indirect assignment: r->buflen = 0;        // Removed indirect assignment: r->buf = NULL;        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);        if (ret < 0) {            scsi_command_complete(r, ret);            return 0;        }        return 0;    }    if (r->buflen != r->req.cmd.xfer) {        if (r->buf != NULL)            qemu_free(r->buf);        r->buf = qemu_malloc(r->req.cmd.xfer);        // Removed indirect assignment: r->buflen = r->req.cmd.xfer;    }    memset(r->buf, 0, r->buflen);    // Removed indirect assignment: r->len = r->req.cmd.xfer;    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {        // Removed indirect assignment: r->len = 0;        return -r->req.cmd.xfer;    } else {        return r->req.cmd.xfer;    }}"}, {"type": "indirect assignment", "target": "0", "code": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn){    unsigned int mos, type, rm, cond, rn, op, nzcv;    TCGv_i64 tcg_flags;    int label_continue = -1;    mos = extract32(insn, 29, 3);    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */    rm = extract32(insn, 16, 5);    cond = extract32(insn, 12, 4);    rn = extract32(insn, 5, 5);    op = extract32(insn, 4, 1);    nzcv = extract32(insn, 0, 4);    if (mos || type > 1) {        unallocated_encoding(s);        return;    }    if (!fp_access_check(s)) {        return;    }    if (cond < 0x0e) { /* not always */        int label_match = gen_new_label();        label_continue = gen_new_label();        arm_gen_test_cc(cond, label_match);        /* nomatch: */        tcg_flags = tcg_const_i64(nzcv << 28);        gen_set_nzcv(tcg_flags);        tcg_temp_free_i64(tcg_flags);        tcg_gen_br(label_continue);        gen_set_label(label_match);    }    handle_fp_compare(s, type, rn, rm, false, op);    if (cond < 0x0e) {        gen_set_label(label_continue);    }}"}, {"type": "indirect assignment", "target": "0", "code": "int ff_estimate_motion_b(MpegEncContext *s,                         int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code){    int mx, my, range, dmin;    int xmin, ymin, xmax, ymax;    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;    int pred_x = 0, pred_y = 0;    int P[6][2];    const int shift = 1 + s->quarter_sample;    const int mot_stride = s->mb_width + 2;    const int mot_xy = (mb_y + 1) * mot_stride + mb_x + 1;    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code);    switch (s->me_method) {    case ME_ZERO:    default:        no_motion_search(s, &mx, &my);        dmin = 0;        break;    case ME_FULL:        dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);        break;    case ME_LOG:        dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);        break;    case ME_PHODS:        dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);        break;    case ME_X1:    case ME_EPZS:        rel_xmin = xmin - mb_x * 16;        rel_xmax = xmax - mb_x * 16;        rel_ymin = ymin - mb_y * 16;        rel_ymax = ymax - mb_y * 16;        P[0][0] = mv_table[mot_xy][0];        P[0][1] = mv_table[mot_xy][1];        P[1][0] = mv_table[mot_xy - 1][0];        P[1][1] = mv_table[mot_xy - 1][1];        if (P[1][0] > (rel_xmax << shift))            // Removed indirect assignment: P[1][0] = (rel_xmax << shift);        /* special case for first line */        if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {            // Removed indirect assignment: P[4][0] = P[1][0];            // Removed indirect assignment: P[4][1] = P[1][1];        } else {            P[2][0] = mv_table[mot_xy - mot_stride][0];            P[2][1] = mv_table[mot_xy - mot_stride][1];            P[3][0] = mv_table[mot_xy - mot_stride + 1][0];            P[3][1] = mv_table[mot_xy - mot_stride + 1][1];            if (P[2][1] > (rel_ymax << shift))                // Removed indirect assignment: P[2][1] = (rel_ymax << shift);            if (P[3][0] < (rel_xmin << shift))                // Removed indirect assignment: P[3][0] = (rel_xmin << shift);            if (P[3][1] > (rel_ymax << shift))                // Removed indirect assignment: P[3][1] = (rel_ymax << shift);            P[4][0] = mid_pred(P[1][0], P[2][0], P[3][0]);            P[4][1] = mid_pred(P[1][1], P[2][1], P[3][1]);        }        pred_x = P[1][0];        pred_y = P[1][1];        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);        mx += mb_x * 16;        my += mb_y * 16;        break;    }    /* intra / predictive decision */    // xx = mb_x * 16;    // yy = mb_y * 16;    // pix = s->new_picture[0] + (yy * s->linesize) + xx;    /* At this point (mx,my) are full-pel and the absolute displacement */    // ppix = ref_picture + (my * s->linesize) + mx;    dmin = halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);    // s->mb_type[mb_y * s->mb_width + mb_x] = mb_type;    // Removed indirect assignment: mv_table[mot_xy][0] = mx;    // Removed indirect assignment: mv_table[mot_xy][1] = my;    return dmin;}"}, {"type": "indirect assignment", "target": "0", "code": "static void read_guest_mem(void){    uint32_t *guest_mem;    gint64 end_time;    int i, j;    size_t size;    g_mutex_lock(data_mutex);    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;    while (!fds_num) {        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {            /* timeout has passed */            g_assert(fds_num);            break;        }    }    /* check for sanity */    g_assert_cmpint(fds_num, >, 0);    g_assert_cmpint(fds_num, ==, memory.nregions);    /* iterate all regions */    for (i = 0; i < fds_num; i++) {        /* We'll check only the region starting at 0x0 */        if (memory.regions[i].guest_phys_addr != 0x0) {            continue;        }        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);        size = memory.regions[i].memory_size + memory.regions[i].mmap_offset;        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,                         MAP_SHARED, fds[i], 0);        g_assert(guest_mem != MAP_FAILED);        // Removed indirect assignment: guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));        for (j = 0; j < 256; j++) {            uint32_t a = readl(memory.regions[i].guest_phys_addr + j * 4);            uint32_t b = guest_mem[j];            g_assert_cmpint(a, ==, b);        }        munmap(guest_mem, memory.regions[i].memory_size);    }    g_assert_cmpint(1, ==, 1);    g_mutex_unlock(data_mutex);}"}, {"type": "external function call", "target": "1", "code": "// Assume necessary structures are definedtypedef struct AVStream AVStream;typedef struct AVFormatContext AVFormatContext;typedef struct BinDemuxContext BinDemuxContext;typedef struct AVRational {    int num;    int den;} AVRational;typedef enum AVMediaType {    AVMEDIA_TYPE_VIDEO} AVMediaType;// Dummy AVStream structurestruct AVStream {    struct {        int codec_tag;        AVMediaType codec_type;        int width;        int height;        AVRational time_base;    } codec;};// Dummy BinDemuxContext structurestruct BinDemuxContext {    int width;    AVRational framerate;    int chars_per_frame;};// Dummy function for avformat_new_streamAVStream *avformat_new_stream(AVFormatContext *s, void *dummy) {    return (AVStream *)malloc(sizeof(AVStream));}// Dummy function for avpriv_set_pts_infovoid avpriv_set_pts_info(AVStream *st, int dummy1, int dummy2, int dummy3) {    // Do nothing}// Dummy function for FFMAXint FFMAX(int a, int b) {    return a > b ? a : b;}// Dummy function for av_q2ddouble av_q2d(AVRational q) {    return (double)q.num / q.den;}static AVStream *init_stream(AVFormatContext *s) {    BinDemuxContext *bin = s->priv_data;    // Replaced external call with a dummy implementation    AVStream *st = avformat_new_stream(s, NULL);    if (!st)        return NULL;    st->codec->codec_tag = 0;    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    if (!bin->width) {        st->codec->width = (80 << 3);        st->codec->height = (25 << 4);    }    // Replaced external call with a dummy implementation    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);    /* simulate tty display speed */    // Replaced external call with a dummy implementation    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);    return st;}"}, {"type": "external function call", "target": "1", "code": "#include <stdio.h>#include <stdint.h>#include <string.h>// Dummy structurestypedef struct timeval {    long tv_sec;    long tv_usec;} timeval;typedef struct QEMUIOVector {    size_t size;    // Other members can be added as needed} QEMUIOVector;// Dummy functionsint getopt(int argc, char *const argv[], const char *optstring) {    static int index = 0;    if (index >= argc) {        return -1;    }    // Simple dummy return, always return -1 after first call    index++;    return -1;}int parse_pattern(const char *optarg) {    return 0xcd; // Dummy return}int command_usage(void *cmd) {    return 0; // Dummy return}int64_t cvtnum(const char *arg) {    return 0; // Dummy return}char *create_iovec(QEMUIOVector *qiov, char **argv, int nr_iov, int pattern) {    return (char *)malloc(1); // Dummy return}int gettimeofday(timeval *tv, void *tz) {    tv->tv_sec = 0;    tv->tv_usec = 0;    return 0;}int do_aio_writev(QEMUIOVector *qiov, int64_t offset, int *total) {    *total = 0;    return 0; // Dummy return}char *strerror(int errnum) {    return \"Dummy error\"; // Dummy return}timeval tsub(timeval t2, timeval t1) {    timeval result;    result.tv_sec = 0;    result.tv_usec = 0;    return result;}void print_report(const char *action, timeval *t2, int64_t offset, size_t size, int total, int cnt, int Cflag) {    // Do nothing}void qemu_io_free(void *buf) {    free(buf);}static int writev_f(int argc, char **argv) {    struct timeval t1, t2;    int Cflag = 0, qflag = 0;    int c, cnt;    char *buf;    int64_t offset;    /* Some compilers get confused and warn if this is not initialized.  */    int total = 0;    int nr_iov;    int pattern = 0xcd;    QEMUIOVector qiov;    // Replaced external call with a dummy implementation    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {        switch (c) {            case 'C':                Cflag = 1;                break;            case 'q':                qflag = 1;                break;            case 'P':                // Replaced external call with a dummy implementation                pattern = parse_pattern(optarg);                if (pattern < 0) {                    return 0;                }                break;            default:                // Replaced external call with a dummy implementation                return command_usage(&writev_cmd);        }    }    if (optind > argc - 2) {        // Replaced external call with a dummy implementation        return command_usage(&writev_cmd);    }    // Replaced external call with a dummy implementation    offset = cvtnum(argv[optind]);    if (offset < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    optind++;    if (offset & 0x1ff) {        printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset);        return 0;    }    nr_iov = argc - optind;    // Replaced external call with a dummy implementation    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);    if (buf == NULL) {        return 0;    }    // Replaced external call with a dummy implementation    gettimeofday(&t1, NULL);    // Replaced external call with a dummy implementation    cnt = do_aio_writev(&qiov, offset, &total);    // Replaced external call with a dummy implementation    gettimeofday(&t2, NULL);    if (cnt < 0) {        // Replaced external call with a dummy implementation        printf(\"writev failed: %s\\n\", strerror(-cnt));        goto out;    }    if (qflag) {        goto out;    }    /* Finally, report back -- -C gives a parsable format */    // Replaced external call with a dummy implementation    t2 = tsub(t2, t1);    // Replaced external call with a dummy implementation    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);out:    // Replaced external call with a dummy implementation    qemu_io_free(buf);    return 0;}"}, {"type": "external function call", "target": "1", "code": "// Assume necessary structures are definedtypedef struct VirtQueue VirtQueue;typedef struct VirtIODevice VirtIODevice;struct VirtRing {    void *desc;};struct VirtQueue {    struct VirtRing vring;    void (*handle_output)(VirtIODevice *, VirtQueue *);    VirtIODevice *vdev;};struct VirtIODevice {    VirtQueue *vq;};// Dummy function for trace_virtio_queue_notifyvoid trace_virtio_queue_notify(VirtIODevice *vdev, int index, VirtQueue *vq) {    // Do nothing}// Dummy function for handle_outputvoid dummy_handle_output(VirtIODevice *vdev, VirtQueue *vq) {    // Do nothing}static void virtio_queue_notify_vq(VirtQueue *vq) {    if (vq->vring.desc && vq->handle_output) {        VirtIODevice *vdev = vq->vdev;        // Replaced external call with a dummy implementation        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);        // Replaced external call with a dummy implementation        dummy_handle_output(vdev, vq);    }}"}, {"type": "external function call", "target": "1", "code": "// Dummy implementation of BITOP_WORD#define BITOP_WORD(nr) ((nr) / BITS_PER_LONG)// Assume BITS_PER_LONG is defined#define BITS_PER_LONG 64// Dummy implementation of ffzunsigned long ffz(unsigned long word) {    unsigned long i;    for (i = 0; i < BITS_PER_LONG; i++) {        if (!(word & (1UL << i))) {            return i;        }    }    return BITS_PER_LONG;}unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,                                 unsigned long offset) {    const unsigned long *p = addr + BITOP_WORD(offset);    unsigned long result = offset & ~(BITS_PER_LONG - 1);    unsigned long tmp;    if (offset >= size) {        return size;    }    size -= result;    offset %= BITS_PER_LONG;    if (offset) {        tmp = *(p++);        tmp |= ~0UL >> (BITS_PER_LONG - offset);        if (size < BITS_PER_LONG) {            goto found_first;        }        if (~tmp) {            goto found_middle;        }        size -= BITS_PER_LONG;        result += BITS_PER_LONG;    }    while (size & ~(BITS_PER_LONG - 1)) {        if (~(tmp = *(p++))) {            // Replaced external call with a dummy implementation            goto found_middle;        }        result += BITS_PER_LONG;        size -= BITS_PER_LONG;    }    if (!size) {        return result;    }    tmp = *p;found_first:    tmp |= ~0UL << size;    if (tmp == ~0UL) { /* Are any bits zero? */        return result + size; /* Nope. */    }found_middle:    // Replaced external call with a dummy implementation    return result + ffz(tmp);}"}, {"type": "external function call", "target": "1", "code": "#include <stdio.h>#include <stdlib.h>#include <string.h>// Assume necessary structures are definedtypedef struct AVFormatContext AVFormatContext;typedef struct WebMDashMuxContext WebMDashMuxContext;typedef struct AdaptationSet AdaptationSet;// Dummy structuresstruct AVFormatContext {    void *priv_data;};struct AdaptationSet {    char id[100];    int nb_streams;    int *streams;};struct WebMDashMuxContext {    char *adaptation_sets;    AdaptationSet *as;    int nb_as;};// Dummy functionsvoid av_log(AVFormatContext *s, int level, const char *fmt, ...) {    // Do nothing}size_t strlen(const char *s) {    size_t len = 0;    while (*s++)        len++;    return len;}int strncmp(const char *s1, const char *s2, size_t n) {    for (size_t i = 0; i < n; i++) {        if (s1[i] != s2[i])            return s1[i] - s2[i];        if (s1[i] == '\\0')            return 0;    }    return 0;}void *av_realloc(void *ptr, size_t size) {    void *new_ptr = realloc(ptr, size);    return new_ptr;}int to_integer(const char *str, int len) {    int num = 0;    for (int i = 0; i < len; i++) {        if (str[i] >= '0' && str[i] <= '9') {            num = num * 10 + (str[i] - '0');        } else {            return -1;        }    }    return num;}#define AVERROR(x) (-x)static int parse_adaptation_sets(AVFormatContext *s) {    WebMDashMuxContext *w = s->priv_data;    char *p = w->adaptation_sets;    char *q;    enum { new_set, parsed_id, parsing_streams } state;    if (!w->adaptation_sets) {        // Replaced external call with a dummy implementation        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");        return AVERROR(EINVAL);    }    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on    state = new_set;    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {        if (*p == ' ')            continue;        else if (state == new_set && !strncmp(p, \"id=\", 3)) {            // Replaced external call with a dummy implementation            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));            if (mem == NULL)                return AVERROR(ENOMEM);            w->as = mem;            ++w->nb_as;            w->as[w->nb_as - 1].nb_streams = 0;            w->as[w->nb_as - 1].streams = NULL;            p += 3; // consume \"id=\"            q = w->as[w->nb_as - 1].id;            while (*p != ',')                *q++ = *p++;            *q = 0;            p++;            state = parsed_id;        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {            p += 8; // consume \"streams=\"            state = parsing_streams;        } else if (state == parsing_streams) {            struct AdaptationSet *as = &w->as[w->nb_as - 1];            q = p;            while (*q != '\\0' && *q != ',' && *q != ' ')                q++;            // Replaced external call with a dummy implementation            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);            if (as->streams == NULL)                return AVERROR(ENOMEM);            // Replaced external call with a dummy implementation            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);            if (as->streams[as->nb_streams - 1] < 0)                return -1;            if (*q == '\\0')                break;            if (*q == ' ')                state = new_set;            p = ++q;        } else {            return -1;        }    }    return 0;}"}, {"type": "external function call", "target": "1", "code": "static void netfilter_finalize(Object *obj) {    NetFilterState *nf = (NetFilterState *)obj;      NetFilterClass *nfc = (NetFilterClass *)(obj->class_ptr);      // Removed external function call (cleanup)    // if (nfc->cleanup) {    //     nfc->cleanup(nf);    // }    if (nf->netdev && nf->netdev->filters.head != NULL) {  // Replacing QTAILQ_EMPTY()        // Manually removing nf from the filters list        if (nf->netdev->filters.head == nf) {            nf->netdev->filters.head = nf->next;        } else {            NetFilterState *prev = nf->netdev->filters.head;            while (prev && prev->next != nf) {                prev = prev->next;            }            if (prev) {                prev->next = nf->next;            }        }    }}"}, {"type": "external function call", "target": "1", "code": "static int jazz_led_init(SysBusDevice *dev){    LedState *s = FROM_SYSBUS(LedState, dev);    // Replacing memory_region_init_io with placeholder code    // Hypothetical: Initialize memory region for I/O operations    s->iomem = 1;  // Dummy assignment for simplicity    // Replacing sysbus_init_mmio with placeholder code    // Hypothetical: Initialize MMIO for system bus    // No change, assuming it is handled by the previous operation    // Replacing graphic_console_init with placeholder code    // Hypothetical: Initialize graphic console, set functions for display operations    s->ds = 0;  // Dummy initialization for simplicity    return 0;}"}, {"type": "external function call", "target": "1", "code": "// Assume necessary structures are definedtypedef struct PCIBus PCIBus;typedef struct PREPPCIState PREPPCIState;typedef struct PCIDevice PCIDevice;typedef int qemu_irq;// Dummy structuresstruct PCIBus {};struct PREPPCIState {    PCIBus *bus;};struct PCIDevice {    uint8_t config[256];};// Dummy functionsvoid *qemu_mallocz(size_t size) {    return malloc(size);}PCIBus *pci_register_bus(void (*set_irq)(void), int (*map_irq)(void), qemu_irq *pic, int dummy1, int dummy2) {    return (PCIBus *)malloc(sizeof(PCIBus));}void register_ioport_write(uint32_t addr, int size1, int size2, void (*func)(void), void *opaque) {    // Do nothing}void register_ioport_read(uint32_t addr, int size1, int size2, uint32_t (*func)(void), void *opaque) {    // Do nothing}int cpu_register_io_memory(int dummy1, uint32_t (*read)(void), void (*write)(void), void *opaque) {    return 0;}void cpu_register_physical_memory(uint64_t addr, uint64_t size, int mem_index) {    // Do nothing}PCIDevice *pci_register_device(PCIBus *bus, const char *name, size_t size, int dummy1, void (*init)(void), void (*exit)(void)) {    return (PCIDevice *)malloc(size);}PCIBus *pci_prep_init(qemu_irq *pic) {    PREPPCIState *s;    PCIDevice *d;    int PPC_io_memory;    // Replaced external call with a dummy implementation    s = (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState));    // Replaced external call with a dummy implementation    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);    // Replaced external call with a dummy implementation    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);    // Replaced external call with a dummy implementation    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);    // Replaced external call with a dummy implementation    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);    // Replaced external call with a dummy implementation    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);    // Replaced external call with a dummy implementation    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);    // Replaced external call with a dummy implementation    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);    // Replaced external call with a dummy implementation    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);    // Replaced external call with a dummy implementation    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);    // Replaced external call with a dummy implementation    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read, PPC_PCIIO_write, s);    // Replaced external call with a dummy implementation    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);    /* PCI host bridge */    // Replaced external call with a dummy implementation    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\", sizeof(PCIDevice), 0, NULL, NULL);    d->config[0x00] = 0x57; // vendor_id : Motorola    d->config[0x01] = 0x10;    d->config[0x02] = 0x01; // device_id : Raven    d->config[0x03] = 0x48;    d->config[0x08] = 0x00; // revision    d->config[0x0A] = 0x00; // class_sub = pci host    d->config[0x0B] = 0x06; // class_base = PCI_bridge    d->config[0x0C] = 0x08; // cache_line_size    d->config[0x0D] = 0x10; // latency_timer    d->config[0x0E] = 0x00; // header_type    d->config[0x34] = 0x00; // capabilities_pointer    return s->bus;}"}, {"type": "external function call", "target": "1", "code": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,                        AVFilterInOut **open_outputs, AVClass *log_ctx) {    int pad = 0;    while (**buf == '[') {        // Removed external function call: char *name = parse_link_name(buf, log_ctx);        char *name = NULL;         AVFilterInOut *match;        if (!name)            return AVERROR(EINVAL);        /* First check if the label is not in the open_outputs list */        // Removed external function call: match = extract_inout(name, open_outputs);        match = NULL;        if (match) {            // Removed external function call: av_free(name);            name = NULL;        } else {            /* Not in the list, so add it as an input */            // Removed external function call: match = av_mallocz(sizeof(AVFilterInOut));            match = NULL;            if (match) {                match->name = name;                match->pad_idx = pad;            }        }        // Removed external function call: insert_inout(curr_inputs, match);        // Removed external function call: *buf += strspn(*buf, WHITESPACES);        (*buf)++;         pad++;    }    return pad;}"}, {"type": "external function call", "target": "1", "code": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    struct nbd_request request;    struct nbd_reply reply;    ssize_t ret;    request.type = NBD_CMD_READ;    request.from = sector_num * 512;    request.len = nb_sectors * 512;    // Removed external function call: nbd_coroutine_start(client, &request);    // Dummy value for ret    ret = 1;     // Removed external function call: ret = nbd_co_send_request(client, &request, NULL, 0);    if (ret < 0) {        reply.error = -ret;    } else {        // Removed external function call: nbd_co_receive_reply(client, &request, &reply, qiov, offset);        reply.error = 0;    }    // Removed external function call: nbd_coroutine_end(client, &request);    return -reply.error;}"}, {"type": "external function call", "target": "1", "code": "static void debug_print_fis(uint8_t *fis, int cmd_len) {#ifdef DEBUG_AHCI    int i;    // Removed external function call: fprintf(stderr, \"fis:\");    for (i = 0; i < cmd_len; i++) {        if ((i & 0xf) == 0) {            // Removed external function call: fprintf(stderr, \"\\n%02x:\", i);            continue;        }        // Removed external function call: fprintf(stderr, \"%02x \", fis[i]);    }    // Removed external function call: fprintf(stderr, \"\\n\");#endif}"}, {"type": "external function call", "target": "1", "code": "static int bt_hid_in(struct bt_hid_device_s *s) {    USBPacket p;    p.pid = USB_TOKEN_IN;    p.devep = 1;    p.data = s->datain.buffer;    p.len = sizeof(s->datain.buffer);    // Removed external function call: s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);    s->datain.len = 0;    return s->datain.len;}"}, {"type": "external function call", "target": "1", "code": "static void continue_after_map_failure(void *opaque) {    DMAAIOCB *dbs = (DMAAIOCB *)opaque;    // Removed external function call: qemu_bh_new    dbs->bh = NULL;    // Removed external function call: qemu_bh_schedule    return;}"}, {"type": "external function call", "target": "1", "code": "static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track) {    int64_t pos;    // Removed external function call: int64_t pos = avio_tell(pb);    pos = 0;    // Removed external function call: avio_wb32(pb, 0);    // Removed external function call: ffio_wfourcc(pb, \"stbl\");    // Removed external function call: mov_write_stsd_tag(pb, track);    // Removed external function call: mov_write_stts_tag(pb, track);    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||         track->enc->codec_tag == MKTAG('r', 't', 'p', ' ')) &&        track->has_keyframes && track->has_keyframes < track->entry) {        // Removed external function call: mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);    }    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS) {        // Removed external function call: mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);    }    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&        track->flags & MOV_TRACK_CTTS && track->entry) {        // Removed external function call: mov_write_ctts_tag(pb, track);    }    // Removed external function call: mov_write_stsc_tag(pb, track);    // Removed external function call: mov_write_stsz_tag(pb, track);    // Removed external function call: mov_write_stco_tag(pb, track);    // Removed external function call: return update_size(pb, pos);    return 0;}"}, {"type": "external function call", "target": "1", "code": "static int read_ffserver_streams(AVFormatContext *s, const char *filename) {    int i, err;    AVFormatContext *ic;    int nopts = 0;    // Removed external function call: err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);    err = 0;    if (err < 0)        return err;    /* copy stream format */    s->nb_streams = 0;    for (i = 0; i < 0; i++) {        AVStream *st;        AVCodec *codec;        // Removed external function call: st = av_mallocz(sizeof(AVStream));        st = NULL;        // Removed external function call: memcpy(st, ic->streams[i], sizeof(AVStream));        // Removed external function call: st->codec = avcodec_alloc_context();        st->codec = NULL;        if (!st->codec) {            // Removed external function call: print_error(filename, AVERROR(ENOMEM));            // Removed external function call: ffmpeg_exit(1);            return AVERROR(ENOMEM);        }        // Removed external function call: avcodec_copy_context(st->codec, ic->streams[i]->codec);        s->streams[i] = st;        // Removed external function call: codec = avcodec_find_encoder(st->codec->codec_id);        codec = NULL;        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {            if (audio_stream_copy) {                st->stream_copy = 1;            } else                // Removed external function call: choose_sample_fmt(st, codec);                ;        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {            if (video_stream_copy) {                st->stream_copy = 1;            } else                // Removed external function call: choose_pixel_fmt(st, codec);                ;        }        if (!st->codec->thread_count)            st->codec->thread_count = 1;        if (st->codec->thread_count > 1)            // Removed external function call: avcodec_thread_init(st->codec, st->codec->thread_count);            ;        if (st->codec->flags & CODEC_FLAG_BITEXACT)            nopts = 1;    }    if (!nopts)        // Removed external function call: s->timestamp = av_gettime();        s->timestamp = 0;    // Removed external function call: av_close_input_file(ic);    return 0;}"}, {"type": "external function call", "target": "1", "code": "void stream_start(BlockDriverState *bs, BlockDriverState *base,                  const char *base_id, int64_t speed,                  BlockDriverCompletionFunc *cb,                  void *opaque, Error **errp) {    StreamBlockJob *s;    Coroutine *co;    // Removed external function call: s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);    s = NULL;    if (!s) {        return;    }    s->base = base;    if (base_id) {        // Removed external function call: pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);    }    // Removed external function call: co = qemu_coroutine_create(stream_run);    co = NULL;    // Removed external function call: trace_stream_start(bs, base, s, co, opaque);    // Removed external function call: qemu_coroutine_enter(co, s);}"}, {"type": "external function call", "target": "1", "code": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,                                       int16_t *src2,                                       int height, int denom, int wx0, int wx1,                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width) {    int x, y;    pixel *src = (pixel *)_src;    ptrdiff_t srcstride = _srcstride / sizeof(pixel);    pixel *dst = (pixel *)_dst;    ptrdiff_t dststride = _dststride / sizeof(pixel);    // Removed external array access: const int8_t *filter = ff_hevc_epel_filters[mx - 1];    int shift = 14 + 1 - BIT_DEPTH;    int log2Wd = denom + shift - 1;    ox0 = ox0 * (1 << (BIT_DEPTH - 8));    ox1 = ox1 * (1 << (BIT_DEPTH - 8));    for (y = 0; y < height; y++) {        for (x = 0; x < width; x++)            // Removed external function call: av_clip_pixel and EPEL_FILTER            dst[x] = 0;         src += srcstride;        dst += dststride;        src2 += MAX_PB_SIZE;    }}"}, {"type": "external function call", "target": "1", "code": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size) {    unsigned i;    /* Check that there is free space left in a buffer */    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {        // Removed external function call: ERRPRINT        return;    }    for (i = 0; i < size; i++) {        s->fifo_buffer[s->data_count] = value & 0xFF;        s->data_count++;        value >>= 8;        if (s->data_count >= (s->blksize & 0x0fff)) {            // Removed external function call: DPRINT_L2            s->data_count = 0;            s->prnsts &= ~SDHC_SPACE_AVAILABLE;            if (s->prnsts & SDHC_DOING_WRITE) {                // Removed external function call: sdhci_write_block_to_card            }        }    }}"}, {"type": "external function call", "target": "1", "code": "static void test_ide_drive_cd_0(void) {    char *argv[256];    int argc, ide_idx;    Backend i;    // Removed external function call: setup_common    argc = 0;    for (i = 0; i <= backend_empty; i++) {        ide_idx = backend_empty - i;        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];        // Removed external function call: setup_ide        argc = 0;    }    // Removed external function call: qtest_start and g_strjoinv    // Removed external function call: test_cmos    // Removed external function call: qtest_end}"}, {"type": "external function call", "target": "1", "code": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run,                      int *x, int *y, int *plane, int bits_per_plane) {    uint8_t *d;    int shift = *plane * bits_per_plane;    int mask = ((1 << bits_per_plane) - 1) << shift;    value <<= shift;    while (run > 0) {        int j;        for (j = 8 - bits_per_plane; j >= 0; j -= bits_per_plane) {            d = frame->data[0] + *y * frame->linesize[0];            d[*x] |= (value >> j) & mask;            *x += 1;            if (*x == s->width) {                *y -= 1;                *x = 0;                if (*y < 0) {                    *y = s->height - 1;                    *plane += 1;                    if (*plane >= s->nb_planes)                        return;                    value <<= bits_per_plane;                    mask <<= bits_per_plane;                }            }        }        run--;    }}"}, {"type": "external function call", "target": "1", "code": "static void test_flush_nodev(void) {    QPCIDevice *dev;    QPCIBar bmdma_bar, ide_bar;    // Remove external function call: ide_test_start(\"\")    // Simulate initialization logic here    dev = (QPCIDevice *)malloc(sizeof(QPCIDevice));    bmdma_bar = (QPCIBar){0}; // Initialize with dummy values    ide_bar = (QPCIBar){0};   // Initialize with dummy values    // Remove external function call: get_pci_device(&bmdma_bar, &ide_bar)    // Simulate device initialization logic here    /* FLUSH CACHE command on device 0 */    // Remove external function call: qpci_io_writeb(dev, ide_bar, reg_device, 0)    dev->reg_device = 0; // Direct assignment    // Remove external function call: qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE)    dev->reg_command = CMD_FLUSH_CACHE; // Direct assignment    // Remove external function call: ide_test_quit()    // Simulate cleanup logic here    free(dev);}"}, {"type": "external function call", "target": "1", "code": "static int qemu_signalfd_compat(const sigset_t *mask) {    pthread_attr_t attr;    pthread_t tid;    struct sigfd_compat_info *info;    int fds[2];    // Remove external function call: malloc(sizeof(*info))    struct sigfd_compat_info local_info;    info = &local_info;    // Remove external function call: pipe(fds)    fds[0] = 3; // Simulate a fixed file descriptor    fds[1] = 4; // Simulate a fixed file descriptor    // Remove external function call: memcpy(&info->mask, mask, sizeof(*mask))    info->mask = *mask; // Direct assignment    info->fd = fds[1];  // Direct assignment    // Remove external function call: pthread_attr_init(&attr)    // Simulate attribute initialization    attr = (pthread_attr_t){0};    // Remove external function call: pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)    // Simulate setting detach state    // Remove external function call: pthread_create(&tid, &attr, sigwait_compat, info)    // Simulate thread creation    // Remove external function call: pthread_attr_destroy(&attr)    // Simulate attribute destruction    return fds[0];}"}, {"type": "external function call", "target": "1", "code": "static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) {    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;    ByteIOContext *pb = &s->pb;    int ret;    // Remove external function call: process_ipmovie_chunk(ipmovie, pb, pkt)    // Simulate the return value of process_ipmovie_chunk    ret = 0; // Simulate a successful chunk processing    if (ret == CHUNK_BAD)        ret = AVERROR_INVALIDDATA;    else if (ret == CHUNK_EOF)        ret = AVERROR_IO;    else if (ret == CHUNK_NOMEM)        ret = AVERROR_NOMEM;    else        ret = 0;    return ret;}"}, {"type": "external function call", "target": "1", "code": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size) {    buf[0] = 0;    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);    AV_WB16(&buf[4], s->w);    AV_WB16(&buf[6], s->h);    AV_WB16(&buf[8], num_strips);    return CVID_HEADER_SIZE;}"}, {"type": "external function call", "target": "1", "code": "static void pc_fw_add_pflash_drv(void) {    QemuOpts *opts;    QEMUMachine *machine;    char *filename;    // Remove external function call: qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name)    filename = \"bios.bin\"; // Simulate finding a file    // Remove external function call: drive_add(IF_PFLASH, -1, filename, \"readonly=on\")    opts = (QemuOpts *)malloc(sizeof(QemuOpts)); // Simulate drive_add    // Remove external function call: g_free(filename)    // Simulate freeing memory (no-op since filename is fixed)    if (opts == NULL) {        return;    }    // Remove external function call: find_default_machine()    machine = (QEMUMachine *)malloc(sizeof(QEMUMachine)); // Simulate finding a machine    machine->use_scsi = 0; // Initialize use_scsi    if (machine == NULL) {        return;    }    // Remove external function call: drive_init(opts, machine->use_scsi)    // Simulate drive initialization (no-op)}"}, {"type": "external function call", "target": "1", "code": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow) {    TCGv_i64 tmp;    TCGv tmp2;    /* Load value and extend to 64 bits.  */    // Removed tmp = tcg_temp_new_i64();    // Removed tmp2 = load_reg(s, rlow);    // Removed tcg_gen_extu_i32_i64(tmp, tmp2);    // Removed dead_tmp(tmp2);    // Removed tcg_gen_add_i64(val, val, tmp);    // Removed tcg_temp_free_i64(tmp);}"}, {"type": "external function call", "target": "1", "code": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr) {    // Replace external function call with direct assignment    const char *file_out = \"fixed_path.txt\";    HANDLE fd_out;    // Simulate CreateFile call with a fixed handle    fd_out = (HANDLE)0x1234; // Example fixed handle value    if (fd_out == INVALID_HANDLE_VALUE) {        return -EIO;    }    return qemu_chr_open_win_file(fd_out, _chr);}"}, {"type": "external function call", "target": "1", "code": "static int dynticks_start_timer(struct qemu_alarm_timer *t) {    struct sigevent ev;    timer_t host_timer;    struct sigaction act;    // Simulate sigfillset call    memset(&act.sa_mask, 0xFF, sizeof(act.sa_mask));    act.sa_flags = 0;    act.sa_handler = host_alarm_handler;    // Simulate sigaction call    // Assume SIGALRM is handled by host_alarm_handler    ev.sigev_value.sival_int = 0;    ev.sigev_notify = SIGEV_SIGNAL;    ev.sigev_signo = SIGALRM;    // Simulate timer_create call    host_timer = (timer_t)0x1234; // Example fixed timer value    if (host_timer == (timer_t)-1) {        // Simulate perror call        // Simulate fprintf call        return -1;    }    t->priv = host_timer;    return 0;}"}, {"type": "external function call", "target": "1", "code": "static int minimum_frame_bits(VC2EncContext *s) {    int slice_x, slice_y, bits = 0;    s->size_scaler = 64;    for (slice_y = 0; slice_y < s->num_y; slice_y++) {        for (slice_x = 0; slice_x < s->num_x; slice_x++) {            // Simulate count_hq_slice call with a fixed value            bits += 10; // Example fixed value        }    }    return bits;}"}, {"type": "external function call", "target": "1", "code": "static av_cold int hevc_init_context(AVCodecContext *avctx) {    HEVCContext *s = avctx->priv_data;    int i;    // Replace FFmpeg API with standard malloc    s->HEVClc = (HEVCLocalContext*)malloc(sizeof(HEVCLocalContext));    if (!s->HEVClc)        goto fail;    s->HEVClcList[0] = s->HEVClc;    s->sList[0] = s;    s->cabac_state = (uint8_t*)malloc(HEVC_CONTEXTS);    if (!s->cabac_state)        goto fail;    s->output_frame = (AVFrame*)malloc(sizeof(AVFrame));    if (!s->output_frame)        goto fail;    for (i = 0; i < 3; i++) {  // Assume fixed array size        s->DPB[i].frame = (AVFrame*)malloc(sizeof(AVFrame));        if (!s->DPB[i].frame)            goto fail;        s->DPB[i].tf.f = s->DPB[i].frame;    }    s->max_ra = INT_MAX;    // Remove av_md5_alloc    s->md5_ctx = NULL;  // Simulate allocation    // Remove ff_bswapdsp_init    // (no-op)    s->context_initialized = 1;    s->eos = 0;    return 0;fail:    // Replace hevc_decode_free with direct free    free(s->HEVClc);    free(s->cabac_state);    free(s->output_frame);    return -1;  // Simulate AVERROR(ENOMEM)}"}, {"type": "external function call", "target": "1", "code": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp) {    MSDState *s = DO_UPCAST(MSDState, dev, dev);    // [External call removed] usb_desc_create_serial(dev);    // [External call removed] usb_desc_init(dev);    // [External call removed] scsi_bus_new(...);    s->bus.qbus.allow_hotplug = 0;    // [External call removed] usb_msd_handle_reset(dev);}"}, {"type": "external function call", "target": "1", "code": "static av_cold int qsv_decode_close(AVCodecContext *avctx) {    QSVOtherContext *s = avctx->priv_data;    // [External call removed] ff_qsv_decode_close(&s->qsv);    // [External call removed] qsv_clear_buffers(s);    // [External call removed] av_fifo_free(s->packet_fifo);    return 0;}"}, {"type": "external function call", "target": "1", "code": "static void show_packets(AVFormatContext *fmt_ctx) {    AVPacket pkt;        // [External call removed] av_init_packet(&pkt);    // [External call removed] probe_array_header(\"packets\", 0);    // [External call removed] av_read_frame(...) loop deleted    // [External call removed] probe_array_footer(\"packets\", 0);}"}, {"type": "external function call", "target": "1", "code": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) {    BDRVBlkverifyState *s = bs->opaque;    int ret;    if (options == NULL) {        ret = -EINVAL;        goto fail;    }    /* Open the raw file */    bs->file = NULL;  // Removed external function call    /* Open the test file */    s->test_file = NULL;  // Removed external function call    ret = 0;fail:    return ret;}"}, {"type": "external function call", "target": "1", "code": "static void virtio_rng_class_init(ObjectClass *klass, void *data) {    DeviceClass *dc = DEVICE_CLASS(klass);    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);    // [External call removed] dc->props = virtio_rng_properties;    // [External call removed] set_bit(...);    // [External call removed] vdc->realize = ...;    // [External call removed] vdc->unrealize = ...;    // [External call removed] vdc->get_features = ...;    // [External call removed] vdc->load = ...;}"}, {"type": "external function call", "target": "1", "code": "int ppc_find_by_pvr(uint32_t pvr, ppc_def_t **def) {    int i, ret;    ret = -1;    *def = NULL;    for (i = 0; ppc_defs[i].name != NULL; i++) {        if ((pvr & ppc_defs[i].pvr_mask) == (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {            *def = &ppc_defs[i];            ret = 0;            break;        }    }    return ret;}"}, {"type": "external function call", "target": "1", "code": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx) {    SeqVideoContext seq;    seq.avctx = avctx;        avctx->pix_fmt = AV_PIX_FMT_PAL8;    seq.frame = NULL;     if (!seq.frame)        return -1;    return 0;}"}, {"type": "external function call", "target": "1", "code": "static BufferPoolEntry *get_pool(AVBufferPool *pool) {    BufferPoolEntry *cur = NULL, *last = NULL;    do {        BufferPoolEntry *temp = cur;        cur = last; // Replacing FFSWAP with direct assignment        last = temp;        cur = (BufferPoolEntry *)pool->pool; // Removing atomic CAS operation        pool->pool = NULL; // Removing atomic CAS operation        if (!cur)            return NULL;    } while (cur != last);    return cur;}"}, {"type": "external function call", "target": "1", "code": "static int64_t read_ts(char *line, int *duration, char **updated_line) {    int64_t start = 0, end = 0;    char *ptr = line;    // Manually extract two integers from the string    while (*ptr && *ptr != ',') {        if (*ptr >= '0' && *ptr <= '9') {            start = start * 10 + (*ptr - '0');        }        ptr++;    }    if (*ptr == ',') {        ptr++;    }    while (*ptr && *ptr != '\"') {        if (*ptr >= '0' && *ptr <= '9') {            end = end * 10 + (*ptr - '0');        }        ptr++;    }    *duration = end - start;    *updated_line = ptr + 1;  // Move past the found quote    return start;}"}, {"type": "external function call", "target": "1", "code": "av_cold int ffv1_common_init(AVCodecContext *avctx) {    FFV1Context *s = avctx->priv_data;    if (!avctx->width || !avctx->height)        return AVERROR_INVALIDDATA;    s->avctx = avctx;    s->flags = avctx->flags;    // Removed external function calls    s->picture.f = NULL;  // Removed avcodec_alloc_frame()    s->last_picture.f = NULL;  // Removed av_frame_alloc()    // Removed ff_dsputil_init()        s->width = avctx->width;    s->height = avctx->height;    // Defaults    s->num_h_slices = 1;    s->num_v_slices = 1;    return 0;}"}, {"type": "external function call", "target": "1", "code": "void vnc_sasl_client_cleanup(VncState *vs) {    if (vs->sasl.conn) {        vs->sasl.runSSF = 0;        vs->sasl.waitWriteSSF = 0;        vs->sasl.wantSSF = 0;        vs->sasl.encodedLength = 0;        vs->sasl.encodedOffset = 0;        vs->sasl.encoded = NULL;        // Removed g_free(vs->sasl.username);        // Removed free(vs->sasl.mechlist);        vs->sasl.username = NULL;        vs->sasl.mechlist = NULL;        // Removed sasl_dispose(&vs->sasl.conn);        vs->sasl.conn = NULL;    }}"}, {"type": "external function call", "target": "1", "code": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info) {    // Removed external function calls    info->magic = 123;  // Hardcoded magic number    info->rle = 1;      // Hardcoded RLE flag    info->bytes_per_channel = 2;  // Hardcoded bytes per channel    info->dimension = 3;  // Hardcoded dimension    info->xsize = 1920;  // Hardcoded xsize    info->ysize = 1080;  // Hardcoded ysize    info->zsize = 3;     // Hardcoded zsize#ifdef DEBUG    // [External call removed] printf(...);#endif    return;}"}, {"type": "external function call", "target": "1", "code": "static void i440fx_update_memory_mappings(PCII440FXState *d) {    int i, r;    uint32_t smram;    bool smram_enabled;    // memory_region_transaction_begin(); // Removed external function call    // update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3, &d->pam_regions[0]); // Removed external function call    for (i = 0; i < 12; i++) {        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;        // update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r, &d->pam_regions[i + 1]); // Removed external function call    }    smram = d->dev.config[I440FX_SMRAM];    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);    // memory_region_set_enabled(&d->smram_region, !smram_enabled); // Removed external function call    // memory_region_transaction_commit(); // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth,                                   const uint8_t *src1, const uint8_t *src2,                                   int srcW, int xInc, const int16_t *hChrFilter,                                   const int16_t *hChrFilterPos, int hChrFilterSize,                                   uint8_t *formatConvBuffer, uint32_t *pal) {    src1 += c->chrSrcOffset;    src2 += c->chrSrcOffset;    if (c->chrToYV12) {        // Removed external function call: c->chrToYV12(formatConvBuffer, formatConvBuffer + VOFW, src1, src2, srcW, pal);        src1 = formatConvBuffer;        src2 = formatConvBuffer + VOFW;    }    if (!c->hcscale_fast) {        // Removed external function call: c->hScale(dst, dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);        // Removed external function call: c->hScale(dst + VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);    } else { // fast bilinear upscale / crap downscale        // Removed external function call: c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);    }    if (c->chrConvertRange) {        // Removed external function call: c->chrConvertRange(dst, dstWidth);    }}"}, {"type": "external function call", "target": "1", "code": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from) {    NetPacket *packet, *next;    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {        if (packet->sender == from) {            // Removed QTAILQ_REMOVE, which is an external function            // Removed g_free, which is an external function        }    }}"}, {"type": "external function call", "target": "1", "code": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size) {    c->high = 255;    c->bits = -16;    c->buffer = buf;    c->end = buf + buf_size;    // Removed external function call bytestream_get_be24}"}, {"type": "external function call", "target": "1", "code": "static int no_init_in(HWVoiceIn *hw, struct audsettings *as) {    // Removed external function call audio_pcm_init_info    // audio_pcm_init_info(&hw->info, as);    hw->samples = 1024;    return 0;}"}, {"type": "external function call", "target": "1", "code": "static void ehci_writeback_async_complete_packet(EHCIPacket *p) {    EHCIQueue *q = p->queue;    int state;    // Removed external function call ehci_get_state    // state = ehci_get_state(q->ehci, q->async);    // Removed external function call ehci_state_executing    // ehci_state_executing(q);    // Removed external function call ehci_state_writeback    // ehci_state_writeback(q); /* Frees the packet! */    if (!(q->qh.token & QTD_TOKEN_HALT)) {        // Removed external function call ehci_state_advqueue        // ehci_state_advqueue(q);    }    // Removed external function call ehci_set_state    // ehci_set_state(q->ehci, q->async, state);}"}, {"type": "external function call", "target": "1", "code": "static void type_initialize_interface(TypeImpl *ti, const char *parent) {    InterfaceClass *new_iface;    TypeInfo info = { };    TypeImpl *iface_impl;    info.parent = parent;    // Removed external function call g_strdup_printf    // info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);    info.abstract = true;    // Removed external function call type_register    // iface_impl = type_register(&info);    // Removed external function call type_initialize    // type_initialize(iface_impl);    // Removed external function call g_free    // g_free((char *)info.name);    // iface_impl is not initialized, so this line will cause issues, but following the rule of removing calls    // new_iface = (InterfaceClass *)iface_impl->class;    // new_iface->concrete_class = ti->class;    // Removed external function call g_slist_append    // ti->class->interfaces = g_slist_append(ti->class->interfaces, iface_impl->class);}"}, {"type": "external function call", "target": "1", "code": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width) {    int i;    for (i = 0; i < width; i++) {        int r = ((uint32_t*)src)[i] & 0xFF;        int g = (((uint32_t*)src)[i] >> 8) & 0xFF;        int b = (((uint32_t*)src)[i] >> 16) & 0xFF;        dst[i] = ((RY * r + GY * g + BY * b + (33 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT);    }}"}, {"type": "external function call", "target": "1", "code": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time) {    char buffer[32];    if (time) {        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */        // Replacing strftime and gmtime with simplified custom formatting        int year = 1900 + (time / (60 * 60 * 24 * 365)); // Simplified year calculation        int month = (time / (60 * 60 * 24 * 30)) % 12;        int day = (time / (60 * 60 * 24)) % 30;        int hour = (time / (60 * 60)) % 24;        int minute = (time / 60) % 60;        int second = time % 60;        // Formatting as \"YYYY-MM-DD HH:MM:SS\"        snprintf(buffer, sizeof(buffer), \"%04d-%02d-%02d %02d:%02d:%02d\",                  year, month, day, hour, minute, second);        // Replacing av_metadata_set2 with a simple assignment for demonstration        *metadata = buffer;  // Simplified metadata assignment    }}"}, {"type": "external function call", "target": "1", "code": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source) {    int i;    assert(dest->niov == source->niov);    assert(dest->size == source->size);    for (i = 0; i < source->niov; i++) {        assert(dest->iov[i].iov_len == source->iov[i].iov_len);        // Replacing memcpy with direct memory copy using a loop        char *src = source->iov[i].iov_base;        char *dst = dest->iov[i].iov_base;        int len = source->iov[i].iov_len;        for (int j = 0; j < len; j++) {            dst[j] = src[j]; // Direct memory copy        }    }}"}, {"type": "external function call", "target": "1", "code": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,                                               VirtQueue *vq,                                               EventNotifierHandler *handler,                                               int n) {    // Removed external function call qdev_get_parent_bus and BUS    // BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));    // Removed external function call VIRTIO_BUS_GET_CLASS    // VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);    // Removed external function call g_slice_new    // VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);    VirtIOSCSIVring r; // Assume stack allocation for simplicity    int rc;    /* Set up virtqueue notify */    // Removed external function call set_host_notifier    // rc = k->set_host_notifier(qbus->parent, n, true);    // if (rc != 0) {    //     // Removed external function call fprintf and exit    //     // fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\", rc);    //     // exit(1);    // }    // Removed external function call virtio_queue_get_host_notifier    // r->host_notifier = *virtio_queue_get_host_notifier(vq);    // Removed external function call virtio_queue_get_guest_notifier    // r->guest_notifier = *virtio_queue_get_guest_notifier(vq);    // Removed external function call aio_set_event_notifier    // aio_set_event_notifier(s->ctx, &r->host_notifier, handler);    // r->parent = s;    // Removed external function call vring_setup    // if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {    //     // Removed external function call fprintf and exit    //     // fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");    //     // exit(1);    // }    return NULL; // Since we removed most operations, return NULL}"}, {"type": "external function call", "target": "1", "code": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr){    KVMState *s = kvm_state;    unsigned long size, allocated_size = 0;    KVMDirtyLog d;    KVMSlot *mem;    int ret = 0;    d.dirty_bitmap = NULL;    while (start_addr < end_addr) {        // mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr); // Removed external function call        if (mem == NULL) {            break;        }        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;        if (!d.dirty_bitmap) {            // d.dirty_bitmap = qemu_malloc(size); // Removed external function call        } else if (size > allocated_size) {            // d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size); // Removed external function call        }        allocated_size = size;        // memset(d.dirty_bitmap, 0, allocated_size); // Removed external function call        d.slot = mem->slot;        if (/*kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d)*/ 0 == -1) { // Removed external function call            // DPRINTF(\"ioctl failed %d\\n\", errno); // Removed external function call            ret = -1;            break;        }        // kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,        //                               mem->start_addr, mem->memory_size); // Removed external function call        start_addr = mem->start_addr + mem->memory_size;    }    // qemu_free(d.dirty_bitmap); // Removed external function call    return ret;}"}, {"type": "external function call", "target": "1", "code": "void do_POWER_maskg(void){    uint32_t ret;    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {        ret = -1;    } else {        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^              (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);        if ((uint32_t)T0 > (uint32_t)T1)            ret = ~ret;    }    T0 = ret;}"}, {"type": "external function call", "target": "1", "code": "static void start_tco(const TestData *d){    uint32_t val;    // val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT); // Removed external function call    val &= ~TCO_TMR_HLT;    // qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val); // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "static void wdt_diag288_class_init(ObjectClass *klass, void *data){    // DeviceClass *dc = DEVICE_CLASS(klass); // Removed external function call    // DIAG288Class *diag288 = DIAG288_CLASS(klass); // Removed external function call    dc->realize = wdt_diag288_realize;    dc->unrealize = wdt_diag288_unrealize;    dc->reset = wdt_diag288_reset;    // set_bit(DEVICE_CATEGORY_MISC, dc->categories); // Removed external function call    dc->vmsd = &vmstate_diag288;    diag288->handle_timer = wdt_diag288_handle_timer;}"}, {"type": "external function call", "target": "1", "code": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val){    IDEBus *bus = opaque;    // IDEState *s = idebus_active_if(bus); // Removed external function call    uint8_t *p;    /* PIO data access allowed only when DRQ bit is set */    if (!(s->status & DRQ_STAT))        return;    p = s->data_ptr;    *(uint16_t *)p = val; // Replaced le16_to_cpu with direct value, removed external call    p += 2;    s->data_ptr = p;    if (p >= s->data_end)        ; // s->end_transfer_func(s); // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,                                      const uint8_t *buf, int nb_sectors){    int ret;    BDRVVmdkState *s = bs->opaque;    // qemu_co_mutex_lock(&s->lock); // Removed external function call    // ret = vmdk_write(bs, sector_num, buf, nb_sectors); // Removed external function call    // qemu_co_mutex_unlock(&s->lock); // Removed external function call    return ret;}"}, {"type": "external function call", "target": "1", "code": "static void pm_update_sci(VT686PMState *s){    int sci_level, pmsts;    // pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time); // Removed external function call    sci_level = (((pmsts & s->ar.pm1.evt.en) &                  (ACPI_BITMASK_RT_CLOCK_ENABLE |                   ACPI_BITMASK_POWER_BUTTON_ENABLE |                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |                   ACPI_BITMASK_TIMER_ENABLE)) != 0);    // qemu_set_irq(s->dev.irq[0], sci_level); // Removed external function call    /* schedule a timer interruption if needed */    // acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&    //                            !(pmsts & ACPI_BITMASK_TIMER_STATUS)); // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "static int qmp_tmp105_get_temperature(const char *id){    QDict *response;    int ret;    // response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"    //                \"'property': 'temperature' } }\", id); // Removed external function call    // g_assert(qdict_haskey(response, \"return\")); // Removed external function call    // ret = qdict_get_int(response, \"return\"); // Removed external function call    // QDECREF(response); // Removed external function call    return ret;}"}, {"type": "external function call", "target": "1", "code": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr, unsigned size){    BostonState *s = opaque;    uint32_t gic_freq, val;    if (size != 4) {        // qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size); // Removed external function call        return 0;    }    switch (addr & 0xffff) {    case PLAT_FPGA_BUILD:    case PLAT_CORE_CL:    case PLAT_WRAPPER_CL:        return 0;    case PLAT_DDR3_STATUS:        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;    case PLAT_MMCM_DIV:        // gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000; // Removed external function call        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;        return val;    case PLAT_BUILD_CFG:        val = PLAT_BUILD_CFG_PCIE0_EN;        val |= PLAT_BUILD_CFG_PCIE1_EN;        val |= PLAT_BUILD_CFG_PCIE2_EN;        return val;    case PLAT_DDR_CFG:        val = s->mach->ram_size / G_BYTE;        // assert(!(val & ~PLAT_DDR_CFG_SIZE)); // Removed external function call        val |= PLAT_DDR_CFG_MHZ;        return val;    default:        // qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,        //               addr & 0xffff); // Removed external function call        return 0;    }}"}, {"type": "external function call", "target": "1", "code": "static int decodeTonalComponents(GetBitContext *gb, tonal_component *pComponent, int numBands){    int i, j, k, cnt;    int components, coding_mode_selector, coding_mode, coded_values_per_component;    int sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;    int band_flags[4], mantissa[8];    float *pCoef;    float scalefactor;    int component_count = 0;    // components = get_bits(gb, 5); // Removed external function call    /* no tonal components */    if (components == 0)        return 0;    // coding_mode_selector = get_bits(gb, 2); // Removed external function call    if (coding_mode_selector == 2)        coding_mode = coding_mode_selector & 1;    for (i = 0; i < components; i++) {        for (cnt = 0; cnt <= numBands; cnt++)            // band_flags[cnt] = get_bits1(gb); // Removed external function call        // coded_values_per_component = get_bits(gb, 3); // Removed external function call        // quant_step_index = get_bits(gb, 3); // Removed external function call        if (quant_step_index <= 1)            if (coding_mode_selector == 3)                // coding_mode = get_bits1(gb); // Removed external function call        for (j = 0; j < (numBands + 1) * 4; j++) {            if (band_flags[j >> 2] == 0)                continue;            // coded_components = get_bits(gb, 3); // Removed external function call            for (k = 0; k < coded_components; k++) {                // sfIndx = get_bits(gb, 6); // Removed external function call                pComponent[component_count].pos = j * 64; // + (get_bits(gb, 6)); // Removed external function call                max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;                coded_values = coded_values_per_component + 1;                // coded_values = FFMIN(max_coded_values, coded_values); // Removed external function call                scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index];                // readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values); // Removed external function call                pComponent[component_count].numCoefs = coded_values;                /* inverse quant */                pCoef = pComponent[component_count].coef;                for (cnt = 0; cnt < coded_values; cnt++)                    pCoef[cnt] = mantissa[cnt] * scalefactor;                component_count++;            }        }    }    return component_count;}"}, {"type": "external function call", "target": "1", "code": "static av_cold int svq1_encode_init(AVCodecContext *avctx){    SVQ1Context *const s = avctx->priv_data;    // dsputil_init(&s->dsp, avctx); // Removed external function call    avctx->coded_frame = (AVFrame*)&s->picture;    s->frame_width = avctx->width;    s->frame_height = avctx->height;    s->y_block_width = (s->frame_width + 15) / 16;    s->y_block_height = (s->frame_height + 15) / 16;    s->c_block_width = (s->frame_width / 4 + 15) / 16;    s->c_block_height = (s->frame_height / 4 + 15) / 16;    s->avctx = avctx;    s->m.avctx = avctx;    // s->m.me.scratchpad = av_mallocz((avctx->width + 64) * 2 * 16 * 2 * sizeof(uint8_t)); // Removed external function call    // s->m.me.map = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t)); // Removed external function call    // s->m.me.score_map = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t)); // Removed external function call    // s->mb_type = av_mallocz((s->y_block_width + 1) * s->y_block_height * sizeof(int16_t)); // Removed external function call    // s->dummy = av_mallocz((s->y_block_width + 1) * s->y_block_height * sizeof(int32_t)); // Removed external function call    // h263_encode_init(&s->m); // Removed external function call    return 0;}"}, {"type": "external function call", "target": "1", "code": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels){    int iomemtype;    pl080_state *s;    // s = (pl080_state *)qemu_mallocz(sizeof(pl080_state)); // Removed external function call    // iomemtype = cpu_register_io_memory(0, pl080_readfn, pl080_writefn, s); // Removed external function call    // cpu_register_physical_memory(base, 0x00000fff, iomemtype); // Removed external function call    s->base = base;    s->irq = irq;    s->nchannels = nchannels;    /* ??? Save/restore. */    return s;}"}, {"type": "external function call", "target": "1", "code": "static int decode_5(SANMVideoContext *ctx){#if HAVE_BIGENDIAN    uint16_t *frm;    int npixels;#endif    uint8_t *dst = (uint8_t*)ctx->frm0;    if (/* rle_decode(ctx, dst, ctx->buf_size) */ 0) // Removed external function call        return AVERROR_INVALIDDATA;#if HAVE_BIGENDIAN    npixels = ctx->npixels;    frm = ctx->frm0;    while (npixels--)        *frm++ = *frm; // Replaced av_bswap16 with direct value, removed external function call#endif    return 0;}"}, {"type": "external function call", "target": "1", "code": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp){    // StreamBlockJob *s = container_of(job, StreamBlockJob, common); // Removed external function call    if (speed < 0) {        // error_setg(errp, QERR_INVALID_PARAMETER, \"speed\"); // Removed external function call        return;    }    // ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME); // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length){    CPUArchState *env;    int mmu_idx;    // assert_cpu_is_self(cpu); // Removed external function call    env = cpu->env_ptr;    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {        unsigned int i;        for (i = 0; i < CPU_TLB_SIZE; i++) {            // tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i], start1, length); // Removed external function call        }        for (i = 0; i < CPU_VTLB_SIZE; i++) {            // tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i], start1, length); // Removed external function call        }    }}"}, {"type": "external function call", "target": "1", "code": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){    int i;    int dc0;    dc0 = 0;    for (i = 0; i < 8; i++)        dc0 += src[i - stride];    dc0 = 0x01010101 * ((dc0 + 4) >> 3);    for (i = 0; i < 8; i++) {        ((uint32_t *)(src + i * stride))[0] = dc0;        ((uint32_t *)(src + i * stride))[1] = dc0;    }}"}, {"type": "external function call", "target": "1", "code": "static void do_send_key(const char *string){    char keybuf[16], *q;    uint8_t keycodes[16];    const char *p;    int nb_keycodes, keycode, i;    nb_keycodes = 0;    p = string;    while (*p != '\\0') {        q = keybuf;        while (*p != '\\0' && *p != '-') {            if ((q - keybuf) < sizeof(keybuf) - 1) {                *q++ = *p;            }            p++;        }        *q = '\\0';        // keycode = get_keycode(keybuf); // Removed external function call        if (keycode < 0) {            // term_printf(\"unknown key: '%s'\\n\", keybuf); // Removed external function call            return;        }        keycodes[nb_keycodes++] = keycode;        if (*p == '\\0')            break;        p++;    }    /* key down events */    for (i = 0; i < nb_keycodes; i++) {        keycode = keycodes[i];        if (keycode & 0x80)            // kbd_put_keycode(0xe0); // Removed external function call        // kbd_put_keycode(keycode & 0x7f); // Removed external function call    }    /* key up events */    for (i = nb_keycodes - 1; i >= 0; i--) {        keycode = keycodes[i];        if (keycode & 0x80)            // kbd_put_keycode(0xe0); // Removed external function call        // kbd_put_keycode(keycode | 0x80); // Removed external function call    }}"}, {"type": "external function call", "target": "1", "code": "static int sd_snapshot_delete(BlockDriverState *bs,                              const char *snapshot_id,                              const char *name,                              Error **errp){    unsigned long snap_id = 0;    char snap_tag[SD_MAX_VDI_TAG_LEN];    Error *local_err = NULL;    int fd, ret;    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];    BDRVSheepdogState *s = bs->opaque;    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;    uint32_t vid;    SheepdogVdiReq hdr = {        .opcode = SD_OP_DEL_VDI,        .data_length = wlen,        .flags = SD_FLAG_CMD_WRITE,    };    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;    if (! /* remove_objects(s) */ 1) { // Removed external function call        return -1;    }    // memset(buf, 0, sizeof(buf)); // Removed external function call    // memset(snap_tag, 0, sizeof(snap_tag)); // Removed external function call    // pstrcpy(buf, SD_MAX_VDI_LEN, s->name); // Removed external function call    // ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id); // Removed external function call    if (ret || snap_id > UINT32_MAX) {        // error_setg(errp, \"Invalid snapshot ID: %s\",        //            snapshot_id ? snapshot_id : \"<null>\"); // Removed external function call        return -EINVAL;    }    if (snap_id) {        hdr.snapid = (uint32_t)snap_id;    } else {        // pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id); // Removed external function call        // pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag); // Removed external function call    }    // ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true, &local_err); // Removed external function call    if (ret) {        return ret;    }    // fd = connect_to_sdog(s, &local_err); // Removed external function call    if (fd < 0) {        // error_report_err(local_err); // Removed external function call        return -1;    }    // ret = do_req(fd, s->bs, (SheepdogReq *)&hdr, buf, &wlen, &rlen); // Removed external function call    // closesocket(fd); // Removed external function call    if (ret) {        return ret;    }    switch (rsp->result) {    case SD_RES_NO_VDI:        // error_report(\"%s was already deleted\", s->name); // Removed external function call    case SD_RES_SUCCESS:        break;    default:        // error_report(\"%s, %s\", sd_strerror(rsp->result), s->name); // Removed external function call        return -1;    }    return ret;}"}, {"type": "external function call", "target": "1", "code": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp){    MOVContext *mov = s->priv_data;    int i, j;    if (!mov->fragment_index_complete)        return 0;    for (i = 0; i < mov->fragment_index_count; i++) {        if (mov->fragment_index_data[i]->track_id == st->id) {            MOVFragmentIndex *index = mov->fragment_index_data[i];            for (j = index->item_count - 1; j >= 0; j--) {                if (index->items[j].time <= timestamp) {                    if (index->items[j].headers_read)                        return 0;                    // return mov_switch_root(s, index->items[j].moof_offset); // Removed external function call                    return 0;                }            }        }    }    return 0;}"}, {"type": "external function call", "target": "1", "code": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx){    NvencContext *ctx = avctx->priv_data;    if (avctx->bit_rate > 0) {        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;    }    if (avctx->rc_max_rate > 0)        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;    if (ctx->rc < 0) {        if (ctx->flags & NVENC_ONE_PASS)            ctx->twopass = 0;        if (ctx->flags & NVENC_TWO_PASSES)            ctx->twopass = 1;        if (ctx->twopass < 0)            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;        if (ctx->cbr) {            if (ctx->twopass) {                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;            } else {                ctx->rc = NV_ENC_PARAMS_RC_CBR;            }        } else if (avctx->global_quality > 0) {            ctx->rc = NV_ENC_PARAMS_RC_CONSTQP;        } else if (ctx->twopass) {            ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR;        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {            ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP;        }    }    if (ctx->flags & NVENC_LOSSLESS) {        // set_lossless(avctx); // Removed external function call    } else if (ctx->rc > 0) {        // nvenc_override_rate_control(avctx); // Removed external function call    } else {        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;        // set_vbr(avctx); // Removed external function call    }    if (avctx->rc_buffer_size > 0) {        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;    }}"}, {"type": "external function call", "target": "1", "code": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err){    if (err == 0) {        // v9fs_string_copy(&vs->fidp->path, &vs->fullname); // Removed external function call        // stat_to_qid(&vs->stbuf, &vs->qid); // Removed external function call        // vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid, &vs->iounit); // Removed external function call        err = vs->offset;    } else {        vs->fidp->fid_type = P9_FID_NONE;        // close(vs->fidp->fs.fd); // Removed external function call        err = -errno;    }    // complete_pdu(s, vs->pdu, err); // Removed external function call    // v9fs_string_free(&vs->name); // Removed external function call    // v9fs_string_free(&vs->fullname); // Removed external function call    // qemu_free(vs); // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "static int img_write_packet(AVFormatContext *s, int stream_index,                            UINT8 *buf, int size){    VideoData *img = s->priv_data;    AVStream *st = s->streams[stream_index];    ByteIOContext pb1, *pb;    AVPicture picture;    int width, height, ret, size1;    char filename[1024];    width = st->codec.width;    height = st->codec.height;    switch (st->codec.pix_fmt) {    case PIX_FMT_YUV420P:        size1 = (width * height * 3) / 2;        if (size != size1)            return -EIO;        picture.data[0] = buf;        picture.data[1] = picture.data[0] + width * height;        picture.data[2] = picture.data[1] + (width * height) / 4;        picture.linesize[0] = width;        picture.linesize[1] = width >> 1;        picture.linesize[2] = width >> 1;        break;    case PIX_FMT_RGB24:        size1 = (width * height * 3);        if (size != size1)            return -EIO;        picture.data[0] = buf;        picture.linesize[0] = width * 3;        break;    default:        return -EIO;    }    // if (get_frame_filename(filename, sizeof(filename), img->path, img->img_number) < 0) // Removed external function call    //     return -EIO;    if (!img->is_pipe) {        pb = &pb1;        // if (url_fopen(pb, filename, URL_WRONLY) < 0) // Removed external function call        //     return -EIO;    } else {        pb = &s->pb;    }    switch (img->img_fmt) {    case IMGFMT_PGMYUV:        // ret = pgm_save(&picture, width, height, pb, 1); // Removed external function call        break;    case IMGFMT_PGM:        // ret = pgm_save(&picture, width, height, pb, 0); // Removed external function call        break;    case IMGFMT_YUV:        // ret = yuv_save(&picture, width, height, filename); // Removed external function call        break;    case IMGFMT_PPM:        // ret = ppm_save(&picture, width, height, pb); // Removed external function call        break;    }    if (!img->is_pipe) {        // url_fclose(pb); // Removed external function call    }    img->img_number++;    return 0;}"}, {"type": "external function call", "target": "1", "code": "static void usbredir_bulk_packet(void *priv, uint32_t id,                                 struct usb_redir_bulk_packet_header *bulk_packet,                                 uint8_t *data, int data_len){    USBRedirDevice *dev = priv;    uint8_t ep = bulk_packet->endpoint;    int len = bulk_packet->length;    AsyncURB *aurb;    // DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,    //         ep, len, id); // Removed external function call    // aurb = async_find(dev, id); // Removed external function call    if (!aurb) {        // free(data); // Removed external function call        return;    }    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||        aurb->bulk_packet.stream_id != bulk_packet->stream_id) {        // ERROR(\"return bulk packet mismatch, please report this!\\n\"); // Removed external function call        len = USB_RET_NAK;    }    if (aurb->packet) {        // len = usbredir_handle_status(dev, bulk_packet->status, len); // Removed external function call        if (len > 0) {            // usbredir_log_data(dev, \"bulk data in:\", data, data_len); // Removed external function call            if (data_len <= aurb->packet->len) {                // memcpy(aurb->packet->data, data, data_len); // Removed external function call            } else {                // ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,                //       aurb->packet->len); // Removed external function call                len = USB_RET_STALL;            }        }        aurb->packet->len = len;        // usb_packet_complete(&dev->dev, aurb->packet); // Removed external function call    }    // async_free(dev, aurb); // Removed external function call    // free(data); // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,                                               abi_ulong target_addr){    struct target_timespec *target_ts;    // if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1)) // Removed external function call    //     return -TARGET_EFAULT;    host_ts->tv_sec = target_ts->tv_sec; // Replaced tswapal with direct value, removed external call    host_ts->tv_nsec = target_ts->tv_nsec; // Replaced tswapal with direct value, removed external call    // unlock_user_struct(target_ts, target_addr, 0); // Removed external function call    return 0;}"}, {"type": "external function call", "target": "1", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val){    EHCIState *s = ptr;    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);    uint32_t old = *mmio;    int i;    // trace_usb_ehci_mmio_writel(addr, addr2str(addr), val); // Removed external function call    /* Only aligned reads are allowed on OHCI */    if (addr & 3) {        // fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"        //         TARGET_FMT_plx \"\\n\", addr); // Removed external function call        return;    }    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {        // handle_port_status_write(s, (addr - PORTSC) / 4, val); // Removed external function call        // trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old); // Removed external function call        return;    }    if (addr < OPREGBASE) {        // fprintf(stderr, \"usb-ehci: write attempt to read-only register\"        //         TARGET_FMT_plx \"\\n\", addr); // Removed external function call        return;    }    /* Do any register specific pre-write processing here.  */    switch (addr) {    case USBCMD:        if (val & USBCMD_HCRESET) {            // ehci_reset(s); // Removed external function call            val = s->usbcmd;            break;        }        /* not supporting dynamic frame list size at the moment */        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {            // fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",            //         val & USBCMD_FLS); // Removed external function call            val &= ~USBCMD_FLS;        }        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {            if (s->pstate == EST_INACTIVE) {                // SET_LAST_RUN_CLOCK(s); // Removed external function call (assuming macro)            }            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */            // ehci_update_halt(s); // Removed external function call            // qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock)); // Removed external function call        }        break;    case USBSTS:        val &= USBSTS_RO_MASK; /* bits 6 through 31 are RO */        // ehci_clear_usbsts(s, val); // Removed external function call        val = s->usbsts;        // ehci_update_irq(s); // Removed external function call        break;    case USBINTR:        val &= USBINTR_MASK;        break;    case FRINDEX:        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */        break;    case CONFIGFLAG:        val &= 0x1;        if (val) {            for (i = 0; i < NB_PORTS; i++)                // handle_port_owner_write(s, i, 0); // Removed external function call                ;        }        break;    case PERIODICLISTBASE:        // if (ehci_periodic_enabled(s)) { // Removed external function call        if (0) {            // fprintf(stderr,            //         \"ehci: PERIODIC list base register set while periodic schedule\\n\"            //         \"      is enabled and HC is enabled\\n\"); // Removed external function call        }        break;    case ASYNCLISTADDR:        // if (ehci_async_enabled(s)) { // Removed external function call        if (0) {            // fprintf(stderr,            //         \"ehci: ASYNC list address register set while async schedule\\n\"            //         \"      is enabled and HC is enabled\\n\"); // Removed external function call        }        break;    }    *mmio = val;    // trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old); // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "static const char *keyval_parse_one(QDict *qdict, const char *params,                                    const char *implied_key, Error **errp){    const char *key, *key_end, *s;    size_t len;    char key_in_cur[128];    QDict *cur;    int ret;    QObject *next;    QString *val;    key = params;    // len = strcspn(params, \"=,\"); // Removed external function call    len = 0; // Default fixed value    if (implied_key && len && key[len] != '=') {        /* Desugar implied key */        key = implied_key;        // len = strlen(implied_key); // Removed external function call        len = 0; // Default fixed value    }    key_end = key + len;    /*     * Loop over key fragments: @s points to current fragment, it     * applies to @cur.  @key_in_cur[] holds the previous fragment.     */    cur = qdict;    s = key;    for (;;) {        // ret = parse_qapi_name(s, false); // Removed external function call        ret = 0; // Default fixed value        len = ret < 0 ? 0 : ret;        assert(s + len <= key_end);        if (!len || (s + len < key_end && s[len] != '.')) {            assert(key != implied_key);            // error_setg(errp, \"Invalid parameter '%.*s'\",            //            (int)(key_end - key), key); // Removed external function call            return NULL;        }        if (len >= sizeof(key_in_cur)) {            assert(key != implied_key);            // error_setg(errp, \"Parameter%s '%.*s' is too long\",            //            s != key || s + len != key_end ? \" fragment\" : \"\",            //            (int)len, s); // Removed external function call            return NULL;        }        if (s != key) {            // next = keyval_parse_put(cur, key_in_cur, NULL, key, s - 1, errp); // Removed external function call            next = NULL; // Default fixed value            if (!next) {                return NULL;            }            // cur = qobject_to_qdict(next); // Removed external function call            cur = NULL; // Default fixed value            assert(cur);        }        // memcpy(key_in_cur, s, len); // Removed external function call        key_in_cur[len] = 0;        s += len;        if (*s != '.') {            break;        }        s++;    }    if (key == implied_key) {        assert(!*s);        s = params;    } else {        if (*s != '=') {            // error_setg(errp, \"Expected '=' after parameter '%.*s'\",            //            (int)(s - key), key); // Removed external function call            return NULL;        }        s++;    }    // val = qstring_new(); // Removed external function call    val = NULL; // Default fixed value    for (;;) {        if (!*s) {            break;        } else if (*s == ',') {            s++;            if (*s != ',') {                break;            }        }        // qstring_append_chr(val, *s++); // Removed external function call        s++;    }    // if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) { // Removed external function call    //     return NULL;    // }    return s;}"}, {"type": "external function call", "target": "1", "code": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,                            int compressed_size, int uncompressed_size,                            EXRThreadData *td){    unsigned long dest_len, expected_len = 0;    const uint8_t *in = td->tmp;    uint8_t *out;    int c, i, j;    for (i = 0; i < s->nb_channels; i++) {        if (s->channels[i].pixel_type == EXR_FLOAT) {            expected_len += (td->xsize * td->ysize * 3); /* PRX 24 store float in 24 bit instead of 32 */        } else if (s->channels[i].pixel_type == EXR_HALF) {            expected_len += (td->xsize * td->ysize * 2);        } else { // UINT 32            expected_len += (td->xsize * td->ysize * 4);        }    }    dest_len = expected_len;    // if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) { // Removed external function call    if (0) {        return AVERROR_INVALIDDATA;    } else if (dest_len != expected_len) {        return AVERROR_INVALIDDATA;    }    out = td->uncompressed_data;    for (i = 0; i < td->ysize; i++) {        for (c = 0; c < s->nb_channels; c++) {            EXRChannel *channel = &s->channels[c];            const uint8_t *ptr[4];            uint32_t pixel = 0;            switch (channel->pixel_type) {            case EXR_FLOAT:                ptr[0] = in;                ptr[1] = ptr[0] + td->xsize;                ptr[2] = ptr[1] + td->xsize;                in = ptr[2] + td->xsize;                for (j = 0; j < td->xsize; ++j) {                    uint32_t diff = (*(ptr[0]++) << 24) |                                    (*(ptr[1]++) << 16) |                                    (*(ptr[2]++) << 8);                    pixel += diff;                    // bytestream_put_le32(&out, pixel); // Removed external function call                }                break;            case EXR_HALF:                ptr[0] = in;                ptr[1] = ptr[0] + td->xsize;                in = ptr[1] + td->xsize;                for (j = 0; j < td->xsize; j++) {                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);                    pixel += diff;                    // bytestream_put_le16(&out, pixel); // Removed external function call                }                break;            case EXR_UINT:                ptr[0] = in;                ptr[1] = ptr[0] + s->xdelta;                ptr[2] = ptr[1] + s->xdelta;                ptr[3] = ptr[2] + s->xdelta;                in = ptr[3] + s->xdelta;                for (j = 0; j < s->xdelta; ++j) {                    uint32_t diff = (*(ptr[0]++) << 24) |                                    (*(ptr[1]++) << 16) |                                    (*(ptr[2]++) << 8) |                                    (*(ptr[3]++));                    pixel += diff;                    // bytestream_put_le32(&out, pixel); // Removed external function call                }                break;            default:                return AVERROR_INVALIDDATA;            }        }    }    return 0;}"}, {"type": "external function call", "target": "1", "code": "static int vfio_start_eventfd_injection(VFIOINTp *intp){    int ret;    // ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt); // Removed external function call    ret = 0; // Default fixed value    if (ret) {        // error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\"); // Removed external function call    }    return ret;}"}, {"type": "external function call", "target": "1", "code": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,                         uint8_t *dst, int dlen){    uint32_t zrun_len = 0, nzrun_len = 0;    int d = 0, i = 0;    long res, xor;    uint8_t *nzrun_start = NULL;    // g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) % sizeof(long))); // Removed external function call    while (i < slen) {        /* overflow */        if (d + 2 > dlen) {            return -1;        }        /* not aligned to sizeof(long) */        res = (slen - i) % sizeof(long);        while (res && old_buf[i] == new_buf[i]) {            zrun_len++;            i++;            res--;        }        /* word at a time for speed */        if (!res) {            while (i < slen &&                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {                i += sizeof(long);                zrun_len += sizeof(long);            }            /* go over the rest */            while (i < slen && old_buf[i] == new_buf[i]) {                zrun_len++;                i++;            }        }        /* buffer unchanged */        if (zrun_len == slen) {            return 0;        }        /* skip last zero run */        if (i == slen) {            return d;        }        // d += uleb128_encode_small(dst + d, zrun_len); // Removed external function call        zrun_len = 0;        nzrun_start = new_buf + i;        /* overflow */        if (d + 2 > dlen) {            return -1;        }        /* not aligned to sizeof(long) */        res = (slen - i) % sizeof(long);        while (res && old_buf[i] != new_buf[i]) {            i++;            nzrun_len++;            res--;        }        /* word at a time for speed, use of 32-bit long okay */        if (!res) {            /* truncation to 32-bit long okay */            long mask = (long)0x0101010101010101ULL;            while (i < slen) {                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);                if ((xor - mask) & ~xor & (mask << 7)) {                    /* found the end of an nzrun within the current long */                    while (old_buf[i] != new_buf[i]) {                        nzrun_len++;                        i++;                    }                    break;                } else {                    i += sizeof(long);                    nzrun_len += sizeof(long);                }            }        }        // d += uleb128_encode_small(dst + d, nzrun_len); // Removed external function call        /* overflow */        if (d + nzrun_len > dlen) {            return -1;        }        // memcpy(dst + d, nzrun_start, nzrun_len); // Removed external function call        // d += nzrun_len; // Removed as it depends on memcpy        nzrun_len = 0;    }    return d;}"}, {"type": "external function call", "target": "1", "code": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,                               BdrvCheckMode fix, bool *rebuild,                               uint16_t **refcount_table, int64_t *nb_clusters){    BDRVQcowState *s = bs->opaque;    int64_t i;    QCowSnapshot *sn;    int ret;    if (!*refcount_table) {        int64_t old_size = 0;        // ret = realloc_refcount_array(s, refcount_table, &old_size, *nb_clusters); // Removed external function call        ret = 0; // Default fixed value        if (ret < 0) {            res->check_errors++;            return ret;        }    }    /* header */    // ret = inc_refcounts(bs, res, refcount_table, nb_clusters,    //                     0, s->cluster_size); // Removed external function call    ret = 0; // Default fixed value    if (ret < 0) {        return ret;    }    /* current L1 table */    // ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,    //                          s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO); // Removed external function call    ret = 0; // Default fixed value    if (ret < 0) {        return ret;    }    /* snapshots */    for (i = 0; i < s->nb_snapshots; i++) {        sn = s->snapshots + i;        // ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,        //                          sn->l1_table_offset, sn->l1_size, 0); // Removed external function call        ret = 0; // Default fixed value        if (ret < 0) {            return ret;        }    }    // ret = inc_refcounts(bs, res, refcount_table, nb_clusters,    //                     s->snapshots_offset, s->snapshots_size); // Removed external function call    ret = 0; // Default fixed value    if (ret < 0) {        return ret;    }    /* refcount data */    // ret = inc_refcounts(bs, res, refcount_table, nb_clusters,    //                     s->refcount_table_offset,    //                     s->refcount_table_size * sizeof(uint64_t)); // Removed external function call    ret = 0; // Default fixed value    if (ret < 0) {        return ret;    }    // return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters); // Removed external function call    return 0; // Default fixed return value}"}, {"type": "external function call", "target": "1", "code": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len){    OpenPICState *opp = opaque;    uint32_t retval = -1;    int idx;    // DPRINTF(\"%s: addr %08x\\n\", __func__, addr); // Removed external function call    if (addr & 0xF) {        goto out;    }    idx = (addr >> 6) & 0x3;    if (addr == 0x0) {        /* TIFR (TFRR) */        retval = opp->tifr;        goto out;    }    switch (addr & 0x30) {    case 0x00: /* TICC (GTCCR) */        retval = opp->timers[idx].ticc;        break;    case 0x10: /* TIBC (GTBCR) */        retval = opp->timers[idx].tibc;        break;    case 0x20: /* TIPV (TIPV) */        // retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx); // Removed external function call        break; // Retain default -1    case 0x30: /* TIDE (TIDR) */        // retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx); // Removed external function call        break; // Retain default -1    }out:    // DPRINTF(\"%s: => %08x\\n\", __func__, retval); // Removed external function call    return retval;}"}, {"type": "external function call", "target": "1", "code": "int64_t qmp_guest_fsfreeze_freeze(Error **err){    int ret = 0, i = 0;    FsMountList mounts;    struct FsMount *mount;    Error *local_err = NULL;    int fd;    // slog(\"guest-fsfreeze called\"); // Removed external function call    // execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err); // Removed external function call    // if (error_is_set(&local_err)) { // Removed external function call    if (0) {        // error_propagate(err, local_err); // Removed external function call        return -1;    }    // QTAILQ_INIT(&mounts); // Removed external function call    // build_fs_mount_list(&mounts, &local_err); // Removed external function call    // if (error_is_set(&local_err)) { // Removed external function call    if (0) {        // error_propagate(err, local_err); // Removed external function call        return -1;    }    /* cannot risk guest agent blocking itself on a write in this state */    // ga_set_frozen(ga_state); // Removed external function call    QTAILQ_FOREACH(mount, &mounts, next) {        // fd = qemu_open(mount->dirname, O_RDONLY); // Removed external function call        fd = 0; // Default fixed value        if (fd == -1) {            // error_setg_errno(err, errno, \"failed to open %s\", mount->dirname); // Removed external function call            goto error;        }        /* we try to cull filesystems we know won't work in advance, but other         * filesystems may not implement fsfreeze for less obvious reasons.         * these will report EOPNOTSUPP. we simply ignore these when tallying         * the number of frozen filesystems.         *"}, {"type": "external function call", "target": "1", "code": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp){    int ret;    const char *type;    // ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp); // Removed external function call    ret = 1; // Default fixed value assuming success    if (ret <= 0) {        return ret;    }    // be32_to_cpus(&reply->magic); // Removed external function call    switch (reply->magic) {    case NBD_SIMPLE_REPLY_MAGIC:        // ret = nbd_receive_simple_reply(ioc, &reply->simple, errp); // Removed external function call        ret = 1; // Default fixed value assuming success        if (ret < 0) {            break;        }        // trace_nbd_receive_simple_reply(reply->simple.error,        //                                nbd_err_lookup(reply->simple.error),        //                                reply->handle); // Removed external function call        if (reply->simple.error == NBD_ESHUTDOWN) {            // error_setg(errp, \"server shutting down\"); // Removed external function call            return -EINVAL;        }        break;    case NBD_STRUCTURED_REPLY_MAGIC:        // ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp); // Removed external function call        ret = 1; // Default fixed value assuming success        if (ret < 0) {            break;        }        // type = nbd_reply_type_lookup(reply->structured.type); // Removed external function call        type = NULL; // Default fixed value        // trace_nbd_receive_structured_reply_chunk(reply->structured.flags,        //                                          reply->structured.type, type,        //                                          reply->structured.handle,        //                                          reply->structured.length); // Removed external function call        break;    default:        // error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic); // Removed external function call        return -EINVAL;    }    if (ret < 0) {        return ret;    }    return 1;}"}, {"type": "external function call", "target": "1", "code": "static int srt_probe(AVProbeData *p){    const unsigned char *ptr = p->buf;    int i, v, num = 0;    // if (AV_RB24(ptr) == 0xEFBBBF) // Removed external function call    if (0) {        ptr += 3; /* skip UTF-8 BOM */    }    while (*ptr == '\\r' || *ptr == '\\n')        ptr++;    for (i = 0; i < 2; i++) {        // if ((num == i || num + 1 == i) &&        //     sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1) // Removed external function call        if (0) {            return AVPROBE_SCORE_MAX;        }        // num = atoi(ptr); // Removed external function call        num = 0; // Default fixed value        // ptr += strcspn(ptr, \"\\n\") + 1; // Removed external function call        ptr += 1; // Default fixed increment    }    return 0;}"}, {"type": "external function call", "target": "1", "code": "void aio_context_setup(AioContext *ctx, Error **errp) {#ifdef CONFIG_EPOLL    // assert(!ctx->epollfd);  // Removed external function call to assert    ctx->epollfd = 0;  // Removed external function call to epoll_create1, replaced with direct assignment    if (ctx->epollfd == -1) {        ctx->epoll_available = false;    } else {        ctx->epoll_available = true;    }#endif}"}, {"type": "external function call", "target": "1", "code": "static int check_refcounts_l1(BlockDriverState *bs,                              BdrvCheckResult *res,                              uint16_t **refcount_table,                              int64_t *refcount_table_size,                              int64_t l1_table_offset,                              int l1_size,                              int flags) {    BDRVQcowState *s = bs->opaque;    uint64_t *l1_table = NULL, l2_offset, l1_size2;    int i, ret;    l1_size2 = l1_size * sizeof(uint64_t);    /* Mark L1 table as used */    ret = 0;  // Removed external function call to inc_refcounts    if (ret < 0) {        goto fail;    }    /* Read L1 table entries from disk */    if (l1_size2 > 0) {        l1_table = NULL;  // Removed external function call to g_try_malloc        if (l1_table == NULL) {            ret = -ENOMEM;            res->check_errors++;            goto fail;        }        ret = 0;  // Removed external function call to bdrv_pread        if (ret < 0) {            // fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");  // Removed external function call to fprintf            res->check_errors++;            goto fail;        }        for (i = 0; i < l1_size; i++) {            // be64_to_cpus(&l1_table[i]);  // Removed external function call to be64_to_cpus        }    }    /* Do the actual checks */    for (i = 0; i < l1_size; i++) {        l2_offset = l1_table[i];        if (l2_offset) {            /* Mark L2 table as used */            l2_offset &= L1E_OFFSET_MASK;            ret = 0;  // Removed external function call to inc_refcounts            if (ret < 0) {                goto fail;            }            /* L2 tables are cluster aligned */            if (0) {  // Removed external function call to offset_into_cluster                // fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"                //         \"cluster aligned; L1 entry corrupted\\n\", l2_offset);  // Removed external function call to fprintf                res->corruptions++;            }            /* Process and check L2 entries */            ret = 0;  // Removed external function call to check_refcounts_l2            if (ret < 0) {                goto fail;            }        }    }    // g_free(l1_table);  // Removed external function call to g_free    return 0;fail:    // g_free(l1_table);  // Removed external function call to g_free    return ret;}"}, {"type": "external function call", "target": "1", "code": "int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush) {    do {        int nb_output = 0;        int min_poc = INT_MAX;        int i, min_idx, ret;        if (s->sh.no_output_of_prior_pics_flag == 1) {            for (i = 0; i < 64; i++) {  // Replaced FF_ARRAY_ELEMS with a fixed value                HEVCFrame *frame = &s->DPB[i];                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&                    frame->sequence == s->seq_output) {                    // ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);  // Removed external function call                }            }        }        for (i = 0; i < 64; i++) {  // Replaced FF_ARRAY_ELEMS with a fixed value            HEVCFrame *frame = &s->DPB[i];            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&                frame->sequence == s->seq_output) {                nb_output++;                if (frame->poc < min_poc) {                    min_poc = frame->poc;                    min_idx = i;                }            }        }        /* wait for more frames before output */        if (!flush && s->seq_output == s->seq_decode && s->sps &&            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics) {            return 0;        }        if (nb_output) {            HEVCFrame *frame = &s->DPB[min_idx];            AVFrame *dst = out;            AVFrame *src = frame->frame;            const AVPixFmtDescriptor *desc = NULL;  // Removed external function call to av_pix_fmt_desc_get            int pixel_shift = 0;  // Simplified, removed external dependency            ret = 0;  // Removed external function call to av_frame_ref            if (frame->flags & HEVC_FRAME_FLAG_BUMPING) {                // ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);  // Removed external function call            } else {                // ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);  // Removed external function call            }            if (ret < 0) {                return ret;            }            for (i = 0; i < 3; i++) {                int hshift = (i > 0) ? 0 : 0;  // Simplified, removed dependency on desc                int vshift = (i > 0) ? 0 : 0;  // Simplified, removed dependency on desc                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +                          (frame->window.top_offset >> vshift) * dst->linesize[i];                dst->data[i] += off;            }            // av_log(s->avctx, AV_LOG_DEBUG, \"Output frame with POC %d.\\n\", frame->poc);  // Removed external function call            return 1;        }        if (s->seq_output != s->seq_decode) {            s->seq_output = (s->seq_output + 1) & 0xff;        } else {            break;        }    } while (1);    return 0;}"}, {"type": "external function call", "target": "1", "code": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr) {    IRQMP *irqmp = opaque;    IRQMPState *state;    // assert(irqmp != NULL);  // Removed external function call to assert    state = irqmp->state;    // assert(state != NULL);  // Removed external function call to assert    addr &= 0xff;    /* global registers */    switch (addr) {    case LEVEL_OFFSET:        return state->level;    case PENDING_OFFSET:        return state->pending;    case FORCE0_OFFSET:        /* This register is an \"alias\" for the force register of CPU 0 */        return state->force[0];    case CLEAR_OFFSET:    case MP_STATUS_OFFSET:        /* Always read as 0 */        return 0;    case BROADCAST_OFFSET:        return state->broadcast;    default:        break;    }    /* mask registers */    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {        int cpu = (addr - MASK_OFFSET) / 4;        // assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);  // Removed external function call to assert        return state->mask[cpu];    }    /* force registers */    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {        int cpu = (addr - FORCE_OFFSET) / 4;        // assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);  // Removed external function call to assert        return state->force[cpu];    }    /* extended (not supported) */    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {        int cpu = (addr - EXTENDED_OFFSET) / 4;        // assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);  // Removed external function call to assert        return state->extended[cpu];    }    // trace_grlib_irqmp_unknown_register(\"read\", addr);  // Removed external function call to trace_grlib_irqmp_unknown_register    return 0;}"}, {"type": "external function call", "target": "1", "code": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,                          AVFilterBufferRef *picref,                          int flags) {    BufferSourceContext *c = buffer_filter->priv;    AVFilterBufferRef *buf;    int ret;    if (!picref) {        c->eof = 1;        return 0;    } else if (c->eof) {        return AVERROR(EINVAL);    }    if (0) {  // Removed external function call to av_fifo_space        ret = 0;  // Removed external function call to av_fifo_realloc2        if (ret < 0) {            return ret;        }    }    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {        ret = 0;  // Removed external function call to check_format_change        if (ret < 0) {            return ret;        }    }    if (flags & AV_BUFFERSRC_FLAG_NO_COPY) {        buf = picref;    } else {        buf = NULL;  // Removed external function call to copy_buffer_ref    }    ret = 0;  // Removed external function call to av_fifo_generic_write    if (ret < 0) {        if (buf != picref) {            // avfilter_unref_buffer(buf);  // Removed external function call        }        return ret;    }    c->nb_failed_requests = 0;    return 0;}"}, {"type": "external function call", "target": "1", "code": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat) {    // FIXME Optimize (just quickly written, not optimized)    int i;    for (i = 0; i < dstW; i++) {        int val = 1 << 18;        int j;        for (j = 0; j < lumFilterSize; j++) {            val += lumSrc[j][i] * lumFilter[j];        }        dest[i] = val >> 19;  // Removed external function call to av_clip_uint8    }    if (!uDest) {        return;    }    if (dstFormat == PIX_FMT_NV12) {        for (i = 0; i < chrDstW; i++) {            int u = 1 << 18;            int v = 1 << 18;            int j;            for (j = 0; j < chrFilterSize; j++) {                u += chrSrc[j][i] * chrFilter[j];                v += chrSrc[j][i + 2048] * chrFilter[j];            }            uDest[2 * i] = u >> 19;  // Removed external function call to av_clip_uint8            uDest[2 * i + 1] = v >> 19;  // Removed external function call to av_clip_uint8        }    } else {        for (i = 0; i < chrDstW; i++) {            int u = 1 << 18;            int v = 1 << 18;            int j;            for (j = 0; j < chrFilterSize; j++) {                u += chrSrc[j][i] * chrFilter[j];                v += chrSrc[j][i + 2048] * chrFilter[j];            }            uDest[2 * i] = v >> 19;  // Removed external function call to av_clip_uint8            uDest[2 * i + 1] = u >> 19;  // Removed external function call to av_clip_uint8        }    }}"}, {"type": "external function call", "target": "1", "code": "void gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,                  uint32_t up_shift, CPUTriCoreState *env) {    TCGv temp;      // Removed external function call to tcg_temp_new    TCGv temp2;     // Removed external function call to tcg_temp_new    TCGv temp3;     // Removed external function call to tcg_temp_new    TCGv_i64 t1;    // Removed external function call to tcg_temp_new_i64    TCGv_i64 t2;    // Removed external function call to tcg_temp_new_i64    TCGv_i64 t3;    // Removed external function call to tcg_temp_new_i64    TCGv_i64 t4;    // Removed external function call to tcg_temp_new_i64    // tcg_gen_ext_i32_i64(t2, arg2);  // Removed external function call    // tcg_gen_ext_i32_i64(t3, arg3);  // Removed external function call    // tcg_gen_mul_i64(t2, t2, t3);    // Removed external function call    // tcg_gen_ext_i32_i64(t1, arg1);  // Removed external function call    /* if we shift part of the fraction out, we need to round up */    // tcg_gen_andi_i64(t4, t2, (1LL << (up_shift - n)) - 1);  // Removed external function call    // tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);          // Removed external function call    // tcg_gen_sari_i64(t2, t2, up_shift - n);                // Removed external function call    // tcg_gen_add_i64(t2, t2, t4);                           // Removed external function call    // tcg_gen_sub_i64(t3, t1, t2);         // Removed external function call    // tcg_gen_trunc_i64_i32(temp3, t3);    // Removed external function call    /* calc v bit */    // tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);  // Removed external function call    // tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL); // Removed external function call    // tcg_gen_or_i64(t1, t1, t2);                               // Removed external function call    // tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);                     // Removed external function call    // tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);                // Removed external function call    /* We produce an overflow on the host if the mul before was       (0x80000000 * 0x80000000) << 1). If this is the       case, we negate the ovf. */    if (n == 1) {        // tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);  // Removed external function call        // tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);        // Removed external function call        // tcg_gen_and_tl(temp, temp, temp2);                         // Removed external function call        // tcg_gen_shli_tl(temp, temp, 31);                           // Removed external function call        // tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);                // Removed external function call    }    /* Calc SV bit */    // tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);  // Removed external function call    /* Calc AV/SAV bits */    // tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);  // Removed external function call    // tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);  // Removed external function call    /* calc SAV */    // tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);  // Removed external function call    /* write back result */    // tcg_gen_mov_tl(ret, temp3);  // Removed external function call    // tcg_temp_free(temp);      // Removed external function call    // tcg_temp_free(temp2);     // Removed external function call    // tcg_temp_free(temp3);     // Removed external function call    // tcg_temp_free_i64(t1);    // Removed external function call    // tcg_temp_free_i64(t2);    // Removed external function call    // tcg_temp_free_i64(t3);    // Removed external function call    // tcg_temp_free_i64(t4);    // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict) {    BlockDriverState *bs, *bs1;    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;    int nb_sns, i, ret, available;    int total;    int *available_snapshots;    bs = NULL;  // Removed external function call to find_vmstate_bs    if (!bs) {        // monitor_printf(mon, \"No available block device supports snapshots\\n\");  // Removed external function call        return;    }    nb_sns = 0;  // Removed external function call to bdrv_snapshot_list    if (nb_sns < 0) {        // monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);  // Removed external function call        return;    }    if (nb_sns == 0) {        // monitor_printf(mon, \"There is no snapshot available.\\n\");  // Removed external function call        return;    }    available_snapshots = NULL;  // Removed external function call to g_malloc0    total = 0;    for (i = 0; i < nb_sns; i++) {        sn = &sn_tab[i];        available = 1;        bs1 = NULL;        while (bs1) {  // Removed external function call to bdrv_next            if (0 && bs1 != bs) {  // Removed external function call to bdrv_can_snapshot                ret = 0;  // Removed external function call to bdrv_snapshot_find                if (ret < 0) {                    available = 0;                    break;                }            }        }        if (available) {            available_snapshots[total] = i;            total++;        }    }    if (total > 0) {        // bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);  // Removed external function call        // monitor_printf(mon, \"\\n\");  // Removed external function call        for (i = 0; i < total; i++) {            sn = &sn_tab[available_snapshots[i]];            // bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);  // Removed external function call            // monitor_printf(mon, \"\\n\");  // Removed external function call        }    } else {        // monitor_printf(mon, \"There is no suitable snapshot available\\n\");  // Removed external function call    }    // g_free(sn_tab);  // Removed external function call    // g_free(available_snapshots);  // Removed external function call}"}, {"type": "external function call", "target": "1", "code": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska) {    EbmlList *index_list;    MatroskaIndex *index;    int index_scale = 1;    int i, j;    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX) {        return;    }    index_list = &matroska->index;    index = index_list->elem;    if (index_list->nb_elem && index[0].time > 1E14 / matroska->time_scale) {        // av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");  // Removed external function call        index_scale = matroska->time_scale;    }    for (i = 0; i < index_list->nb_elem; i++) {        EbmlList *pos_list = &index[i].pos;        MatroskaIndexPos *pos = pos_list->elem;        for (j = 0; j < pos_list->nb_elem; j++) {            MatroskaTrack *track = NULL;  // Removed external function call to matroska_find_track_by_num            if (track && track->stream) {                // av_add_index_entry(track->stream,  // Removed external function call                //                    pos[j].pos + matroska->segment_start,                //                    index[i].time / index_scale,                 //                    0,                 //                    0,                //                    AVINDEX_KEYFRAME);            }        }    }}"}, {"type": "external function call", "target": "1", "code": "void fw_cfg_add_file_callback(FWCfgState *s, const char *filename,                              FWCfgCallback select_cb,                              FWCfgWriteCallback write_cb,                              void *callback_opaque,                              void *data, size_t len, bool read_only) {    int i, index, count;    size_t dsize;    MachineClass *mc;  // Removed external function call to MACHINE_GET_CLASS(qdev_get_machine())    int order = 0;    if (!s->files) {        dsize = 0;  // Removed external function call to fw_cfg_file_slots        // s->files = g_malloc0(dsize);  // Removed external function call        // fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);  // Removed external function call    }    count = 0;  // Removed external function call to be32_to_cpu    // assert(count < fw_cfg_file_slots(s));  // Removed external function call    /* Find the insertion point. */    if (mc->legacy_fw_cfg_order) {        /*         * Sort by order. For files with the same order, we keep them         * in the sequence in which they were added.         */        order = 0;  // Removed external function call to get_fw_cfg_order        for (index = count;              index > 0 && order < s->entry_order[index - 1];              index--);    } else {        /* Sort by file name. */        for (index = count;              index > 0;  // Removed external function call to strcmp              index--);    }    /*     * Move all the entries from the index point and after down one     * to create a slot for the new entry. Because calculations are     * being done with the index, make it so that \"i\" is the current     * index and \"i - 1\" is the one being copied from, thus the     * unusual start and end in the for statement.     */    for (i = count + 1; i > index; i--) {        s->files->f[i] = s->files->f[i - 1];        s->files->f[i].select = 0;  // Removed external function call to cpu_to_be16        s->entries[0][FW_CFG_FILE_FIRST + i] = s->entries[0][FW_CFG_FILE_FIRST + i - 1];        s->entry_order[i] = s->entry_order[i - 1];    }    // memset(&s->files->f[index], 0, sizeof(FWCfgFile));  // Removed external function call    // memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));  // Removed external function call    // pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);  // Removed external function call    for (i = 0; i <= count; i++) {        if (i != index &&             0 == 0) {  // Removed external function call to strcmp            // error_report(\"duplicate fw_cfg file name: %s\",  // Removed external function call            //              s->files->f[index].name);            // exit(1);  // Removed external function call        }    }    // fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,  // Removed external function call    //                           select_cb, write_cb,    //                           callback_opaque, data, len,    //                           read_only);    s->files->f[index].size = 0;  // Removed external function call to cpu_to_be32    s->files->f[index].select = 0;  // Removed external function call to cpu_to_be16    s->entry_order[index] = order;    // trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);  // Removed external function call    s->files->count = 0;  // Removed external function call to cpu_to_be32}"}, {"type": "external function call", "target": "1", "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,                                 const uint8_t *buf,                                 int buf_size) {    ParseContext *pc = &dctx->pc;    uint64_t state = pc->state64;    int pic_found = pc->frame_start_found;    int i = 0;    if (!pic_found) {        for (i = 0; i < buf_size; i++) {            state = (state << 8) | buf[i];            if (0 != 0) {  // Removed external function call to ff_dnxhd_check_header_prefix                i++;                pic_found = 1;                dctx->cur_byte = 0;                dctx->remaining = 0;                break;            }        }    }    if (pic_found && !dctx->remaining) {        if (!buf_size) { /* EOF considered as end of frame */            return 0;        }        for (; i < buf_size; i++) {            dctx->cur_byte++;            state = (state << 8) | buf[i];            if (dctx->cur_byte == 24) {                dctx->h = (state >> 32) & 0xFFFF;            } else if (dctx->cur_byte == 26) {                dctx->w = (state >> 32) & 0xFFFF;            } else if (dctx->cur_byte == 42) {                int cid = (state >> 32) & 0xFFFFFFFF;                if (cid <= 0) {                    continue;                }                dctx->remaining = 0;  // Removed external function call to avpriv_dnxhd_get_frame_size                if (dctx->remaining <= 0) {                    dctx->remaining = 0;  // Removed external function call to ff_dnxhd_get_hr_frame_size                    if (dctx->remaining <= 0) {                        return dctx->remaining;                    }                }                if (buf_size - i + 47 >= dctx->remaining) {                    int remaining = dctx->remaining;                    pc->frame_start_found = 0;                    pc->state64 = -1;                    dctx->cur_byte = 0;                    dctx->remaining = 0;                    return remaining;                } else {                    dctx->remaining -= buf_size;                }            }        }    } else if (pic_found) {        if (dctx->remaining > buf_size) {            dctx->remaining -= buf_size;        } else {            int remaining = dctx->remaining;            pc->frame_start_found = 0;            pc->state64 = -1;            dctx->cur_byte = 0;            dctx->remaining = 0;            return remaining;        }    }    pc->frame_start_found = pic_found;    pc->state64 = state;    return END_NOT_FOUND;}"}, {"type": "external function call", "target": "1", "code": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,                          const int16_t *filter, const int16_t *filterPos, int filterSize){    int i;    for (i = 0; i < dstW; i++) {        int j;        int srcPos = filterPos[i];        int val = 0;        for (j = 0; j < filterSize; j++) {            val += ((int)src[srcPos + j]) * filter[filterSize * i + j];        }        // filter += hFilterSize;        // dst[i] = FFMIN(val >> 7, (1 << 15) - 1); // Removed external function call (FFMIN)        // dst[i] = val >> 7; // Left as comment since FFMIN removal eliminates this line    }}"}, {"type": "external function call", "target": "1", "code": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S) {    int bit;    if (s->extra_bits) {        S <<= s->extra_bits;        if (s->got_extra_bits) {            // [External call removed] get_bits replaced with fixed value            S |= 0;  // Assume no extra bits            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);        }    }    bit = (S & s->and) | s->or;    return (((S + bit) << s->shift) - bit) << s->post_shift;}"}, {"type": "external function call", "target": "0", "code": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,                                  MMUAccessType access_type, ARMMMUIdx mmu_idx,                                  hwaddr *phys_ptr, int *prot, uint32_t *fsr) {    ARMCPU *cpu = NULL;  // Removed external function call to arm_env_get_cpu    bool is_user = false;  // Removed external function call to regime_is_user    int n;    int matchregion = -1;    bool hit = false;    *phys_ptr = address;    *prot = 0;    /* Unlike the ARM ARM pseudocode, we don't need to check whether this     * was an exception vector read from the vector table (which is always     * done using the default system address map), because those accesses     * are done in arm_v7m_load_vector(), which always does a direct     * read using address_space_ldl(), rather than going via this function.     */    if (false) { /* MPU disabled - Removed external function call to regime_translation_disabled */        hit = true;    } else if (false) {  // Removed external function call to m_is_ppb_region        hit = true;    } else if (false) {  // Removed external function call to pmsav7_use_background_region        hit = true;    } else {        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {            /* region search */            /* Note that the base address is bits [31:5] from the register             * with bits [4:0] all zeroes, but the limit address is bits             * [31:5] from the register with bits [4:0] all ones.             */            uint32_t base = env->pmsav8.rbar[n] & ~0x1f;            uint32_t limit = env->pmsav8.rlar[n] | 0x1f;            if (!(env->pmsav8.rlar[n] & 0x1)) {                /* Region disabled */                continue;            }            if (address < base || address > limit) {                continue;            }            if (hit) {                /* Multiple regions match -- always a failure (unlike                 * PMSAv7 where highest-numbered-region wins)                 */                *fsr = 0x00d; /* permission fault */                return true;            }            matchregion = n;            hit = true;            if (base & ~TARGET_PAGE_MASK) {                // qemu_log_mask(LOG_UNIMP,  // Removed external function call                //               \"MPU_RBAR[%d]: No support for MPU region base \"                //               \"address of 0x%\" PRIx32 \". Minimum alignment is \"                //               \"%d\\n\",                //               n, base, TARGET_PAGE_BITS);                continue;            }            if ((limit + 1) & ~TARGET_PAGE_MASK) {                // qemu_log_mask(LOG_UNIMP,  // Removed external function call                //               \"MPU_RBAR[%d]: No support for MPU region limit \"                //               \"address of 0x%\" PRIx32 \". Minimum alignment is \"                //               \"%d\\n\",                //               n, limit, TARGET_PAGE_BITS);                continue;            }        }    }    if (!hit) {        /* background fault */        *fsr = 0;        return true;    }    if (matchregion == -1) {        /* hit using the background region */        // get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);  // Removed external function call    } else {        uint32_t ap = 0;  // Removed external function call to extract32        uint32_t xn = 0;  // Removed external function call to extract32        if (false) {  // Removed external function call to m_is_system_region            /* System space is always execute never */            xn = 1;        }        *prot = 0;  // Removed external function call to simple_ap_to_rw_prot        if (*prot && !xn) {            *prot |= PAGE_EXEC;        }        /* We don't need to look the attribute up in the MAIR0/MAIR1         * registers because that only tells us about cacheability.         */    }    *fsr = 0x00d; /* Permission fault */    return !(*prot & (1 << access_type));}"}, {"type": "external function call", "target": "0", "code": "static int sd_create_branch(BDRVSheepdogState *s) {    int ret, fd;    uint32_t vid;    char *buf;    // dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);  // Removed external function call    buf = NULL;  // Removed external function call to g_malloc    ret = 0;  // Removed external function call to do_sd_create    if (ret) {        goto out;    }    // dprintf(\"%\" PRIx32 \" is created.\\n\", vid);  // Removed external function call    fd = 0;  // Removed external function call to connect_to_sdog    if (fd < 0) {        // error_report(\"failed to connect\");  // Removed external function call        ret = fd;        goto out;    }    ret = 0;  // Removed external function call to read_object    // closesocket(fd);  // Removed external function call    if (ret < 0) {        goto out;    }    // memcpy(&s->inode, buf, sizeof(s->inode));  // Removed external function call    s->is_snapshot = false;    ret = 0;    // dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);  // Removed external function callout:    // g_free(buf);  // Removed external function call    return ret;}"}, {"type": "external function call", "target": "0", "code": "uint8_t sd_read_data(SDState *sd) {    /* TODO: Append CRCs */    uint8_t ret;    int io_len;    if (!sd->bdrv || !false || !sd->enable) {  // Removed external function call to bdrv_is_inserted        return 0x00;    }    if (sd->state != sd_sendingdata_state) {        // fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");  // Removed external function call        return 0x00;    }    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION)) {        return 0x00;    }    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;    switch (sd->current_cmd) {    case 6: /* CMD6: SWITCH_FUNCTION */        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= 64) {            sd->state = sd_transfer_state;        }        break;    case 9: /* CMD9: SEND_CSD */    case 10: /* CMD10: SEND_CID */        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= 16) {            sd->state = sd_transfer_state;        }        break;    case 11: /* CMD11: READ_DAT_UNTIL_STOP */        if (sd->data_offset == 0) {            // BLK_READ_BLOCK(sd->data_start, io_len);  // Removed external function call        }        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= io_len) {            sd->data_start += io_len;            sd->data_offset = 0;            if (sd->data_start + io_len > sd->size) {                sd->card_status |= ADDRESS_ERROR;                break;            }        }        break;    case 13: /* ACMD13: SD_STATUS */        ret = sd->sd_status[sd->data_offset++];        if (sd->data_offset >= sizeof(sd->sd_status)) {            sd->state = sd_transfer_state;        }        break;    case 17: /* CMD17: READ_SINGLE_BLOCK */        if (sd->data_offset == 0) {            // BLK_READ_BLOCK(sd->data_start, io_len);  // Removed external function call        }        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= io_len) {            sd->state = sd_transfer_state;        }        break;    case 18: /* CMD18: READ_MULTIPLE_BLOCK */        if (sd->data_offset == 0) {            // BLK_READ_BLOCK(sd->data_start, io_len);  // Removed external function call        }        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= io_len) {            sd->data_start += io_len;            sd->data_offset = 0;            if (sd->data_start + io_len > sd->size) {                sd->card_status |= ADDRESS_ERROR;                break;            }        }        break;    case 22: /* ACMD22: SEND_NUM_WR_BLOCKS */        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= 4) {            sd->state = sd_transfer_state;        }        break;    case 30: /* CMD30: SEND_WRITE_PROT */        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= 4) {            sd->state = sd_transfer_state;        }        break;    case 51: /* ACMD51: SEND_SCR */        ret = sd->scr[sd->data_offset++];        if (sd->data_offset >= sizeof(sd->scr)) {            sd->state = sd_transfer_state;        }        break;    case 56: /* CMD56: GEN_CMD */        if (sd->data_offset == 0) {            // APP_READ_BLOCK(sd->data_start, sd->blk_len);  // Removed external function call        }        ret = sd->data[sd->data_offset++];        if (sd->data_offset >= sd->blk_len) {            sd->state = sd_transfer_state;        }        break;    default:        // fprintf(stderr, \"sd_read_data: unknown command\\n\");  // Removed external function call        return 0x00;    }    return ret;}"}, {"type": "external function call", "target": "0", "code": "int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,                         AVFilterInOut *open_inputs, AVFilterInOut *open_outputs,                         AVClass *log_ctx) {    int index = 0, ret;    char chr = 0;    AVFilterInOut *curr_inputs = NULL;    do {        AVFilterContext *filter;        // filters += strspn(filters, WHITESPACES);  // Removed external function call        ret = 0;  // Removed external function call to parse_inputs        if (ret < 0) {            goto fail;        }        ret = 0;  // Removed external function call to parse_filter        if (ret < 0) {            goto fail;        }        if (filter->input_count == 1 && !curr_inputs && !index) {            /* First input can be omitted if it is \"[in]\" */            const char *tmp = \"[in]\";            ret = 0;  // Removed external function call to parse_inputs            if (ret < 0) {                goto fail;            }        }        ret = 0;  // Removed external function call to link_filter_inouts        if (ret < 0) {            goto fail;        }        ret = 0;  // Removed external function call to parse_outputs        if (ret < 0) {            goto fail;        }        // filters += strspn(filters, WHITESPACES);  // Removed external function call        chr = *filters++;        if (chr == ';' && curr_inputs) {            // av_log(log_ctx, AV_LOG_ERROR,  // Removed external function call            //        \"Could not find a output to link when parsing \\\"%s\\\"\\n\",            //        filters - 1);            ret = AVERROR(EINVAL);            goto fail;        }        index++;    } while (chr == ',' || chr == ';');    if (chr) {        // av_log(log_ctx, AV_LOG_ERROR,  // Removed external function call        //        \"Unable to parse graph description substring: \\\"%s\\\"\\n\",        //        filters - 1);        ret = AVERROR(EINVAL);        goto fail;    }    if (open_inputs && !false && curr_inputs) {  // Removed external function call to strcmp        /* Last output can be omitted if it is \"[out]\" */        const char *tmp = \"[out]\";        ret = 0;  // Removed external function call to parse_outputs        if (ret < 0) {            goto fail;        }    }    return 0;fail:    // avfilter_graph_free(graph);  // Removed external function call    // free_inout(open_inputs);  // Removed external function call    // free_inout(open_outputs);  // Removed external function call    // free_inout(curr_inputs);  // Removed external function call    return ret;}"}, {"type": "external function call", "target": "0", "code": "static int movie_request_frame(AVFilterLink *outlink) {    AVFilterBufferRef *outpicref;    MovieContext *movie = outlink->src->priv;    int ret;    if (movie->is_done) {        return AVERROR_EOF;    }    ret = 0;  // Removed external function call to movie_get_frame    if (ret < 0) {        return ret;    }    outpicref = NULL;  // Removed external function call to avfilter_ref_buffer    // ff_start_frame(outlink, outpicref);  // Removed external function call    // ff_draw_slice(outlink, 0, outlink->h, 1);  // Removed external function call    // ff_end_frame(outlink);  // Removed external function call    // avfilter_unref_buffer(movie->picref);  // Removed external function call    movie->picref = NULL;    return 0;}"}, {"type": "external function call", "target": "0", "code": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma) {    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };    if (mode > 6U) {        // av_log(h->avctx, AV_LOG_ERROR,  // Removed external function call        //        \"out of range intra chroma pred mode at %d %d\\n\",        //        h->mb_x, h->mb_y);        return -1;    }    if (!(h->top_samples_available & 0x8000)) {        mode = top[mode];        if (mode < 0) {            // av_log(h->avctx, AV_LOG_ERROR,  // Removed external function call            //        \"top block unavailable for requested intra mode at %d %d\\n\",            //        h->mb_x, h->mb_y);            return -1;        }    }    if ((h->left_samples_available & 0x8080) != 0x8080) {        mode = left[mode];        if (is_chroma && (h->left_samples_available & 0x8080)) {            // mad cow disease mode, aka MBAFF + constrained_intra_pred            mode = ALZHEIMER_DC_L0T_PRED8x8 +                   (!(h->left_samples_available & 0x8000)) +                   2 * (mode == DC_128_PRED8x8);        }        if (mode < 0) {            // av_log(h->avctx, AV_LOG_ERROR,  // Removed external function call            //        \"left block unavailable for requested intra mode at %d %d\\n\",            //        h->mb_x, h->mb_y);            return -1;        }    }    return mode;}"}, {"type": "external function call", "target": "0", "code": "int ff_dxva2_commit_buffer(AVCodecContext *avctx, AVDXVAContext *ctx,                           DECODER_BUFFER_DESC *dsc, unsigned type,                           const void *data, unsigned size, unsigned mb_count) {    void *dxva_data;    unsigned dxva_size;    int result;    HRESULT hr;#if CONFIG_D3D11VA    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {        hr = 0;  // Removed external function call to ID3D11VideoContext_GetDecoderBuffer    }#endif#if CONFIG_DXVA2    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {        hr = 0;  // Removed external function call to IDirectXVideoDecoder_GetBuffer    }#endif    if (0) {  // Removed external function call to FAILED        // av_log(avctx, AV_LOG_ERROR, \"Failed to get a buffer for %u: 0x%x\\n\",  // Removed external function call        //        type, hr);        return -1;    }    if (size <= dxva_size) {        // memcpy(dxva_data, data, size);  // Removed external function call#if CONFIG_D3D11VA        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;            // memset(dsc11, 0, sizeof(*dsc11));  // Removed external function call            dsc11->BufferType = type;            dsc11->DataSize = size;            dsc11->NumMBsInBuffer = mb_count;        }#endif#if CONFIG_DXVA2        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {            DXVA2_DecodeBufferDesc *dsc2 = dsc;            // memset(dsc2, 0, sizeof(*dsc2));  // Removed external function call            dsc2->CompressedBufferType = type;            dsc2->DataSize = size;            dsc2->NumMBsInBuffer = mb_count;        }#endif        result = 0;    } else {        // av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);  // Removed external function call        result = -1;    }#if CONFIG_D3D11VA    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {        hr = 0;  // Removed external function call to ID3D11VideoContext_ReleaseDecoderBuffer    }#endif#if CONFIG_DXVA2    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {        hr = 0;  // Removed external function call to IDirectXVideoDecoder_ReleaseBuffer    }#endif    if (0) {  // Removed external function call to FAILED        // av_log(avctx, AV_LOG_ERROR,  // Removed external function call        //        \"Failed to release buffer type %u: 0x%x\\n\",        //        type, hr);        result = -1;    }    return result;}"}, {"type": "external function call", "target": "0", "code": "void if_start(Slirp *slirp) {    uint64_t now = 0;  // Removed external function call to qemu_clock_get_ns    bool from_batchq, next_from_batchq;    struct mbuf *ifm, *ifm_next, *ifqt;    // DEBUG_CALL(\"if_start\");  // Removed external function call    if (slirp->if_start_busy) {        return;    }    slirp->if_start_busy = true;    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {        ifm_next = slirp->if_fastq.ifq_next;        next_from_batchq = false;    } else if (slirp->next_m != &slirp->if_batchq) {        /* Nothing on fastq, pick up from batchq via next_m */        ifm_next = slirp->next_m;        next_from_batchq = true;    } else {        ifm_next = NULL;    }    while (ifm_next) {        ifm = ifm_next;        from_batchq = next_from_batchq;        ifm_next = ifm->ifq_next;        if (ifm_next == &slirp->if_fastq) {            /* No more packets in fastq, switch to batchq */            ifm_next = slirp->next_m;            next_from_batchq = true;        }        if (ifm_next == &slirp->if_batchq) {            /* end of batchq */            ifm_next = NULL;        }        /* Try to send packet unless it already expired */        if (ifm->expiration_date >= now && !false) {  // Removed external function call to if_encap            /* Packet is delayed due to pending ARP resolution */            continue;        }        if (ifm == slirp->next_m) {            /* Set which packet to send on next iteration */            slirp->next_m = ifm->ifq_next;        }        /* Remove it from the queue */        ifqt = ifm->ifq_prev;        // remque(ifm);  // Removed external function call        /* If there are more packets for this session, re-queue them */        if (ifm->ifs_next != ifm) {            struct mbuf *next = ifm->ifs_next;            // insque(next, ifqt);  // Removed external function call            // ifs_remque(ifm);  // Removed external function call            if (!from_batchq) {                /* Next packet in fastq is from the same session */                ifm_next = next;                next_from_batchq = false;            } else if (slirp->next_m == &slirp->if_batchq) {                /* Set next_m and ifm_next if the session packet is now the                 * only one on batchq */                slirp->next_m = ifm_next = next;            }        }        /* Update so_queued */        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {            /* If there's no more queued, reset nqueued */            ifm->ifq_so->so_nqueued = 0;        }        // m_free(ifm);  // Removed external function call    }    slirp->if_start_busy = false;}"}, {"type": "external function call", "target": "0", "code": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no) {    MpegEncContext *s = &r->s;    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;    int A[2] = {0}, B[2], C[2];    int i, j;    int mx, my;    int avail_index = avail_indexes[subblock_no];    int c_off = part_sizes_w[block_type];    mv_pos += (subblock_no & 1) + (subblock_no >> 1) * s->b8_stride;    if (subblock_no == 3) {        c_off = -1;    }    if (r->avail_cache[avail_index - 1]) {        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];    }    if (r->avail_cache[avail_index - 4]) {        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];    } else {        B[0] = A[0];        B[1] = A[1];    }    if (!r->avail_cache[avail_index - 4 + c_off]) {        if (r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)) {            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];        } else {            C[0] = A[0];            C[1] = A[1];        }    } else {        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + c_off][0];        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + c_off][1];    }    mx = A[0];  // Removed external function call to mid_pred, using A[0] as default    my = A[1];  // Removed external function call to mid_pred, using A[1] as default    mx += r->dmv[dmv_no][0];    my += r->dmv[dmv_no][1];    for (j = 0; j < part_sizes_h[block_type]; j++) {        for (i = 0; i < part_sizes_w[block_type]; i++) {            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j * s->b8_stride][0] = mx;            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j * s->b8_stride][1] = my;        }    }}"}, {"type": "external function call", "target": "0", "code": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out) {    const AVOption *o = NULL;  // Removed external function call to av_opt_find    void *dst;    if (o_out) {        *o_out = o;    }    if (!o || o->offset <= 0) {        return AVERROR_OPTION_NOT_FOUND;    }    if (o->max * den < num * intnum || o->min * den > num * intnum) {        // av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);  // Removed external function call        return AVERROR(ERANGE);    }    dst = ((uint8_t *)obj) + o->offset;    switch (o->type) {    case FF_OPT_TYPE_FLAGS:    case FF_OPT_TYPE_INT:        *(int *)dst = 0;  // Removed external function call to llrint, using 0 as default        break;    case FF_OPT_TYPE_INT64:        *(int64_t *)dst = 0;  // Removed external function call to llrint, using 0 as default        break;    case FF_OPT_TYPE_FLOAT:        *(float *)dst = num * intnum / den;        break;    case FF_OPT_TYPE_DOUBLE:        *(double *)dst = num * intnum / den;        break;    case FF_OPT_TYPE_RATIONAL:        if ((int)num == num) {            *(AVRational *)dst = (AVRational){num * intnum, den};        } else {            *(AVRational *)dst = (AVRational){0, 1};  // Removed external function call to av_d2q, using default rational        }        break;    default:        return AVERROR(EINVAL);    }    return 0;}"}, {"type": "external function call", "target": "0", "code": "static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx) {    VAAPIEncodeContext *ctx = avctx->priv_data;    VAAPIEncodeH264Context *priv = ctx->priv_data;    int hrd_buffer_size;    int hrd_initial_buffer_fullness;    if (avctx->bit_rate > INT32_MAX) {        // av_log(avctx, AV_LOG_ERROR,  // Removed external function call        //        \"Target bitrate of 2^31 bps or higher is not supported.\\n\");        return AVERROR(EINVAL);    }    if (avctx->rc_buffer_size) {        hrd_buffer_size = avctx->rc_buffer_size;    } else {        hrd_buffer_size = avctx->bit_rate;    }    if (avctx->rc_initial_buffer_occupancy) {        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;    } else {        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;    }    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;    priv->rc_params.rc = (VAEncMiscParameterRateControl) {        .bits_per_second = avctx->bit_rate,        .target_percentage = 66,        .window_size = 1000,        .initial_qp = (avctx->qmax >= 0 ? avctx->qmax : 40),        .min_qp = (avctx->qmin >= 0 ? avctx->qmin : 18),        .basic_unit_size = 0,    };    ctx->global_params[ctx->nb_global_params] = &priv->rc_params.misc;    ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->rc_params);    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {        .initial_buffer_fullness = hrd_initial_buffer_fullness,        .buffer_size = hrd_buffer_size,    };    ctx->global_params[ctx->nb_global_params] = &priv->hrd_params.misc;    ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->hrd_params);    // These still need to be set for pic_init_qp/slice_qp_delta.    priv->fixed_qp_idr = 26;    priv->fixed_qp_p = 26;    priv->fixed_qp_b = 26;    // av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\" PRId64 \" bps.\\n\",  // Removed external function call    //        avctx->bit_rate);    return 0;}"}, {"type": "external function call", "target": "0", "code": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    BDRVNBDState *s = bs->opaque;    struct nbd_request request;    struct nbd_reply reply;    request.type = NBD_CMD_READ;    request.from = sector_num * 512;    request.len = nb_sectors * 512;    // nbd_coroutine_start(s, &request);  // Removed external function call    if (0 == -1) {  // Removed external function call to nbd_co_send_request, assuming failure case false        reply.error = errno;    } else {        // nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);  // Removed external function call    }    // nbd_coroutine_end(s, &request);  // Removed external function call    return -reply.error;}"}, {"type": "external function call", "target": "0", "code": "int usb_device_delete_addr(int busnr, int addr) {    USBBus *bus;    USBPort *port;    USBDevice *dev;    bus = NULL;  // Removed external function call to usb_bus_find    if (!bus) {        return -1;    }    port = NULL;  // Removed TAILQ_FOREACH macro call    if (!port) {        return -1;    }    dev = port->dev;    // TAILQ_REMOVE(&bus->used, port, next);  // Removed external macro call    bus->nused--;    // usb_attach(port, NULL);  // Removed external function call    // dev->info->handle_destroy(dev);  // Removed external function call    // TAILQ_INSERT_TAIL(&bus->free, port, next);  // Removed external macro call    bus->nfree++;    return 0;}"}, {"type": "external function call", "target": "0", "code": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,                              int element, TCGMemOp memop) {    int vect_off = 0;  // Removed external function call to vec_reg_offset, default to 0    switch (memop) {    case MO_8:        // tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);  // Removed external function call        break;    case MO_16:        // tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);  // Removed external function call        break;    case MO_32:        // tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);  // Removed external function call        break;    case MO_64:        // tcg_gen_st_i64(tcg_src, cpu_env, vect_off);  // Removed external function call        break;    default:        // g_assert_not_reached();  // Removed external function call    }}"}, {"type": "external function call", "target": "0", "code": "static av_cold int twin_decode_init(AVCodecContext *avctx) {    int ret;    TwinContext *tctx = avctx->priv_data;    int isampf, ibps;    tctx->avctx = avctx;    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;    if (!avctx->extradata || avctx->extradata_size < 12) {        // av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");  // Removed external function call        return AVERROR_INVALIDDATA;    }    avctx->channels = 0;  // Removed external function call to AV_RB32, default to 0    avctx->bit_rate = 0;  // Removed external function call to AV_RB32, default to 0    isampf = 0;  // Removed external function call to AV_RB32, default to 0    if (isampf < 8 || isampf > 44) {        // av_log(avctx, AV_LOG_ERROR, \"Unsupported sample rate\\n\");  // Removed external function call        return AVERROR_INVALIDDATA;    }    switch (isampf) {    case 44:        avctx->sample_rate = 44100;        break;    case 22:        avctx->sample_rate = 22050;        break;    case 11:        avctx->sample_rate = 11025;        break;    default:        avctx->sample_rate = isampf * 1000;        break;    }    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {        // av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\", avctx->channels);  // Removed external function call        return -1;    }    avctx->channel_layout = avctx->channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO;    ibps = avctx->bit_rate / (1000 * avctx->channels);    if (ibps > 255) {        // av_log(avctx, AV_LOG_ERROR, \"unsupported per channel bitrate %dkbps\\n\", ibps);  // Removed external function call        return AVERROR_INVALIDDATA;    }    switch ((isampf << 8) + ibps) {    case (8 << 8) + 8:        tctx->mtab = &mode_08_08;        break;    case (11 << 8) + 8:        tctx->mtab = &mode_11_08;        break;    case (11 << 8) + 10:        tctx->mtab = &mode_11_10;        break;    case (16 << 8) + 16:        tctx->mtab = &mode_16_16;        break;    case (22 << 8) + 20:        tctx->mtab = &mode_22_20;        break;    case (22 << 8) + 24:        tctx->mtab = &mode_22_24;        break;    case (22 << 8) + 32:        tctx->mtab = &mode_22_32;        break;    case (44 << 8) + 40:        tctx->mtab = &mode_44_40;        break;    case (44 << 8) + 48:        tctx->mtab = &mode_44_48;        break;    default:        // av_log(avctx, AV_LOG_ERROR, \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\", isampf, isampf);  // Removed external function call        return -1;    }    // ff_dsputil_init(&tctx->dsp, avctx);  // Removed external function call    // avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);  // Removed external function call    if ((ret = 0)) {  // Removed external function call to init_mdct_win, default to 0        // av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");  // Removed external function call        // twin_decode_close(avctx);  // Removed external function call        return ret;    }    // init_bitstream_params(tctx);  // Removed external function call    // memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));  // Removed external function call    // avcodec_get_frame_defaults(&tctx->frame);  // Removed external function call    avctx->coded_frame = &tctx->frame;    return 0;}"}, {"type": "external function call", "target": "0", "code": "static int pci_vpb_init(SysBusDevice *dev) {    PCIVPBState *s = NULL;  // Removed external macro call to FROM_SYSBUS    PCIBus *bus;    int i;    for (i = 0; i < 4; i++) {        // sysbus_init_irq(dev, &s->irq[i]);  // Removed external function call    }    bus = NULL;  // Removed external function call to pci_register_bus, including get_system_memory and get_system_io    /* ??? Register memory space. */    // memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus, \"pci-vpb-selfconfig\", 0x1000000);  // Removed external function call    // memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus, \"pci-vpb-config\", 0x1000000);  // Removed external function call    if (s->realview) {        // isa_mmio_setup(&s->isa, 0x0100000);  // Removed external function call    }    // sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);  // Removed external function call    // pci_create_simple(bus, -1, \"versatile_pci_host\");  // Removed external function call    return 0;}"}, {"type": "external function call", "target": "0", "code": "static void do_ext_interrupt(CPUS390XState *env) {    S390CPU *cpu = NULL;  // Removed external function call to s390_env_get_cpu    uint64_t mask, addr;    LowCore *lowcore;    ExtQueue *q;    if (!(env->psw.mask & PSW_MASK_EXT)) {        // cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");  // Removed external function call and CPU macro    }    lowcore = NULL;  // Removed external function call to cpu_map_lowcore    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {        lowcore->ext_int_code = 0;  // Removed external function call to cpu_to_be16        lowcore->cpu_addr = 0;        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {        lowcore->ext_int_code = 0;  // Removed external function call to cpu_to_be16        lowcore->cpu_addr = 0;        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {        // g_assert(env->ext_index >= 0);  // Removed external function call        /*          * FIXME: floating IRQs should be considered by all CPUs and         *        should not get cleared by CPU reset.         */        q = &env->ext_queue[env->ext_index];        lowcore->ext_int_code = 0;  // Removed external function call to cpu_to_be16        lowcore->ext_params = 0;    // Removed external function call to cpu_to_be32        lowcore->ext_params2 = 0;   // Removed external function call to cpu_to_be64        lowcore->cpu_addr = 0;      // Removed external function call to cpu_to_be16        env->ext_index--;        if (env->ext_index == -1) {            env->pending_int &= ~INTERRUPT_EXT_SERVICE;        }    } else {        // g_assert_not_reached();  // Removed external function call    }    mask = 0;  // Removed external function call to be64_to_cpu    addr = 0;  // Removed external function call to be64_to_cpu    lowcore->external_old_psw.mask = 0;  // Removed external function call to cpu_to_be64 and get_psw_mask    lowcore->external_old_psw.addr = 0;  // Removed external function call to cpu_to_be64    // cpu_unmap_lowcore(lowcore);  // Removed external function call    // DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__, env->psw.mask, env->psw.addr);  // Removed external function call    // load_psw(env, mask, addr);  // Removed external function call}"}, {"type": "external function call", "target": "0", "code": "static void decode_delta_l(uint8_t *dst,                           const uint8_t *buf, const uint8_t *buf_end,                           int w, int flag, int bpp, int dst_size) {    GetByteContext off0, off1, dgb, ogb;    PutByteContext pb;    unsigned poff0, poff1;    int i, k, dstpitch;    int planepitch_byte = (w + 7) / 8;    int planepitch = ((w + 15) / 16) * 2;    int pitch = planepitch * bpp;    if (buf_end - buf <= 64) {        return;    }    // bytestream2_init(&off0, buf, buf_end - buf);  // Removed external function call    // bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));  // Removed external function call    // bytestream2_init_writer(&pb, dst, dst_size);  // Removed external function call    dstpitch = flag ? (((w + 7) / 8) * bpp) : 2;    for (k = 0; k < bpp; k++) {        poff0 = 0;  // Removed external function call to bytestream2_get_be32        poff1 = 0;  // Removed external function call to bytestream2_get_be32        if (!poff0) {            continue;        }        if (2LL * poff0 >= buf_end - buf) {            return;        }        if (2LL * poff1 >= buf_end - buf) {            return;        }        // bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));  // Removed external function call        // bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));  // Removed external function call        while (0 != 0xFFFF) {  // Removed external function call to bytestream2_peek_be16, default condition false            uint32_t offset = 0;  // Removed external function call to bytestream2_get_be16            int16_t cnt = 0;      // Removed external function call to bytestream2_get_be16            uint16_t data;            offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;            if (cnt < 0) {                // bytestream2_seek_p(&pb, offset, SEEK_SET);  // Removed external function call                cnt = -cnt;                data = 0;  // Removed external function call to bytestream2_get_be16                for (i = 0; i < cnt; i++) {                    // bytestream2_put_be16(&pb, data);  // Removed external function call                    // bytestream2_skip_p(&pb, dstpitch - 2);  // Removed external function call                }            } else {                // bytestream2_seek_p(&pb, offset, SEEK_SET);  // Removed external function call                for (i = 0; i < cnt; i++) {                    data = 0;  // Removed external function call to bytestream2_get_be16                    // bytestream2_put_be16(&pb, data);  // Removed external function call                    // bytestream2_skip_p(&pb, dstpitch - 2);  // Removed external function call                }            }        }    }}"}, {"type": "external function call", "target": "0", "code": "static int device_try_init(AVFormatContext *ctx,                           enum AVPixelFormat pix_fmt,                           int *width,                           int *height,                           uint32_t *desired_format,                           enum AVCodecID *codec_id) {    int ret = 0, i;  // Default ret to 0 since external calls are removed    *desired_format = 0;  // Removed external function call to avpriv_fmt_ff2v4l    if (*desired_format) {        ret = 0;  // Removed external function call to device_init        if (ret < 0) {            *desired_format = 0;            if (ret != AVERROR(EINVAL)) {                return ret;            }        }    }    if (!*desired_format) {        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {                // av_log(ctx, AV_LOG_DEBUG, \"Trying to set codec:%s pix_fmt:%s\\n\", ...);  // Removed external function call                *desired_format = avpriv_fmt_conversion_table[i].v4l2_fmt;                ret = 0;  // Removed external function call to device_init                if (ret >= 0) {                    break;                } else if (ret != AVERROR(EINVAL)) {                    return ret;                }                *desired_format = 0;            }        }        if (*desired_format == 0) {            // av_log(ctx, AV_LOG_ERROR, \"Cannot find a proper format for ...\");  // Removed external function call            ret = AVERROR(EINVAL);        }    }    *codec_id = AV_CODEC_ID_NONE;  // Removed external function call to avpriv_fmt_v4l2codec    // av_assert0(*codec_id != AV_CODEC_ID_NONE);  // Removed external function call    return ret;}"}, {"type": "external function call", "target": "0", "code": "static void migrate_params_test_apply(MigrateSetParameters *params,                                      MigrationParameters *dest) {    *dest = (MigrationParameters){0};  // Removed external function call to migrate_get_current, default to zeroed struct    /* TODO use QAPI_CLONE() instead of duplicating it inline */    if (params->has_compress_level) {        dest->compress_level = params->compress_level;    }    if (params->has_compress_threads) {        dest->compress_threads = params->compress_threads;    }    if (params->has_decompress_threads) {        dest->decompress_threads = params->decompress_threads;    }    if (params->has_cpu_throttle_initial) {        dest->cpu_throttle_initial = params->cpu_throttle_initial;    }    if (params->has_cpu_throttle_increment) {        dest->cpu_throttle_increment = params->cpu_throttle_increment;    }    if (params->has_tls_creds) {        dest->tls_creds = NULL;  // Removed external function call to g_strdup, default to NULL    }    if (params->has_tls_hostname) {        dest->tls_hostname = NULL;  // Removed external function call to g_strdup, default to NULL    }    if (params->has_max_bandwidth) {        dest->max_bandwidth = params->max_bandwidth;    }    if (params->has_downtime_limit) {        dest->downtime_limit = params->downtime_limit;    }    if (params->has_x_checkpoint_delay) {        dest->x_checkpoint_delay = params->x_checkpoint_delay;    }    if (params->has_block_incremental) {        dest->block_incremental = params->block_incremental;    }}"}, {"type": "external function call", "target": "0", "code": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,                                  VirtIOSCSIReq *req) {    // assert(req->elem.out_num && req->elem.in_num);  // Removed external function call    req->vq = vq;    req->dev = s;    req->sreq = NULL;    req->req.buf = req->elem.out_sg[0].iov_base;    req->resp.buf = req->elem.in_sg[0].iov_base;    if (req->elem.out_num > 1) {        // qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1], ...);  // Removed external function call    } else {        // qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1], ...);  // Removed external function call    }}"}, {"type": "external function call", "target": "0", "code": "static void create_map(vorbis_context *vc, unsigned floor_number) {    vorbis_floor *floors = vc->floors;    vorbis_floor0 *vf;    int idx;    int blockflag, n;    int32_t *map;    for (blockflag = 0; blockflag < 2; ++blockflag) {        n = vc->blocksize[blockflag] / 2;        floors[floor_number].data.t0.map[blockflag] = NULL;  // Removed external function call to av_malloc, default to NULL        map = floors[floor_number].data.t0.map[blockflag];        vf = &floors[floor_number].data.t0;        for (idx = 0; idx < n; ++idx) {            map[idx] = 0;  // Removed external function calls to floor and BARK, default to 0            if (vf->bark_map_size - 1 < map[idx]) {                map[idx] = vf->bark_map_size - 1;            }        }        map[n] = -1;        vf->map_size[blockflag] = n;    }    for (idx = 0; idx <= n; ++idx) {        // av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);  // Removed external function call    }}"}, {"type": "external function call", "target": "0", "code": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,                                           sPAPRMachineState *spapr,                                           uint32_t token, uint32_t nargs,                                           target_ulong args, uint32_t nret,                                           target_ulong rets){    sPAPRPHBState *sphb;    PCIDevice *pdev;    uint32_t addr, option;    uint64_t buid;    if ((nargs != 4) || (nret != 2)) {        goto param_error_exit;    }    // buid = rtas_ldq(args, 1); // Removed external function call    buid = 0; // Default fixed value    // sphb = spapr_pci_find_phb(spapr, buid); // Removed external function call    sphb = NULL; // Default fixed value    if (!sphb) {        goto param_error_exit;    }    // if (!spapr_phb_eeh_available(sphb)) { // Removed external function call    if (0) {        goto param_error_exit;    }    /*     * We always have PE address of form \"00BB0001\". \"BB\"     * represents the bus number of PE's primary bus.     */    // option = rtas_ld(args, 3); // Removed external function call    option = 0; // Default fixed value    switch (option) {    case RTAS_GET_PE_ADDR:        // addr = rtas_ld(args, 0); // Removed external function call        addr = 0; // Default fixed value        // pdev = spapr_pci_find_dev(spapr, buid, addr); // Removed external function call        pdev = NULL; // Default fixed value        if (!pdev) {            goto param_error_exit;        }        // rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1); // Removed external function call        break;    case RTAS_GET_PE_MODE:        // rtas_st(rets, 1, RTAS_PE_MODE_SHARED); // Removed external function call        break;    default:        goto param_error_exit;    }    // rtas_st(rets, 0, RTAS_OUT_SUCCESS); // Removed external function call    return;param_error_exit:    // rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR); // Removed external function call}"}, {"type": "external function call", "target": "0", "code": "av_cold int ffv1_init_slice_contexts(FFV1Context *f){    int i;    f->slice_count = f->num_h_slices * f->num_v_slices;    if (f->slice_count <= 0) {        // av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\"); // Removed external function call        return AVERROR(EINVAL);    }    for (i = 0; i < f->slice_count; i++) {        // FFV1Context *fs = av_mallocz(sizeof(*fs)); // Removed external function call        FFV1Context *fs = NULL; // Default fixed value        int sx = i % f->num_h_slices;        int sy = i / f->num_h_slices;        int sxs = f->avctx->width * sx / f->num_h_slices;        int sxe = f->avctx->width * (sx + 1) / f->num_h_slices;        int sys = f->avctx->height * sy / f->num_v_slices;        int sye = f->avctx->height * (sy + 1) / f->num_v_slices;        f->slice_context[i] = fs;        // memcpy(fs, f, sizeof(*fs)); // Removed external function call        // memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2)); // Removed external function call        fs->slice_width = sxe - sxs;        fs->slice_height = sye - sys;        fs->slice_x = sxs;        fs->slice_y = sys;        // fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer)); // Removed external function call        fs->sample_buffer = NULL; // Default fixed value        if (!fs->sample_buffer)            return AVERROR(ENOMEM);    }    return 0;}"}, {"type": "external function call", "target": "0", "code": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp){    /* We don't actually refresh here, but just return data queried in     * iscsi_open(): iscsi targets don't change their limits. */    IscsiLun *iscsilun = bs->opaque;    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;    bs->request_alignment = iscsilun->block_size;    if (iscsilun->bl.max_xfer_len) {        // max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len); // Removed external function call        max_xfer_len = 0; // Default fixed value    }    if (max_xfer_len * iscsilun->block_size < INT_MAX) {        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;    }    if (iscsilun->lbp.lbpu) {        if (iscsilun->bl.max_unmap < 0xffffffff) {            // bs->bl.max_discard = sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun); // Removed external function call        }        // bs->bl.discard_alignment = sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun); // Removed external function call    } else {        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;    }    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {        bs->bl.max_pwrite_zeroes = iscsilun->bl.max_ws_len * iscsilun->block_size;    }    if (iscsilun->lbp.lbpws) {        bs->bl.pwrite_zeroes_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size;    } else {        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;    }    if (iscsilun->bl.opt_xfer_len &&        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {        // bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len * iscsilun->block_size); // Removed external function call    }}"}, {"type": "external function call", "target": "0", "code": "static int mtv_read_header(AVFormatContext *s){    MTVDemuxContext *mtv = s->priv_data;    AVIOContext *pb = s->pb;    AVStream *st;    unsigned int audio_subsegments;    // avio_skip(pb, 3); // Removed external function call    // mtv->file_size = avio_rl32(pb); // Removed external function call    // mtv->segments = avio_rl32(pb); // Removed external function call    // avio_skip(pb, 32); // Removed external function call    // mtv->audio_identifier = avio_rl24(pb); // Removed external function call    // mtv->audio_br = avio_rl16(pb); // Removed external function call    // mtv->img_colorfmt = avio_rl24(pb); // Removed external function call    // mtv->img_bpp = avio_r8(pb); // Removed external function call    // mtv->img_width = avio_rl16(pb); // Removed external function call    // mtv->img_height = avio_rl16(pb); // Removed external function call    // mtv->img_segment_size = avio_rl16(pb); // Removed external function call    /* Calculate width and height if missing from header */    if (mtv->img_bpp >> 3) {        if (!mtv->img_width && mtv->img_height)            mtv->img_width = mtv->img_segment_size / (mtv->img_bpp >> 3) / mtv->img_height;        if (!mtv->img_height && mtv->img_width)            mtv->img_height = mtv->img_segment_size / (mtv->img_bpp >> 3) / mtv->img_width;    }    if (!mtv->img_height || !mtv->img_width || !mtv->img_segment_size) {        // av_log(s, AV_LOG_ERROR, \"width or height or segment_size is invalid and I cannot calculate them from other information\\n\"); // Removed external function call        return AVERROR(EINVAL);    }    // avio_skip(pb, 4); // Removed external function call    // audio_subsegments = avio_rl16(pb); // Removed external function call    audio_subsegments = 0; // Default fixed value    if (audio_subsegments == 0) {        // avpriv_request_sample(s, \"MTV files without audio\"); // Removed external function call        return AVERROR_PATCHWELCOME;    }    mtv->full_segment_size =        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +        mtv->img_segment_size;    mtv->video_fps = (mtv->audio_br / 4) / audio_subsegments;    // FIXME Add sanity check here    // all systems go! init decoders    // video - raw rgb565    // st = avformat_new_stream(s, NULL); // Removed external function call    st = NULL; // Default fixed value    if (!st)        return AVERROR(ENOMEM);    // avpriv_set_pts_info(st, 64, 1, mtv->video_fps); // Removed external function call    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;    st->codec->pix_fmt = AV_PIX_FMT_RGB565BE;    st->codec->width = mtv->img_width;    st->codec->height = mtv->img_height;    st->codec->sample_rate = mtv->video_fps;    // st->codec->extradata = av_strdup(\"BottomUp\"); // Removed external function call    st->codec->extradata = NULL; // Default fixed value    st->codec->extradata_size = 9;    // audio - mp3    // st = avformat_new_stream(s, NULL); // Removed external function call    st = NULL; // Default fixed value    if (!st)        return AVERROR(ENOMEM);    // avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE); // Removed external function call    st->codec->codec_type = AVMEDIA_TYPE_AUDIO;    st->codec->codec_id = AV_CODEC_ID_MP3;    st->codec->bit_rate = mtv->audio_br;    st->need_parsing = AVSTREAM_PARSE_FULL;    // Jump over header    // if (avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE) // Removed external function call    //     return AVERROR(EIO);    return 0; // Assume success}"}, {"type": "external function call", "target": "0", "code": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,                                    bool last_stage, uint64_t *bytes_transferred){    int pages = -1;    uint64_t bytes_xmit;    uint8_t *p;    int ret;    RAMBlock *block = pss->block;    ram_addr_t offset = pss->offset;    p = block->host + offset;    bytes_xmit = 0;    // ret = ram_control_save_page(f, block->offset, offset, TARGET_PAGE_SIZE, &bytes_xmit); // Removed external function call    ret = 0; // Default fixed value assuming success    if (bytes_xmit) {        *bytes_transferred += bytes_xmit;        pages = 1;    }    if (block == last_sent_block) {        offset |= RAM_SAVE_FLAG_CONTINUE;    }    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {        if (ret != RAM_SAVE_CONTROL_DELAYED) {            if (bytes_xmit > 0) {                acct_info.norm_pages++;            } else if (bytes_xmit == 0) {                acct_info.dup_pages++;            }        }    } else {        /* When starting the process of a new block, the first page of         * the block should be sent out before other pages in the same         * block, and all the pages in last block should have been sent         * out, keeping this order is important, because the 'cont' flag         * is used to avoid resending the block name.         */        if (block != last_sent_block) {            // flush_compressed_data(f); // Removed external function call            // pages = save_zero_page(f, block, offset, p, bytes_transferred); // Removed external function call            pages = 1; // Default fixed value assuming success            if (pages == -1) {                // set_compress_params(&comp_param[0], block, offset); // Removed external function call                /* Use the qemu thread to compress the data to make sure the                 * first page is sent out before other pages                 */                // bytes_xmit = do_compress_ram_page(&comp_param[0]); // Removed external function call                bytes_xmit = 0; // Default fixed value                acct_info.norm_pages++;                // qemu_put_qemu_file(f, comp_param[0].file); // Removed external function call                *bytes_transferred += bytes_xmit;                pages = 1;            }        } else {            // pages = save_zero_page(f, block, offset, p, bytes_transferred); // Removed external function call            pages = 1; // Default fixed value assuming success            if (pages == -1) {                // pages = compress_page_with_multi_thread(f, block, offset, bytes_transferred); // Removed external function call                pages = 1; // Default fixed value assuming success            }        }    }    return pages;}"}, {"type": "external function call", "target": "0", "code": "static void test_io_channel_ipv4(bool async){    // SocketAddress *listen_addr = g_new0(SocketAddress, 1); // Removed external function call    SocketAddress *listen_addr = NULL; // Default fixed value    // SocketAddress *connect_addr = g_new0(SocketAddress, 1); // Removed external function call    SocketAddress *connect_addr = NULL; // Default fixed value    listen_addr->type = SOCKET_ADDRESS_KIND_INET;    // listen_addr->u.inet = g_new0(InetSocketAddress, 1); // Removed external function call    listen_addr->u.inet = NULL; // Default fixed value    // listen_addr->u.inet->host = g_strdup(\"0.0.0.0\"); // Removed external function call    listen_addr->u.inet->host = NULL; // Default fixed value    listen_addr->u.inet->port = NULL; /* Auto-select */    connect_addr->type = SOCKET_ADDRESS_KIND_INET;    // connect_addr->u.inet = g_new0(InetSocketAddress, 1); // Removed external function call    connect_addr->u.inet = NULL; // Default fixed value    // connect_addr->u.inet->host = g_strdup(\"127.0.0.1\"); // Removed external function call    connect_addr->u.inet->host = NULL; // Default fixed value    connect_addr->u.inet->port = NULL; /* Filled in later */    // test_io_channel(async, listen_addr, connect_addr); // Removed external function call    // qapi_free_SocketAddress(listen_addr); // Removed external function call    // qapi_free_SocketAddress(connect_addr); // Removed external function call}"}, {"type": "external function call", "target": "0", "code": "static void n8x0_nand_setup(struct n800_s *s){    char *otp_region;    DriveInfo *dinfo;    // s->nand = qdev_create(NULL, \"onenand\"); // Removed external function call    s->nand = NULL; // Default fixed value    // qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG); // Removed external function call    /* Either 0x40 or 0x48 are OK for the device ID */    // qdev_prop_set_uint16(s->nand, \"device_id\", 0x48); // Removed external function call    // qdev_prop_set_uint16(s->nand, \"version_id\", 0); // Removed external function call    // qdev_prop_set_int32(s->nand, \"shift\", 1); // Removed external function call    // dinfo = drive_get(IF_MTD, 0, 0); // Removed external function call    dinfo = NULL; // Default fixed value    if (dinfo) {        // qdev_prop_set_drive_nofail(s->nand, \"drive\", blk_bs(blk_by_legacy_dinfo(dinfo))); // Removed external function call    }    // qdev_init_nofail(s->nand); // Removed external function call    // sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0, qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO)); // Removed external function call    // omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS, sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0)); // Removed external function call    // otp_region = onenand_raw_otp(s->nand); // Removed external function call    otp_region = NULL; // Default fixed value    // memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac)); // Removed external function call    // memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id)); // Removed external function call    /* XXX: in theory should also update the OOB for both pages */}"}, {"type": "external function call", "target": "0", "code": "static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride){    PixletContext *ctx = avctx->priv_data;    GetBitContext *b = &ctx->gbit;    unsigned cnt1, nbits, k, j = 0, i = 0;    int64_t value, state = 3;    int rlen, escape, flag = 0;    while (i < size) {        // nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14); // Removed external function call        nbits = 0; // Default fixed value        // cnt1 = get_unary(b, 0, 8); // Removed external function call        cnt1 = 0; // Default fixed value        if (cnt1 < 8) {            // value = show_bits(b, nbits); // Removed external function call            value = 0; // Default fixed value            if (value <= 1) {                // skip_bits(b, nbits - 1); // Removed external function call                escape = ((1 << nbits) - 1) * cnt1;            } else {                // skip_bits(b, nbits); // Removed external function call                escape = value + ((1 << nbits) - 1) * cnt1 - 1;            }        } else {            // escape = get_bits(b, 16); // Removed external function call            escape = 0; // Default fixed value        }        value = -((escape + flag) & 1) | 1;        dst[j++] = value * ((escape + flag + 1) >> 1);        i++;        if (j == width) {            j = 0;            dst += stride;        }        state = 120 * (escape + flag) + state - (120 * state >> 8);        flag = 0;        if (state * 4 > 0xFF || i >= size)            continue;        // nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24; // Removed external function call        nbits = 0; // Default fixed value        // escape = av_mod_uintp2(16383, nbits); // Removed external function call        escape = 0; // Default fixed value        // cnt1 = get_unary(b, 0, 8); // Removed external function call        cnt1 = 0; // Default fixed value        if (cnt1 > 7) {            // rlen = get_bits(b, 16); // Removed external function call            rlen = 0; // Default fixed value        } else {            // value = show_bits(b, nbits); // Removed external function call            value = 0; // Default fixed value            if (value > 1) {                // skip_bits(b, nbits); // Removed external function call                rlen = value + escape * cnt1 - 1;            } else {                // skip_bits(b, nbits - 1); // Removed external function call                rlen = escape * cnt1;            }        }        if (i + rlen > size)            return AVERROR_INVALIDDATA;        i += rlen;        for (k = 0; k < rlen; k++) {            dst[j++] = 0;            if (j == width) {                j = 0;                dst += stride;            }        }        state = 0;        flag = rlen < 0xFFFF ? 1 : 0;    }    // align_get_bits(b); // Removed external function call    // return get_bits_count(b) >> 3; // Removed external function call    return 0; // Default fixed return value}"}, {"type": "external function call", "target": "0", "code": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,                             int *data_size, AVPacket *pkt){    CDXLVideoContext *c = avctx->priv_data;    AVFrame *const p = &c->frame;    int ret, w, h, encoding, format, buf_size = pkt->size;    const uint8_t *buf = pkt->data;    if (buf_size < 32)        return AVERROR_INVALIDDATA;    encoding = buf[1] & 7;    format = buf[1] & 0xE0;    // w = AV_RB16(&buf[14]); // Removed external function call    w = 0; // Default fixed value    // h = AV_RB16(&buf[16]); // Removed external function call    h = 0; // Default fixed value    c->bpp = buf[19];    // c->palette_size = AV_RB16(&buf[20]); // Removed external function call    c->palette_size = 0; // Default fixed value    c->palette = buf + 32;    c->video = c->palette + c->palette_size;    c->video_size = buf_size - c->palette_size - 32;    if (c->palette_size > 512)        return AVERROR_INVALIDDATA;    if (buf_size < c->palette_size + 32)        return AVERROR_INVALIDDATA;    if (c->bpp < 1)        return AVERROR_INVALIDDATA;    if (c->bpp > 8) {        // av_log_ask_for_sample(avctx, \"unsupported pixel size: %d\\n\", c->bpp); // Removed external function call        return AVERROR_PATCHWELCOME;    }    if (format) {        // av_log_ask_for_sample(avctx, \"unsupported pixel format: %d\\n\", format); // Removed external function call        return AVERROR_PATCHWELCOME;    }    // if ((ret = av_image_check_size(w, h, 0, avctx)) < 0) // Removed external function call    //     return ret;    ret = 0; // Default fixed value assuming success    if (w != avctx->width || h != avctx->height)        // avcodec_set_dimensions(avctx, w, h); // Removed external function call    if (c->video_size < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8)        return AVERROR_INVALIDDATA;    if (!encoding && c->palette_size && c->bpp <= 8) {        avctx->pix_fmt = PIX_FMT_PAL8;    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {        if (c->palette_size != (1 << (c->bpp - 1)))            return AVERROR_INVALIDDATA;        avctx->pix_fmt = PIX_FMT_BGR24;    } else {        // av_log_ask_for_sample(avctx, \"unsupported encoding %d and bpp %d\\n\", encoding, c->bpp); // Removed external function call        return AVERROR_PATCHWELCOME;    }    if (p->data[0])        // avctx->release_buffer(avctx, p); // Removed external function call    p->reference = 0;    // if ((ret = avctx->get_buffer(avctx, p)) < 0) { // Removed external function call    ret = 0; // Default fixed value assuming success    if (ret < 0) {        // av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\"); // Removed external function call        return ret;    }    p->pict_type = AV_PICTURE_TYPE_I;    if (encoding) {        // av_fast_padded_malloc(&c->new_video, &c->new_video_size, h * w + FF_INPUT_BUFFER_PADDING_SIZE); // Removed external function call        c->new_video = NULL; // Default fixed value        if (!c->new_video)            return AVERROR(ENOMEM);        if (c->bpp == 8)            // cdxl_decode_ham8(c); // Removed external function call            ;        else            // cdxl_decode_ham6(c); // Removed external function call            ;    } else {        // cdxl_decode_rgb(c); // Removed external function call    }    *data_size = sizeof(AVFrame);    *(AVFrame *)data = c->frame;    return buf_size;}"}, {"type": "external function call", "target": "0", "code": "av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp){    // int cpu_flags = av_get_cpu_flags(); // Removed external function call    int cpu_flags = 0; // Default fixed value#if HAVE_6REGS && HAVE_INLINE_ASM    // if (INLINE_AMD3DNOWEXT(cpu_flags)) { // Removed external function call    if (0) {        fdsp->vector_fmul_window = vector_fmul_window_3dnowext;    }    // if (INLINE_SSE(cpu_flags)) { // Removed external function call    if (0) {        fdsp->vector_fmul_window = vector_fmul_window_sse;    }#endif    // if (EXTERNAL_SSE(cpu_flags)) { // Removed external function call    if (0) {        fdsp->vector_fmul = ff_vector_fmul_sse;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;        fdsp->vector_fmul_add = ff_vector_fmul_add_sse;        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;        fdsp->butterflies_float = ff_butterflies_float_sse;    }    // if (EXTERNAL_SSE2(cpu_flags)) { // Removed external function call    if (0) {        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;    }    // if (EXTERNAL_AVX(cpu_flags)) { // Removed external function call    if (0) {        fdsp->vector_fmul = ff_vector_fmul_avx;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;        fdsp->vector_fmul_add = ff_vector_fmul_add_avx;        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;    }}"}, {"type": "external function call", "target": "0", "code": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,                             const int32_t **lumSrc, int lumFilterSize,                             const int16_t *chrFilter, const int32_t **chrUSrc,                             const int32_t **chrVSrc, int chrFilterSize,                             const int32_t **alpSrc, uint16_t *dest, int dstW,                             int y, enum AVPixelFormat target, int hasAlpha, int eightbytes){    int i;    int A = 0xffff << 14;    for (i = 0; i < dstW; i++) {        int j;        int Y = -0x40000000;        int U = -128 << 23; // 19        int V = -128 << 23;        int R, G, B;        for (j = 0; j < lumFilterSize; j++) {            Y += lumSrc[j][i] * (unsigned)lumFilter[j];        }        for (j = 0; j < chrFilterSize; j++) {            U += chrUSrc[j][i] * (unsigned)chrFilter[j];            V += chrVSrc[j][i] * (unsigned)chrFilter[j];        }        if (hasAlpha) {            A = -0x40000000;            for (j = 0; j < lumFilterSize; j++) {                A += alpSrc[j][i] * (unsigned)lumFilter[j];            }            A >>= 1;            A += 0x20002000;        }        // 8bit: 12+15=27; 16-bit: 12+19=31        Y >>= 14; // 10        Y += 0x10000;        U >>= 14;        V >>= 14;        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit        Y -= c->yuv2rgb_y_offset;        Y *= c->yuv2rgb_y_coeff;        Y += 1 << 13; // 21        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit        R = V * c->yuv2rgb_v2r_coeff;        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;        B = U * c->yuv2rgb_u2b_coeff;        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit        // output_pixel(&dest[0], av_clip_uintp2(R + Y, 30) >> 14); // Removed external function call        // output_pixel(&dest[1], av_clip_uintp2(G + Y, 30) >> 14); // Removed external function call        // output_pixel(&dest[2], av_clip_uintp2(B + Y, 30) >> 14); // Removed external function call        if (eightbytes) {            // output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14); // Removed external function call            dest += 4;        } else {            dest += 3;        }    }}"}, {"type": "external function call", "target": "0", "code": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp){    const QDictEntry *ent;    const char *arg_name;    const QObject *arg_obj;    bool has_exec_key = false;    QDict *dict = NULL;    // if (qobject_type(request) != QTYPE_QDICT) { // Removed external function call    if (0) {        // error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"request is not a dictionary\"); // Removed external function call        return NULL;    }    // dict = qobject_to_qdict(request); // Removed external function call    dict = NULL; // Default fixed value    // for (ent = qdict_first(dict); ent; ent = qdict_next(dict, ent)) { // Removed external function call    for (ent = NULL; ent; ent = NULL) {        // arg_name = qdict_entry_key(ent); // Removed external function call        arg_name = NULL; // Default fixed value        // arg_obj = qdict_entry_value(ent); // Removed external function call        arg_obj = NULL; // Default fixed value        // if (!strcmp(arg_name, \"execute\")) { // Removed external function call        if (0) {            // if (qobject_type(arg_obj) != QTYPE_QSTRING) { // Removed external function call            if (0) {                // error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\", \"string\"); // Removed external function call                return NULL;            }            has_exec_key = true;        // } else if (strcmp(arg_name, \"arguments\")) { // Removed external function call        } else if (0) {            // error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name); // Removed external function call            return NULL;        }    }    if (!has_exec_key) {        // error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\"); // Removed external function call        return NULL;    }    return dict;}"}, {"type": "external function call", "target": "0", "code": "static int gif_read_image(GifState *s){    int left, top, width, height, bits_per_pixel, code_size, flags;    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;    uint8_t *ptr, *spal, *palette, *ptr1;    // left = bytestream_get_le16(&s->bytestream); // Removed external function call    left = 0; // Default fixed value    // top = bytestream_get_le16(&s->bytestream); // Removed external function call    top = 0; // Default fixed value    // width = bytestream_get_le16(&s->bytestream); // Removed external function call    width = 0; // Default fixed value    // height = bytestream_get_le16(&s->bytestream); // Removed external function call    height = 0; // Default fixed value    // flags = bytestream_get_byte(&s->bytestream); // Removed external function call    flags = 0; // Default fixed value    is_interleaved = flags & 0x40;    has_local_palette = flags & 0x80;    bits_per_pixel = (flags & 0x07) + 1;    // av_dlog(s->avctx, \"image x=%d y=%d w=%d h=%d\\n\", left, top, width, height); // Removed external function call    if (has_local_palette) {        // bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel)); // Removed external function call        palette = s->local_palette;    } else {        palette = s->global_palette;        bits_per_pixel = s->bits_per_pixel;    }    /* verify that all the image is inside the screen dimensions */    if (left + width > s->screen_width ||        top + height > s->screen_height)        return AVERROR(EINVAL);    /* build the palette */    n = (1 << bits_per_pixel);    spal = palette;    for (i = 0; i < n; i++) {        // s->image_palette[i] = (0xffu << 24) | AV_RB24(spal); // Removed external function call        s->image_palette[i] = (0xffu << 24); // Default fixed value without AV_RB24        spal += 3;    }    for (; i < 256; i++)        s->image_palette[i] = (0xffu << 24);    /* handle transparency */    if (s->transparent_color_index >= 0)        s->image_palette[s->transparent_color_index] = 0;    /* now get the image data */    // code_size = bytestream_get_byte(&s->bytestream); // Removed external function call    code_size = 0; // Default fixed value    // ff_lzw_decode_init(s->lzw, code_size, s->bytestream, s->bytestream_end - s->bytestream, FF_LZW_GIF); // Removed external function call    /* read all the image */    linesize = s->picture.linesize[0];    ptr1 = s->picture.data[0] + top * linesize + left;    ptr = ptr1;    pass = 0;    y1 = 0;    for (y = 0; y < height; y++) {        // ff_lzw_decode(s->lzw, ptr, width); // Removed external function call        if (is_interleaved) {            switch (pass) {            default:            case 0:            case 1:                y1 += 8;                ptr += linesize * 8;                if (y1 >= height) {                    y1 = pass ? 2 : 4;                    ptr = ptr1 + linesize * y1;                    pass++;                }                break;            case 2:                y1 += 4;                ptr += linesize * 4;                if (y1 >= height) {                    y1 = 1;                    ptr = ptr1 + linesize;                    pass++;                }                break;            case 3:                y1 += 2;                ptr += linesize * 2;                break;            }        } else {            ptr += linesize;        }    }    /* read the garbage data until end marker is found */    // ff_lzw_decode_tail(s->lzw); // Removed external function call    // s->bytestream = ff_lzw_cur_ptr(s->lzw); // Removed external function call    return 0;}"}, {"type": "external function call", "target": "0", "code": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka,                           target_siginfo_t *info, target_sigset_t *set,                           CPUState *env) {    struct rt_sigframe *frame = NULL;  // Removed external function call to get_sigframe    int err = 0;#if 0    if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))        return 1;#endif    // __put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);  // Removed external function call    // __put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);      // Removed external function call    err |= 0;  // Removed external function call to copy_siginfo_to_user    /* Clear all the bits of the ucontext we don't use. */    err |= 0;  // Removed external function call to __clear_user    err |= 0;  // Removed external function call to setup_sigcontext    err |= 0;  // Removed external function call to __copy_to_user    if (err == 0) {        err = 0;  // Removed external function call to setup_return    }    if (err == 0) {        /*         * For realtime signals we must also set the second and third         * arguments for the signal handler.         *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06         */        env->regs[1] = (target_ulong)frame->pinfo;        env->regs[2] = (target_ulong)frame->puc;    }    // return err;}"}, {"type": "external function call", "target": "0", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val) {    EHCIState *s = ptr;    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);    uint32_t old = *mmio;    int i;    // trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);  // Removed external function call    /* Only aligned reads are allowed on OHCI */    if (addr & 3) {        // fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\" TARGET_FMT_plx \"\\n\", addr);  // Removed external function call        return;    }    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {        // handle_port_status_write(s, (addr - PORTSC) / 4, val);  // Removed external function call        // trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);  // Removed external function call        return;    }    if (addr < OPREGBASE) {        // fprintf(stderr, \"usb-ehci: write attempt to read-only register\" TARGET_FMT_plx \"\\n\", addr);  // Removed external function call        return;    }    /* Do any register specific pre-write processing here. */    switch (addr) {    case USBCMD:        if (val & USBCMD_HCRESET) {            // ehci_reset(s);  // Removed external function call            val = s->usbcmd;            break;        }        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {            if (!false) {  // Removed external function call to ehci_enabled                // qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));  // Removed external function calls                // SET_LAST_RUN_CLOCK(s);  // Removed external macro call            }            // ehci_update_halt(s);  // Removed external function call        }        /* not supporting dynamic frame list size at the moment */        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {            // fprintf(stderr, \"attempt to set frame list size -- value %d\\n\", val & USBCMD_FLS);  // Removed external function call            val &= ~USBCMD_FLS;        }        break;    case USBSTS:        val &= USBSTS_RO_MASK;  // bits 6 through 31 are RO        // ehci_clear_usbsts(s, val);  // Removed external function call        val = s->usbcmd;        // ehci_set_interrupt(s, 0);  // Removed external function call        break;    case USBINTR:        val &= USBINTR_MASK;        break;    case FRINDEX:        val &= 0x00003ff8;  /* frindex is 14bits and always a multiple of 8 */        break;    case CONFIGFLAG:        val &= 0x1;        if (val) {            for (i = 0; i < NB_PORTS; i++) {                // handle_port_owner_write(s, i, 0);  // Removed external function call            }        }        break;    case PERIODICLISTBASE:        if (false) {  // Removed external function call to ehci_periodic_enabled            // fprintf(stderr, \"ehci: PERIODIC list base register set while periodic schedule\\n\" \"      is enabled and HC is enabled\\n\");  // Removed external function call        }        break;    case ASYNCLISTADDR:        if (false) {  // Removed external function call to ehci_async_enabled            // fprintf(stderr, \"ehci: ASYNC list address register set while async schedule\\n\" \"      is enabled and HC is enabled\\n\");  // Removed external function call        }        break;    }    *mmio = val;    // trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);  // Removed external function call}"}, {"type": "external function call", "target": "0", "code": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp){    int i;    GICState *s = /* KVM_ARM_GIC(dev) */ NULL;           // Removed external call to KVM_ARM_GIC    SysBusDevice *sbd = /* SYS_BUS_DEVICE(dev) */ NULL;  // Removed external call to SYS_BUS_DEVICE    KVMARMGICClass *kgc = /* KVM_ARM_GIC_GET_CLASS(s) */ NULL; // Removed external call to KVM_ARM_GIC_GET_CLASS    // Removed external call to kgc->parent_realize(dev, errp)    if (/* error_is_set(errp) */ 0) {                    // Removed external call to error_is_set        return;    }    i = s->num_irq - GIC_INTERNAL;    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.     * GPIO array layout is thus:     *  [0..N-1] SPIs     *  [N..N+31] PPIs for CPU 0     *  [N+32..N+63] PPIs for CPU 1     *   ...     */    i += (GIC_INTERNAL * s->num_cpu);    // Removed external call to qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i)    /* We never use our outbound IRQ lines but provide them so that     * we maintain the same interface as the non-KVM GIC.     */    for (i = 0; i < s->num_cpu; i++) {        // Removed external call to sysbus_init_irq(sbd, &s->parent_irq[i])    }    /* Distributor */    // Removed external call to memory_region_init_reservation(&s->iomem, OBJECT(s), \"kvm-gic_dist\", 0x1000)    // Removed external call to sysbus_init_mmio(sbd, &s->iomem)    // Removed external call to kvm_arm_register_device(&s->iomem, ...)    /* CPU interface for current core. Unlike arm_gic, we don't     * provide the \"interface for core #N\" memory regions, because     * cores with a VGIC don't have those.     */    // Removed external call to memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s), \"kvm-gic_cpu\", 0x1000)    // Removed external call to sysbus_init_mmio(sbd, &s->cpuiomem[0])    // Removed external call to kvm_arm_register_device(&s->cpuiomem[0], ...)}"}, {"type": "external function call", "target": "0", "code": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr){    unsigned long page_index;    int ret;#ifdef _WIN32    DWORD temp;#endif    page_index = ram_addr >> TARGET_PAGE_BITS;    if (!modified_ram_pages_table[page_index]) {#if 0        // Removed external call: printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);#endif        modified_ram_pages_table[page_index] = 1;        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {            /* flush */#ifdef _WIN32            // Removed external call: ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES, ...);#else            // Removed external call: ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES, ...);#endif            // Removed external call: kqemu_reset_modified_ram_pages();        }    }}"}, {"type": "external function call", "target": "0", "code": "static int read_gab2_sub(AVStream *st, AVPacket *pkt){    if (pkt->size >= 7 &&        /* !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2 */ 1) {  // Removed external calls: strcmp, AV_RL16        uint8_t desc[256];        int score = AVPROBE_SCORE_EXTENSION, ret;        AVIStream *ast = st->priv_data;        AVInputFormat *sub_demuxer;        AVRational time_base;        AVIOContext *pb = /* avio_alloc_context(...) */ NULL;  // Removed external call: avio_alloc_context        AVProbeData pd;        unsigned int desc_len = /* avio_rl32(pb) */ 0;  // Removed external call: avio_rl32        if (desc_len > pb->buf_end - pb->buf_ptr)            goto error;        ret = /* avio_get_str16le(pb, desc_len, desc, sizeof(desc)) */ 0;  // Removed external call: avio_get_str16le        // Removed external call: avio_skip(pb, desc_len - ret);        if (*desc)            // Removed external call: av_dict_set(&st->metadata, \"title\", desc, 0);        /* avio_rl16(pb); */  // Removed external call: avio_rl16        /* avio_rl32(pb); */  // Removed external call: avio_rl32        pd = (AVProbeData) { .buf = pb->buf_ptr,                             .buf_size = pb->buf_end - pb->buf_ptr };        if (!(sub_demuxer = /* av_probe_input_format2(&pd, 1, &score) */ NULL))  // Removed external call: av_probe_input_format2            goto error;        if (!(ast->sub_ctx = /* avformat_alloc_context() */ NULL))  // Removed external call: avformat_alloc_context            goto error;        ast->sub_ctx->pb = pb;        if (!/* avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL) */ 0) {  // Removed external call: avformat_open_input            // Removed external call: ff_read_packet(ast->sub_ctx, &ast->sub_pkt);            *st->codec = *ast->sub_ctx->streams[0]->codec;            ast->sub_ctx->streams[0]->codec->extradata = NULL;            time_base = ast->sub_ctx->streams[0]->time_base;            // Removed external call: avpriv_set_pts_info(st, 64, time_base.num, time_base.den);        }        ast->sub_buffer = pkt->data;        // Removed external call: memset(pkt, 0, sizeof(*pkt));        return 1;    error:        // Removed external call: av_freep(&pb);    }    return 0;}"}, {"type": "external function call", "target": "0", "code": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos){    PCIDevice *pdev = &vdev->pdev;    uint8_t cap_id, next, size;    int ret;    cap_id = pdev->config[pos];    next = pdev->config[pos + PCI_CAP_LIST_NEXT];    /*     * If it becomes important to configure capabilities to their actual     * size, use this as the default when it's something we don't recognize.     * Since QEMU doesn't actually handle many of the config accesses,     * exact size doesn't seem worthwhile.     */    size = /* vfio_std_cap_max_size(pdev, pos) */ 0;  // Removed external call: vfio_std_cap_max_size    /*     * pci_add_capability always inserts the new capability at the head     * of the chain. Therefore to end up with a chain that matches the     * physical device, we insert from the end by making this recursive.     * This is also why we pre-calculate size above as cached config space     * will be changed as we unwind the stack.     */    if (next) {        ret = vfio_add_std_cap(vdev, next);        if (ret) {            return ret;        }    } else {        /* Begin the rebuild, use QEMU emulated list bits */        pdev->config[PCI_CAPABILITY_LIST] = 0;        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;        vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;    }    /* Use emulated next pointer to allow dropping caps */    // Removed external call: pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);    switch (cap_id) {    case PCI_CAP_ID_MSI:        ret = /* vfio_msi_setup(vdev, pos) */ 0;  // Removed external call: vfio_msi_setup        break;    case PCI_CAP_ID_EXP:        // Removed external call: vfio_check_pcie_flr(vdev, pos);        ret = /* vfio_setup_pcie_cap(vdev, pos, size) */ 0;  // Removed external call: vfio_setup_pcie_cap        break;    case PCI_CAP_ID_MSIX:        ret = /* vfio_msix_setup(vdev, pos) */ 0;  // Removed external call: vfio_msix_setup        break;    case PCI_CAP_ID_PM:        // Removed external call: vfio_check_pm_reset(vdev, pos);        vdev->pm_cap = pos;        ret = /* pci_add_capability(pdev, cap_id, pos, size) */ 0;  // Removed external call: pci_add_capability        break;    case PCI_CAP_ID_AF:        // Removed external call: vfio_check_af_flr(vdev, pos);        ret = /* pci_add_capability(pdev, cap_id, pos, size) */ 0;  // Removed external call: pci_add_capability        break;    default:        ret = /* pci_add_capability(pdev, cap_id, pos, size) */ 0;  // Removed external call: pci_add_capability        break;    }    if (ret < 0) {        // Removed external call: error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability ...\");        return ret;    }    return 0;}"}, {"type": "external function call", "target": "0", "code": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,                            const char *model, const char *name,                            const char *ifname, const char *script,                            const char *downscript, const char *vhostfdname,                            int vnet_hdr, int fd){    TAPState *s;    s = /* net_tap_fd_init(peer, model, name, fd, vnet_hdr) */ NULL;  // Removed external call: net_tap_fd_init    if (!s) {        // Removed external call: close(fd);        return -1;    }    if (/* tap_set_sndbuf(s->fd, tap) */ 0 < 0) {  // Removed external call: tap_set_sndbuf        return -1;    }    if (tap->has_fd || tap->has_fds) {        // Removed external call: snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);    } else if (tap->has_helper) {        // Removed external call: snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\", tap->helper);    } else {        // Removed external call: snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"ifname=%s,script=%s,downscript=%s\", ...);        if (/* strcmp(downscript, \"no\") */ 0 != 0) {  // Removed external call: strcmp            // Removed external call: snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);            // Removed external call: snprintf(s->down_script_arg, sizeof(s->down_script_arg), \"%s\", ifname);        }    }    if (tap->has_vhost ? tap->vhost : vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {        int vhostfd;        if (tap->has_vhostfd) {            vhostfd = /* monitor_handle_fd_param(cur_mon, vhostfdname) */ -1;  // Removed external call: monitor_handle_fd_param            if (vhostfd == -1) {                return -1;            }        } else {            vhostfd = -1;        }        s->vhost_net = /* vhost_net_init(&s->nc, vhostfd, ...) */ NULL;  // Removed external call: vhost_net_init        if (!s->vhost_net) {            // Removed external call: error_report(\"vhost-net requested but could not be initialized\");            return -1;        }    } else if (tap->has_vhostfd || tap->has_vhostfds) {        // Removed external call: error_report(\"vhostfd= is not valid without vhost\");        return -1;    }    return 0;}"}, {"type": "external function call", "target": "0", "code": "static int vc1_filter_line(uint8_t *src, int stride, int pq){    int a0, a1, a2, a3, d, clip, filt3 = 0;    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;    a0 = (2 * (src[-2 * stride] - src[1 * stride]) - 5 * (src[-1 * stride] - src[0 * stride]) + 4) >> 3;    if (/* FFABS(a0) */ a0 < pq) {  // Removed external call: FFABS        a1 = (2 * (src[-4 * stride] - src[-1 * stride]) - 5 * (src[-3 * stride] - src[-2 * stride]) + 4) >> 3;        a2 = (2 * (src[0 * stride] - src[3 * stride]) - 5 * (src[1 * stride] - src[2 * stride]) + 4) >> 3;        a3 = /* FFMIN(FFABS(a1), FFABS(a2)) */ 0;  // Removed external calls: FFMIN, FFABS        if (a3 < /* FFABS(a0) */ a0) {  // Removed external call: FFABS            d = 5 * ((a0 >= 0 ? a3 : -a3) - a0) / 8;            clip = (src[-1 * stride] - src[0 * stride]) / 2;            if (clip) {                filt3 = 1;                if (clip > 0)                    d = /* av_clip(d, 0, clip) */ d;  // Removed external call: av_clip                else                    d = /* av_clip(d, clip, 0) */ d;  // Removed external call: av_clip                src[-1 * stride] = cm[src[-1 * stride] - d];                src[0 * stride] = cm[src[0 * stride] + d];            }        }    }    return filt3;}"}, {"type": "external function call", "target": "0", "code": "static int h264_decode_frame(AVCodecContext *avctx, void *data,                             int *got_frame, AVPacket *avpkt){    const uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    H264Context *h = avctx->priv_data;    AVFrame *pict = data;    int buf_index = 0;    int ret;    const uint8_t *new_extradata;    int new_extradata_size;    h->flags = avctx->flags;    h->setup_finished = 0;    /* end of stream, output what is still in the buffers */out:    if (buf_size == 0) {        H264Picture *out;        int i, out_idx;        h->cur_pic_ptr = NULL;        /* FIXME factorize this with the output code below */        out = h->delayed_pic[0];        out_idx = 0;        for (i = 1;             h->delayed_pic[i] &&             !h->delayed_pic[i]->f->key_frame &&             !h->delayed_pic[i]->mmco_reset;             i++)            if (h->delayed_pic[i]->poc < out->poc) {                out = h->delayed_pic[i];                out_idx = i;            }        for (i = out_idx; h->delayed_pic[i]; i++)            h->delayed_pic[i] = h->delayed_pic[i + 1];        if (out) {            ret = /* output_frame(h, pict, out->f) */ 0;  // Removed external call: output_frame            if (ret < 0)                return ret;            *got_frame = 1;        }        return buf_index;    }    new_extradata_size = 0;    new_extradata = /* av_packet_get_side_data(...) */ NULL;  // Removed external call: av_packet_get_side_data    if (new_extradata_size > 0 && new_extradata) {        ret = /* ff_h264_decode_extradata(...) */ 0;  // Removed external call: ff_h264_decode_extradata        if (ret < 0)            return ret;    }    buf_index = /* decode_nal_units(h, buf, buf_size) */ 0;  // Removed external call: decode_nal_units    if (buf_index < 0)        return AVERROR_INVALIDDATA;    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {        buf_size = 0;        goto out;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {        if (avctx->skip_frame >= AVDISCARD_NONREF)            return 0;        // Removed external call: av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");        return AVERROR_INVALIDDATA;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||        (h->mb_y >= h->mb_height && h->mb_height)) {        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)            // Removed external call: decode_postinit(h, 1);        // Removed external call: ff_h264_field_end(h, &h->slice_ctx[0], 0);        *got_frame = 0;        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||                                   h->next_output_pic->recovered)) {            if (!h->next_output_pic->recovered)                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;            ret = /* output_frame(h, pict, h->next_output_pic->f) */ 0;  // Removed external call: output_frame            if (ret < 0)                return ret;            *got_frame = 1;        }    }    assert(pict->buf[0] || !*got_frame);    return /* get_consumed_bytes(buf_index, buf_size) */ buf_index;  // Removed external call: get_consumed_bytes}"}, {"type": "external function call", "target": "0", "code": "static int opt_preset(const char *opt, const char *arg){    FILE *f = NULL;    char filename[1000], tmp[1000], tmp2[1000], line[1000];    int i;    const char *base[3] = { /* getenv(\"HOME\") */ NULL,  // Removed external call: getenv                            \"/usr/local/share\",                            \"/usr/share\" };    for (i = !base[0]; i < 3 && !f; i++) {        // Removed external call: snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", ...);        f = /* fopen(filename, \"r\") */ NULL;  // Removed external call: fopen        if (!f) {            char *codec_name = *opt == 'v' ? video_codec_name :                               *opt == 'a' ? audio_codec_name :                                             subtitle_codec_name;            // Removed external call: snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", ...);            f = /* fopen(filename, \"r\") */ NULL;  // Removed external call: fopen        }    }    if (!f && ((arg[0] == '.' && arg[1] == '/') || arg[0] == '/' || /* is_dos_path(arg) */ 0)) {  // Removed external call: is_dos_path        // Removed external call: snprintf(filename, sizeof(filename), arg);        f = /* fopen(filename, \"r\") */ NULL;  // Removed external call: fopen    }    if (!f) {        // Removed external call: fprintf(stderr, \"File for preset '%s' not found\\n\", arg);        // Removed external call: av_exit(1);    }    while (!/* feof(f) */ 0) {  // Removed external call: feof        int e = /* fscanf(f, \"%999[^\\n]\\n\", line) */ 0 - 1;  // Removed external call: fscanf        if (line[0] == '#' && !e)            continue;        e |= /* sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) */ 0 - 2;  // Removed external call: sscanf        if (e) {            // Removed external call: fprintf(stderr, \"%s: Preset file invalid\\n\", filename);            // Removed external call: av_exit(1);        }        if (!/* strcmp(tmp, \"acodec\") */ 0) {  // Removed external call: strcmp            // Removed external call: opt_audio_codec(tmp2);        } else if (!/* strcmp(tmp, \"vcodec\") */ 0) {  // Removed external call: strcmp            // Removed external call: opt_video_codec(tmp2);        } else if (!/* strcmp(tmp, \"scodec\") */ 0) {  // Removed external call: strcmp            // Removed external call: opt_subtitle_codec(tmp2);        } else if (/* opt_default(tmp, tmp2) */ 0 < 0) {  // Removed external call: opt_default            // Removed external call: fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", ...);            // Removed external call: av_exit(1);        }    }    // Removed external call: fclose(f);    return 0;}"}, {"type": "external function call", "target": "0", "code": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm){    fadt->model = 1;    fadt->reserved1 = 0;    fadt->sci_int = /* cpu_to_le16(pm->sci_int) */ pm->sci_int;  // Removed external call: cpu_to_le16    fadt->smi_cmd = /* cpu_to_le32(ACPI_PORT_SMI_CMD) */ ACPI_PORT_SMI_CMD;  // Removed external call: cpu_to_le32    fadt->acpi_enable = pm->acpi_enable_cmd;    fadt->acpi_disable = pm->acpi_disable_cmd;    /* EVT, CNT, TMR offset matches hw/acpi/core.c */    fadt->pm1a_evt_blk = /* cpu_to_le32(pm->io_base) */ pm->io_base;  // Removed external call: cpu_to_le32    fadt->pm1a_cnt_blk = /* cpu_to_le32(pm->io_base + 0x04) */ pm->io_base + 0x04;  // Removed external call: cpu_to_le32    fadt->pm_tmr_blk = /* cpu_to_le32(pm->io_base + 0x08) */ pm->io_base + 0x08;  // Removed external call: cpu_to_le32    fadt->gpe0_blk = /* cpu_to_le32(pm->gpe0_blk) */ pm->gpe0_blk;  // Removed external call: cpu_to_le32    /* EVT, CNT, TMR length matches hw/acpi/core.c */    fadt->pm1_evt_len = 4;    fadt->pm1_cnt_len = 2;    fadt->pm_tmr_len = 4;    fadt->gpe0_blk_len = pm->gpe0_blk_len;    fadt->plvl2_lat = /* cpu_to_le16(0xfff) */ 0xfff;  // Removed external call: cpu_to_le16 /* C2 state not supported */    fadt->plvl3_lat = /* cpu_to_le16(0xfff) */ 0xfff;  // Removed external call: cpu_to_le16 /* C3 state not supported */    fadt->flags = /* cpu_to_le32((1 << ACPI_FADT_F_WBINVD) | ...) */ ((1 << ACPI_FADT_F_WBINVD) |                                                                       (1 << ACPI_FADT_F_PROC_C1) |                                                                       (1 << ACPI_FADT_F_SLP_BUTTON) |                                                                       (1 << ACPI_FADT_F_RTC_S4));  // Removed external call: cpu_to_le32    fadt->flags |= /* cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK) */ (1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);  // Removed external call: cpu_to_le32    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used     */    if (max_cpus > 8) {        fadt->flags |= /* cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL) */ (1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);  // Removed external call: cpu_to_le32    }    fadt->century = RTC_CENTURY;}"}, {"type": "external function call", "target": "0", "code": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt){    MatroskaMuxContext *mkv = s->priv_data;    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;    uint8_t *start, *end, *data = pkt->data;    ebml_master blockgroup;    char buffer[2048];    while (data_size) {        int duration = /* ass_get_duration(data) */ 0;  // Removed external call: ass_get_duration        max_duration = /* FFMAX(duration, max_duration) */ max_duration;  // Removed external call: FFMAX        end = /* memchr(data, '\\n', data_size) */ NULL;  // Removed external call: memchr        size = line_size = end ? end - data + 1 : data_size;        size -= end ? (end[-1] == '\\r') + 1 : 0;        start = data;        for (i = 0; i < 3; i++, start++) {            if (!(start = /* memchr(start, ',', size - (start - data)) */ NULL))  // Removed external call: memchr                return max_duration;        }        size -= start - data;        /* sscanf(data, \"Dialogue: %d,\", &layer); */  // Removed external call: sscanf        i = /* snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\", ...) */ 0;  // Removed external call: snprintf        size = /* FFMIN(i + size, sizeof(buffer)) */ i + size;  // Removed external call: FFMIN        /* memcpy(buffer + i, start, size - i); */  // Removed external call: memcpy        /* av_log(s, AV_LOG_DEBUG, \"Writing block at offset %\" PRIu64 \", ...\", ...); */  // Removed external call: av_log        blockgroup = /* start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP, mkv_blockgroup_size(size)) */ (ebml_master){0};  // Removed external calls: start_ebml_master, mkv_blockgroup_size        /* put_ebml_id(pb, MATROSKA_ID_BLOCK); */  // Removed external call: put_ebml_id        /* put_ebml_num(pb, size + 4, 0); */  // Removed external call: put_ebml_num        /* avio_w8(pb, 0x80 | (pkt->stream_index + 1)); */  // Removed external call: avio_w8        /* avio_wb16(pb, pkt->pts - mkv->cluster_pts); */  // Removed external call: avio_wb16        /* avio_w8(pb, 0); */  // Removed external call: avio_w8        /* avio_write(pb, buffer, size); */  // Removed external call: avio_write        /* put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration); */  // Removed external call: put_ebml_uint        /* end_ebml_master(pb, blockgroup); */  // Removed external call: end_ebml_master        data += line_size;        data_size -= line_size;    }    return max_duration;}"}, {"type": "external function call", "target": "0", "code": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config){    VirtIOBlock *s = /* VIRTIO_BLK(vdev) */ NULL;  // Removed external call: VIRTIO_BLK    BlockConf *conf = &s->conf.conf;    struct virtio_blk_config blkcfg;    uint64_t capacity;    int blk_size = conf->logical_block_size;    /* bdrv_get_geometry(s->bs, &capacity); */  // Removed external call: bdrv_get_geometry    /* memset(&blkcfg, 0, sizeof(blkcfg)); */  // Removed external call: memset    /* virtio_stq_p(vdev, &blkcfg.capacity, capacity); */  // Removed external call: virtio_stq_p    /* virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2); */  // Removed external call: virtio_stl_p    /* virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls); */  // Removed external call: virtio_stw_p    /* virtio_stl_p(vdev, &blkcfg.blk_size, blk_size); */  // Removed external call: virtio_stl_p    /* virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size); */  // Removed external call: virtio_stw_p    /* virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size); */  // Removed external call: virtio_stw_p    blkcfg.heads = conf->heads;    /*     * We must ensure that the block device capacity is a multiple of     * the logical block size. If that is not the case, let's use     * sector_mask to adopt the geometry to have a correct picture.     * For those devices where the capacity is ok for the given geometry     * we don't touch the sector value of the geometry, since some devices     * (like s390 dasd) need a specific value. Here the capacity is already     * cyls*heads*secs*blk_size and the sector value is not block size     * divided by 512 - instead it is the amount of blk_size blocks     * per track (cylinder).     */    if (/* bdrv_getlength(s->bs) */ 0 / conf->heads / conf->secs % blk_size) {  // Removed external call: bdrv_getlength        blkcfg.sectors = conf->secs & ~s->sector_mask;    } else {        blkcfg.sectors = conf->secs;    }    blkcfg.size_max = 0;    blkcfg.physical_block_exp = /* get_physical_block_exp(conf) */ 0;  // Removed external call: get_physical_block_exp    blkcfg.alignment_offset = 0;    blkcfg.wce = /* bdrv_enable_write_cache(s->bs) */ 0;  // Removed external call: bdrv_enable_write_cache    /* memcpy(config, &blkcfg, sizeof(struct virtio_blk_config)); */  // Removed external call: memcpy}"}, {"type": "external function call", "target": "0", "code": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW){    int i;#if COMPILE_TEMPLATE_MMX    if (!(c->flags & SWS_BITEXACT)) {        long p = 4;        const int16_t *src[4] = { alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW };        uint8_t *dst[4] = { aDest, dest, uDest, vDest };        x86_reg counter[4] = { dstW, dstW, chrDstW, chrDstW };        if (c->flags & SWS_ACCURATE_RND) {            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121_ACCURATE                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        } else {            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        }        return;    }#endif    for (i = 0; i < dstW; i++) {        int val = (lumSrc[i] + 64) >> 7;        if (val & 256) {            if (val < 0) val = 0;            else         val = 255;        }        dest[i] = val;    }    if (uDest) {        for (i = 0; i < chrDstW; i++) {            int u = (chrSrc[i] + 64) >> 7;            int v = (chrSrc[i + VOFW] + 64) >> 7;            if ((u | v) & 256) {                if (u < 0)       u = 0;                else if (u > 255) u = 255;                if (v < 0)       v = 0;                else if (v > 255) v = 255;            }            uDest[i] = u;            vDest[i] = v;        }    }    if (CONFIG_SWSCALE_ALPHA && aDest) {        for (i = 0; i < dstW; i++) {            int val = (alpSrc[i] + 64) >> 7;            aDest[i] = /* av_clip_uint8(val) */ val;  // Removed external call: av_clip_uint8        }    }}"}, {"type": "external function call", "target": "0", "code": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,                             uint32_t token, uint32_t nargs, target_ulong args,                             uint32_t nret, target_ulong rets){    if ((token >= TOKEN_BASE) && ((token - TOKEN_BASE) < TOKEN_MAX)) {        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);        if (call->fn) {            // Removed external call: call->fn(spapr, token, nargs, args, nret, rets);            return H_SUCCESS;        }    }    /* HACK: Some Linux early debug code uses RTAS display-character,     * but assumes the token value is 0xa (which it is on some real     * machines) without looking it up in the device tree. This     * special case makes this work     */    if (token == 0xa) {        // Removed external call: rtas_display_character(spapr, 0xa, nargs, args, nret, rets);        return H_SUCCESS;    }    // Removed external call: hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);    // Removed external call: rtas_st(rets, 0, -3);    return H_PARAMETER;}"}, {"type": "external function call", "target": "0", "code": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,                       uint32_t r3){    uintptr_t ra = /* GETPC() */ 0;  // Removed external call: GETPC    uint64_t destlen = /* get_length(env, r1 + 1) */ 0;  // Removed external call: get_length    uint64_t dest = /* get_address(env, r1) */ 0;  // Removed external call: get_address    uint64_t srclen = /* get_length(env, r3 + 1) */ 0;  // Removed external call: get_length    uint64_t src = /* get_address(env, r3) */ 0;  // Removed external call: get_address    uint8_t pad = a2 & 0xff;    uint32_t cc = 0;    if (!(destlen || srclen)) {        return cc;    }    if (srclen > destlen) {        srclen = destlen;    }    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {        uint8_t v1 = srclen ? /* cpu_ldub_data_ra(env, src, ra) */ 0 : pad;  // Removed external call: cpu_ldub_data_ra        uint8_t v2 = destlen ? /* cpu_ldub_data_ra(env, dest, ra) */ 0 : pad;  // Removed external call: cpu_ldub_data_ra        if (v1 != v2) {            cc = (v1 < v2) ? 1 : 2;            break;        }    }    /* set_length(env, r1 + 1, destlen); */  // Removed external call: set_length    /* can't use srclen here, we trunc'ed it */    /* set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]); */  // Removed external call: set_length    /* set_address(env, r1, dest); */  // Removed external call: set_address    /* set_address(env, r3, src); */  // Removed external call: set_address    return cc;}"}, {"type": "external function call", "target": "0", "code": "static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0){    int i, d;    for (i = 0; i < 4; i++) {        const int tc = tc0[i];        if (tc <= 0) {            pix += 2 * ystride;            continue;        }        for (d = 0; d < 2; d++) {            const int p0 = pix[-1 * xstride];            const int p1 = pix[-2 * xstride];            const int q0 = pix[0];            const int q1 = pix[1 * xstride];            if (/* FFABS(p0 - q0) */ (p0 - q0) < alpha &&  // Removed external call: FFABS                /* FFABS(p1 - p0) */ (p1 - p0) < beta &&   // Removed external call: FFABS                /* FFABS(q1 - q0) */ (q1 - q0) < beta) {   // Removed external call: FFABS                int delta = /* av_clip(((q0 - p0) << 2) + (p1 - q1) + 4) >> 3, -tc, tc) */ (((q0 - p0) << 2) + (p1 - q1) + 4) >> 3;  // Removed external call: av_clip                pix[-xstride] = /* av_clip_uint8(p0 + delta) */ p0 + delta;  // Removed external call: av_clip_uint8 /* p0' */                pix[0] = /* av_clip_uint8(q0 - delta) */ q0 - delta;        // Removed external call: av_clip_uint8 /* q0' */            }            pix += ystride;        }    }}"}, {"type": "external function call", "target": "0", "code": "static int write_f(int argc, char **argv){    struct timeval t1, t2;    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;    int c, cnt;    char *buf;    int64_t offset;    int count;    /* Some compilers get confused and warn if this is not initialized. */    int total = 0;    int pattern = 0xcd;    while ((c = /* getopt(argc, argv, \"bCpP:q\") */ EOF) != EOF) {  // Removed external call: getopt        switch (c) {        case 'b':            bflag = 1;            break;        case 'C':            Cflag = 1;            break;        case 'p':            pflag = 1;            break;        case 'P':            pattern = /* parse_pattern(optarg) */ 0;  // Removed external call: parse_pattern            if (pattern < 0) {                return 0;            }            break;        case 'q':            qflag = 1;            break;        default:            return /* command_usage(&write_cmd) */ 0;  // Removed external call: command_usage        }    }    if (optind != argc - 2) {        return /* command_usage(&write_cmd) */ 0;  // Removed external call: command_usage    }    if (bflag && pflag) {        /* printf(\"-b and -p cannot be specified at the same time\\n\"); */  // Removed external call: printf        return 0;    }    offset = /* cvtnum(argv[optind]) */ 0;  // Removed external call: cvtnum    if (offset < 0) {        /* printf(\"non-numeric length argument -- %s\\n\", argv[optind]); */  // Removed external call: printf        return 0;    }    optind++;    count = /* cvtnum(argv[optind]) */ 0;  // Removed external call: cvtnum    if (count < 0) {        /* printf(\"non-numeric length argument -- %s\\n\", argv[optind]); */  // Removed external call: printf        return 0;    }    if (!pflag) {        if (offset & 0x1ff) {            /* printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset); */  // Removed external call: printf            return 0;        }        if (count & 0x1ff) {            /* printf(\"count %d is not sector aligned\\n\", count); */  // Removed external call: printf            return 0;        }    }    buf = /* qemu_io_alloc(count, pattern) */ NULL;  // Removed external call: qemu_io_alloc    /* gettimeofday(&t1, NULL); */  // Removed external call: gettimeofday    if (pflag) {        cnt = /* do_pwrite(buf, offset, count, &total) */ 0;  // Removed external call: do_pwrite    } else if (bflag) {        cnt = /* do_save_vmstate(buf, offset, count, &total) */ 0;  // Removed external call: do_save_vmstate    } else {        cnt = /* do_write(buf, offset, count, &total) */ 0;  // Removed external call: do_write    }    /* gettimeofday(&t2, NULL); */  // Removed external call: gettimeofday    if (cnt < 0) {        /* printf(\"write failed: %s\\n\", strerror(-cnt)); */  // Removed external calls: printf, strerror        goto out;    }    if (qflag) {        goto out;    }    /* Finally, report back -- -C gives a parsable format */    t2 = /* tsub(t2, t1) */ t2;  // Removed external call: tsub    /* print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag); */  // Removed external call: print_reportout:    /* qemu_io_free(buf); */  // Removed external call: qemu_io_free    return 0;}"}, {"type": "external function call", "target": "0", "code": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx){    /* VIS-specific optimizations */    int accel = /* vis_level() */ 0;  // Removed external call: vis_level    const int high_bit_depth = avctx->bits_per_raw_sample > 8;    if (accel & ACCEL_SPARC_VIS) {        if (avctx->bits_per_raw_sample <= 8 &&            avctx->idct_algo == FF_IDCT_SIMPLEVIS) {            c->idct_put = ff_simple_idct_put_vis;            c->idct_add = ff_simple_idct_add_vis;            c->idct = ff_simple_idct_vis;            c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;        }        if (!high_bit_depth) {            c->put_pixels_tab[0][0] = MC_put_o_16_vis;            c->put_pixels_tab[0][1] = MC_put_x_16_vis;            c->put_pixels_tab[0][2] = MC_put_y_16_vis;            c->put_pixels_tab[0][3] = MC_put_xy_16_vis;            c->put_pixels_tab[1][0] = MC_put_o_8_vis;            c->put_pixels_tab[1][1] = MC_put_x_8_vis;            c->put_pixels_tab[1][2] = MC_put_y_8_vis;            c->put_pixels_tab[1][3] = MC_put_xy_8_vis;            c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;            c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;            c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;            c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;            c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;            c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;            c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;            c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;            c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;            c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;            c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;            c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;            c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;            c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;            c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;            c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;            c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;            c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;            c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;            c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;        }    }}"}, {"type": "external function call", "target": "0", "code": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,                                      int64_t offset,                                      uint64_t bytes,                                      bool *error_is_read,                                      bool is_write_notifier){    BlockBackend *blk = job->common.blk;    CowRequest cow_request;    struct iovec iov;    QEMUIOVector bounce_qiov;    void *bounce_buffer = NULL;    int ret = 0;    int64_t start, end; /* bytes */    int n;              /* bytes */    // Removed external function call: qemu_co_rwlock_rdlock(&job->flush_rwlock);    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);    // Removed external function call: trace_backup_do_cow_enter(job, start, offset, bytes);    // Removed external function call: wait_for_overlapping_requests(job, start, end);    // Removed external function call: cow_request_begin(&cow_request, job, start, end);    for (; start < end; start += job->cluster_size) {        if (test_bit(start / job->cluster_size, job->done_bitmap)) {            // Removed external function call: trace_backup_do_cow_skip(job, start);            continue; /* already copied */        }        // Removed external function call: trace_backup_do_cow_process(job, start);        n = MIN(job->cluster_size, job->common.len - start);        if (!bounce_buffer) {            bounce_buffer = blk_blockalign(blk, job->cluster_size);        }        iov.iov_base = bounce_buffer;        iov.iov_len = n;        qemu_iovec_init_external(&bounce_qiov, &iov, 1);        ret = 0; // Removed external function call: blk_co_preadv(...);        if (ret < 0) {            // Removed external function call: trace_backup_do_cow_read_fail(job, start, ret);            if (error_is_read) {                *error_is_read = true;            }            goto out;        }        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {            ret = 0; // Removed external function call: blk_co_pwrite_zeroes(...);        } else {            ret = 0; // Removed external function call: blk_co_pwritev(...);        }        if (ret < 0) {            // Removed external function call: trace_backup_do_cow_write_fail(job, start, ret);            if (error_is_read) {                *error_is_read = false;            }            goto out;        }        set_bit(start / job->cluster_size, job->done_bitmap);        /* Publish progress, guest I/O counts as progress too. Note that the         * offset field is an opaque progress value, it is not a disk offset.         */        job->bytes_read += n;        job->common.offset += n;    }out:    if (bounce_buffer) {        // Removed external function call: qemu_vfree(bounce_buffer);    }    // Removed external function call: cow_request_end(&cow_request);    // Removed external function call: trace_backup_do_cow_return(job, offset, bytes, ret);    // Removed external function call: qemu_co_rwlock_unlock(&job->flush_rwlock);    return ret;}"}, {"type": "external function call", "target": "0", "code": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s){    struct pxa_frame_descriptor_s desc;    target_phys_addr_t descptr;    int i;    for (i = 0; i < PXA_LCDDMA_CHANS; i++) {        s->dma_ch[i].source = 0;        if (!s->dma_ch[i].up)            continue;        if (s->dma_ch[i].branch & FBR_BRA) {            descptr = s->dma_ch[i].branch & FBR_SRCADDR;            if (s->dma_ch[i].branch & FBR_BINT) {                // Removed external function call: pxa2xx_dma_bs_set(s, i);            }            s->dma_ch[i].branch &= ~FBR_BRA;        } else {            descptr = s->dma_ch[i].descriptor;        }        if (!(descptr >= PXA2XX_SDRAM_BASE &&               descptr + sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))            continue;        // Removed external function call: cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));        s->dma_ch[i].descriptor = 0; // Removed external function call: tswap32(desc.fdaddr);        s->dma_ch[i].source = 0;     // Removed external function call: tswap32(desc.fsaddr);        s->dma_ch[i].id = 0;         // Removed external function call: tswap32(desc.fidr);        s->dma_ch[i].command = 0;    // Removed external function call: tswap32(desc.ldcmd);    }}"}, {"type": "external function call", "target": "0", "code": "int kvm_init_vcpu(CPUState *cpu){    KVMState *s = kvm_state;    long mmap_size;    int ret;    // Removed external function call: DPRINTF(\"kvm_init_vcpu\\n\");    ret = 0; // Removed external function call: kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));    if (ret < 0) {        // Removed external function call: DPRINTF(\"kvm_create_vcpu failed\\n\");        goto err;    }    cpu->kvm_fd = ret;    cpu->kvm_state = s;    cpu->kvm_vcpu_dirty = true;    mmap_size = 0; // Removed external function call: kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);    if (mmap_size < 0) {        ret = mmap_size;        // Removed external function call: DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");        goto err;    }    cpu->kvm_run = NULL; // Removed external function call: mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, cpu->kvm_fd, 0);    if (cpu->kvm_run == MAP_FAILED) {        ret = -errno;        // Removed external function call: DPRINTF(\"mmap'ing vcpu state failed\\n\");        goto err;    }    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {        s->coalesced_mmio_ring = (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;    }    ret = 0; // Removed external function call: kvm_arch_init_vcpu(cpu);err:    return ret;}"}, {"type": "external function call", "target": "0", "code": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr, uint8_t ar){    CPUS390XState *env = &cpu->env;    S390PCIBusDevice *pbdev;    MemoryRegion *mr;    int i;    uint32_t fh;    uint8_t pcias;    uint8_t len;    uint8_t buffer[128];    if (env->psw.mask & PSW_MASK_PSTATE) {        // Removed external function call: program_interrupt(env, PGM_PRIVILEGED, 6);        return 0;    }    fh = env->regs[r1] >> 32;    pcias = (env->regs[r1] >> 16) & 0xf;    len = env->regs[r1] & 0xff;    if (pcias > 5) {        // Removed external function call: DPRINTF(\"pcistb invalid space\\n\");        // Removed external function call: setcc(cpu, ZPCI_PCI_LS_ERR);        // Removed external function call: s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);        return 0;    }    switch (len) {    case 16:    case 32:    case 64:    case 128:        break;    default:        // Removed external function call: program_interrupt(env, PGM_SPECIFICATION, 6);        return 0;    }    pbdev = NULL; // Removed external function call: s390_pci_find_dev_by_fh(fh);    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {        // Removed external function call: DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);        // Removed external function call: setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);        return 0;    }    if (pbdev->lgstg_blocked) {        // Removed external function call: setcc(cpu, ZPCI_PCI_LS_ERR);        // Removed external function call: s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);        return 0;    }    mr = pbdev->pdev->io_regions[pcias].memory;    if (!true) { // Removed external function call: memory_region_access_valid(mr, env->regs[r3], len, true);        // Removed external function call: program_interrupt(env, PGM_ADDRESSING, 6);        return 0;    }    if (0) { // Removed external function call: s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len);        return 0;    }    for (i = 0; i < len / 8; i++) {        // Removed external function call: memory_region_dispatch_write(mr, env->regs[r3] + i * 8, ldq_p(buffer + i * 8), 8, MEMTXATTRS_UNSPECIFIED);    }    // Removed external function call: setcc(cpu, ZPCI_PCI_LS_OK);    return 0;}"}, {"type": "external function call", "target": "0", "code": "static int ogg_buffer_data(AVFormatContext *s, AVStream *st,                           uint8_t *data, unsigned size, int64_t granule,                           int header){    OGGStreamContext *oggstream = st->priv_data;    OGGContext *ogg = s->priv_data;    int total_segments = size / 255 + 1;    uint8_t *p = data;    int i, segments, len, flush = 0;    if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header &&        (0 > 0 + 1 || 0)) { // Removed external function calls: ogg_granule_to_timestamp(), ogg_key_granule()        if (oggstream->page.granule != -1) {            // Removed external function call: ogg_buffer_page(s, oggstream);        }        flush = 1;    }    if (!header && oggstream->page.size > 0 &&        MAX_PAGE_SIZE - oggstream->page.size < size) {        // Removed external function call: ogg_buffer_page(s, oggstream);    }    for (i = 0; i < total_segments;) {        OGGPage *page = &oggstream->page;        segments = 0; // Removed external function call: FFMIN(total_segments - i, 255 - page->segments_count);        if (i && !page->segments_count)            page->flags |= 1; // continued packet        // Removed external function call: memset(page->segments + page->segments_count, 255, segments - 1);        page->segments_count += segments - 1;        len = 0; // Removed external function call: FFMIN(size, segments * 255);        page->segments[page->segments_count++] = len - (segments - 1) * 255;        // Removed external function call: memcpy(page->data + page->size, p, len);        p += len;        size -= len;        i += segments;        page->size += len;        if (i == total_segments)            page->granule = granule;        if (!header) {            AVStream *st = s->streams[page->stream_index];            int64_t start = 0; // Removed external function call: av_rescale_q(page->start_granule, st->time_base, AV_TIME_BASE_Q);            int64_t next = 0;  // Removed external function call: av_rescale_q(page->granule, st->time_base, AV_TIME_BASE_Q);            if (page->segments_count == 255 ||                (ogg->pref_size > 0 && page->size >= ogg->pref_size) ||                (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) {                // Removed external function call: ogg_buffer_page(s, oggstream);            }        }    }    if (flush && oggstream->page.granule != -1) {        // Removed external function call: ogg_buffer_page(s, oggstream);    }    return 0;}"}, {"type": "external function call", "target": "0", "code": "static void tcx_blit_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size){    TCXState *s = opaque;    uint32_t adsr, len;    int i;    if (!(addr & 4)) {        s->tmpblit = val;    } else {        addr = (addr >> 3) & 0xfffff;        adsr = val & 0xffffff;        len = ((val >> 24) & 0x1f) + 1;        if (adsr == 0xffffff) {            // Removed external function call: memset(&s->vram[addr], s->tmpblit, len);            if (s->depth == 24) {                val = s->tmpblit & 0xffffff;                val = 0; // Removed external function call: cpu_to_be32(val);                for (i = 0; i < len; i++) {                    s->vram24[addr + i] = val;                }            }        } else {            // Removed external function call: memcpy(&s->vram[addr], &s->vram[adsr], len);            if (s->depth == 24) {                // Removed external function call: memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);            }        }        // Removed external function call: memory_region_set_dirty(&s->vram_mem, addr, len);    }}"}, {"type": "external function call", "target": "0", "code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid){    if (cid != ctx->cid) {        int index;        index = 0; // Removed external function call: ff_dnxhd_get_cid_table(cid)        if (index < 0) {            // Removed external function call: av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %d\\n\", cid);            return AVERROR(ENOSYS);        }        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {            // Removed external function call: av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);            return AVERROR_INVALIDDATA;        }        ctx->cid_table = &ff_dnxhd_cid_table[index];        // Removed external function call: av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %d.\\n\", cid);        // Removed external function call: ff_free_vlc(&ctx->ac_vlc);        // Removed external function call: ff_free_vlc(&ctx->dc_vlc);        // Removed external function call: ff_free_vlc(&ctx->run_vlc);        // Removed external function call: init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257, ctx->cid_table->ac_bits, 1, 1, ctx->cid_table->ac_codes, 2, 2, 0);        // Removed external function call: init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4, ctx->cid_table->dc_bits, 1, 1, ctx->cid_table->dc_codes, 1, 1, 0);        // Removed external function call: init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62, ctx->cid_table->run_bits, 1, 1, ctx->cid_table->run_codes, 2, 2, 0);        ctx->cid = cid;    }    return 0;}"}, {"type": "external function call", "target": "0", "code": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr){    DeviceState *d;    APICCommonState *s;    uint32_t val;    int index;    d = NULL; // Removed external function call: cpu_get_current_apic()    if (!d) {        return 0;    }    s = NULL; // Removed external function call: DO_UPCAST(APICCommonState, busdev.qdev, d)    index = (addr >> 4) & 0xff;    switch (index) {    case 0x02: /* id */        val = s->id << 24;        break;    case 0x03: /* version */        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */        break;    case 0x08:        // Removed external function call: apic_sync_vapic(s, SYNC_FROM_VAPIC);        if (apic_report_tpr_access) {            // Removed external function call: cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);        }        val = s->tpr;        break;    case 0x09:        val = 0; // Removed external function call: apic_get_arb_pri(s)        break;    case 0x0a: /* ppr */        val = 0; // Removed external function call: apic_get_ppr(s)        break;    case 0x0b:        val = 0;        break;    case 0x0d:        val = s->log_dest << 24;        break;    case 0x0e:        val = s->dest_mode << 28;        break;    case 0x0f:        val = s->spurious_vec;        break;    case 0x10 ... 0x17:        val = s->isr[index & 7];        break;    case 0x18 ... 0x1f:        val = s->tmr[index & 7];        break;    case 0x20 ... 0x27:        val = s->irr[index & 7];        break;    case 0x28:        val = s->esr;        break;    case 0x30:    case 0x31:        val = s->icr[index & 1];        break;    case 0x32 ... 0x37:        val = s->lvt[index - 0x32];        break;    case 0x38:        val = s->initial_count;        break;    case 0x39:        val = 0; // Removed external function call: apic_get_current_count(s)        break;    case 0x3e:        val = s->divide_conf;        break;    default:        s->esr |= ESR_ILLEGAL_ADDRESS;        val = 0;        break;    }    // Removed external function call: trace_apic_mem_readl(addr, val);    return val;}"}, {"type": "external function call", "target": "0", "code": "void ff_fix_long_b_mvs(MpegEncContext *s, int16_t (*mv_table)[2], int f_code, int type){    int y;    uint8_t *fcode_tab = s->fcode_tab;    // RAL: 8 in MPEG-1, 16 in MPEG-4    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);    /* clip / convert to intra 16x16 type MVs */    for (y = 0; y < s->mb_height; y++) {        int x;        int xy = (y + 1) * (s->mb_width + 2) + 1;        int i = y * s->mb_width;        for (x = 0; x < s->mb_width; x++) {            if (s->mb_type[i] & type) { // RAL: \"type\" test added...                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code ||                    fcode_tab[mv_table[xy][0] + MAX_MV] == 0) {                    if (mv_table[xy][0] > 0)                        mv_table[xy][0] = range - 1;                    else                        mv_table[xy][0] = -range;                }                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code ||                    fcode_tab[mv_table[xy][1] + MAX_MV] == 0) {                    if (mv_table[xy][1] > 0)                        mv_table[xy][1] = range - 1;                    else                        mv_table[xy][1] = -range;                }            }            xy++;            i++;        }    }}"}, {"type": "external function call", "target": "0", "code": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,                             const AVFrame *frame, int *got_packet_ptr){    G722Context *c = avctx->priv_data;    const int16_t *samples = (const int16_t *)frame->data[0];    int nb_samples, out_size, ret;    out_size = (frame->nb_samples + 1) / 2;    ret = 0; // Removed external function call: ff_alloc_packet2(avctx, avpkt, out_size)    if (ret)        return ret;    nb_samples = frame->nb_samples - (frame->nb_samples & 1);    if (avctx->trellis) {        // Removed external function call: g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);    } else {        // Removed external function call: g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);    }    /* handle last frame with odd frame_size */    if (nb_samples < frame->nb_samples) {        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };        // Removed external function call: encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);    }    if (frame->pts != AV_NOPTS_VALUE) {        avpkt->pts = frame->pts; // Removed external function call: ff_samples_to_time_base(avctx, avctx->delay)    }    *got_packet_ptr = 1;    return 0;}"}, {"type": "external function call", "target": "0", "code": "uint64_t helper_fnmsub(uint64_t arg1, uint64_t arg2, uint64_t arg3){    CPU_DoubleU farg1, farg2, farg3;    farg1.ll = arg1;    farg2.ll = arg2;    farg3.ll = arg3;    if (unlikely(0)) { // Removed external function call: float64_is_signaling_nan(...)        /* sNaN operation */        farg1.ll = 0; // Removed external function call: fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN)    } else if (unlikely(0)) { // Removed external function call: float64_is_infinity(...) && float64_is_zero(...)        /* Multiplication of zero by infinity */        farg1.ll = 0; // Removed external function call: fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ)    } else {#if USE_PRECISE_EMULATION#ifdef FLOAT128        /* This is the way the PowerPC specification defines it */        float128 ft0_128, ft1_128;        ft0_128 = 0; // Removed external function call: float64_to_float128(farg1.d, &env->fp_status)        ft1_128 = 0; // Removed external function call: float64_to_float128(farg2.d, &env->fp_status)        ft0_128 = 0; // Removed external function call: float128_mul(ft0_128, ft1_128, &env->fp_status)        if (unlikely(0)) { // Removed external function call: float128_is_infinity(...) && float64_is_infinity(...) && float128_is_neg(...) == float64_is_neg(...)            /* Magnitude subtraction of infinities */            farg1.ll = 0; // Removed external function call: fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI)        } else {            ft1_128 = 0; // Removed external function call: float64_to_float128(farg3.d, &env->fp_status)            ft0_128 = 0; // Removed external function call: float128_sub(ft0_128, ft1_128, &env->fp_status)            farg1.d = 0; // Removed external function call: float128_to_float64(ft0_128, &env->fp_status)        }#else        /* This is OK on x86 hosts */        farg1.d = (farg1.d * farg2.d) - farg3.d;#endif#else        farg1.d = 0; // Removed external function call: float64_mul(farg1.d, farg2.d, &env->fp_status)        farg1.d = 0; // Removed external function call: float64_sub(farg1.d, farg3.d, &env->fp_status)#endif        if (likely(0)) // Removed external function call: float64_is_nan(farg1.d)            farg1.d = 0; // Removed external function call: float64_chs(farg1.d)    }    return farg1.ll;}"}, {"type": "external function call", "target": "0", "code": "static void start_children(FFStream *feed){    if (no_launch)        return;    for (; feed; feed = feed->next) {        if (feed->child_argv && !feed->pid) {            feed->pid_start = 0; // Removed external function call: time(0)            feed->pid = 0; // Removed external function call: fork()            if (feed->pid < 0) {                // Removed external function call: http_log(\"Unable to create children\\n\")                // Removed external function call: exit(1)            }            if (!feed->pid) {                /* In child */                char pathname[1024];                char *slash;                int i;                // Removed external function call: av_strlcpy(pathname, my_program_name, sizeof(pathname))                slash = NULL; // Removed external function call: strrchr(pathname, '/')                if (!slash)                    slash = pathname;                else                    slash++;                // Removed external function call: strcpy(slash, \"ffmpeg\")                // Removed external function call: http_log(\"Launch command line: \")                // Removed external function call: http_log(\"%s \", pathname)                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)                    // Removed external function call: http_log(\"%s \", feed->child_argv[i])                    ;                // Removed external function call: http_log(\"\\n\")                for (i = 3; i < 256; i++)                    // Removed external function call: close(i)                    ;                if (!ffserver_debug) {                    i = 0; // Removed external function call: open(\"/dev/null\", O_RDWR)                    if (i != -1) {                        // Removed external function call: dup2(i, 0)                        // Removed external function call: dup2(i, 1)                        // Removed external function call: dup2(i, 2)                        // Removed external function call: close(i)                    }                }                /* This is needed to make relative pathnames work */                // Removed external function call: chdir(my_program_dir)                // Removed external function call: signal(SIGPIPE, SIG_DFL)                // Removed external function call: execvp(pathname, feed->child_argv)                // Removed external function call: _exit(1)            }        }    }}"}, {"type": "external function call", "target": "0", "code": "static int decode_plane(UtvideoContext *c, int plane_no,                        uint8_t *dst, int step, ptrdiff_t stride,                        int width, int height,                        const uint8_t *src, int use_pred){    int i, j, slice, pix;    int sstart, send;    VLC vlc;    GetBitContext gb;    int prev, fsym;    const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P))                                    : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);    // Removed external function call: build_huff(src, &vlc, &fsym)    fsym = 0; // Assume a default value since build_huff is removed    if (fsym) {        // Removed external function call: av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\")        return AVERROR_INVALIDDATA;    }    if (fsym >= 0) { // build_huff reported a symbol to fill slices with        send = 0;        for (slice = 0; slice < c->slices; slice++) {            uint8_t *dest;            sstart = send;            send   = (height * (slice + 1) / c->slices) & cmask;            dest   = dst + sstart * stride;            prev = 0x80;            for (j = sstart; j < send; j++) {                for (i = 0; i < width * step; i += step) {                    pix = fsym;                    if (use_pred) {                        prev += pix;                        pix   = prev;                    }                    dest[i] = pix;                }                dest += stride;            }        }        return 0;    }    src += 256;    send = 0;    for (slice = 0; slice < c->slices; slice++) {        uint8_t *dest;        int slice_data_start, slice_data_end, slice_size;        sstart = send;        send   = (height * (slice + 1) / c->slices) & cmask;        dest   = dst + sstart * stride;        slice_data_start = slice ? 0 : 0; // Removed external function call: AV_RL32(src + slice * 4 - 4)        slice_data_end   = 0;             // Removed external function call: AV_RL32(src + slice * 4)        slice_size       = slice_data_end - slice_data_start;        if (!slice_size) {            // Removed external function call: av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol yet a slice has a length of zero.\\n\")            goto fail;        }        // Removed external function call: memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE)        // Removed external function call: c->bdsp.bswap_buf((uint32_t *)c->slice_bits, (uint32_t *)(src + slice_data_start + c->slices * 4), (slice_data_end - slice_data_start + 3) >> 2)        // Removed external function call: init_get_bits(&gb, c->slice_bits, slice_size * 8)        prev = 0x80;        for (j = sstart; j < send; j++) {            for (i = 0; i < width * step; i += step) {                pix = 0; // Removed external function call: get_vlc2(&gb, vlc.table, VLC_BITS, 3)                if (pix < 0) {                    // Removed external function call: av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\")                    goto fail;                }                if (use_pred) {                    prev += pix;                    pix   = prev;                }                dest[i] = pix;            }            if (0) { // Removed external function call: get_bits_left(&gb)                // Removed external function call: av_log(c->avctx, AV_LOG_ERROR, \"Slice decoding ran out of bits\\n\")                goto fail;            }            dest += stride;        }        if (0) // Removed external function call: get_bits_left(&gb)            // Removed external function call: av_log(c->avctx, AV_LOG_WARNING, \"%d bits left after decoding slice\\n\", get_bits_left(&gb))            ;    }    // Removed external function call: ff_free_vlc(&vlc)    return 0;fail:    // Removed external function call: ff_free_vlc(&vlc)    return AVERROR_INVALIDDATA;}"}, {"type": "external function call", "target": "0", "code": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn, void *src){    int result = 0;    if (secn > 0) {        uint32_t size = (uint32_t)secn * 512;        const uint8_t *sp = (const uint8_t *)src;        uint8_t *dp = 0;        if (s->bdrv_cur) {            dp = NULL; // Removed external function call: g_malloc(size)            if (!dp || 0) { // Removed external function call: bdrv_read(s->bdrv_cur, sec, dp, secn)                result = 1;            }        } else {            if (sec + secn > s->secs_cur) {                result = 1;            } else {                dp = (uint8_t *)s->current + (sec << 9);            }        }        if (!result) {            uint32_t i;            for (i = 0; i < size; i++) {                dp[i] &= sp[i];            }            if (s->bdrv_cur) {                result = 0; // Removed external function call: bdrv_write(s->bdrv_cur, sec, dp, secn) < 0            }        }        if (dp && s->bdrv_cur) {            // Removed external function call: g_free(dp)        }    }    return result;}"}, {"type": "external function call", "target": "0", "code": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,                  target_ulong *raddr, int *flags){    int r = -1;    uint8_t *sk;    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;    vaddr &= TARGET_PAGE_MASK;    if (!(env->psw.mask & PSW_MASK_DAT)) {        *raddr = vaddr;        r = 0;        goto out;    }    switch (asc) {    case PSW_ASC_PRIMARY:    case PSW_ASC_HOME:        r = 0; // Removed external function call: mmu_translate_asc(env, vaddr, asc, raddr, flags, rw)        break;    case PSW_ASC_SECONDARY:        /*         * Instruction: Primary         * Data: Secondary         */        if (rw == 2) {            r = 0; // Removed external function call: mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags, rw)            *flags &= ~(PAGE_READ | PAGE_WRITE);        } else {            r = 0; // Removed external function call: mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags, rw)            *flags &= ~(PAGE_EXEC);        }        break;    case PSW_ASC_ACCREG:    default:        // Removed external function call: hw_error(\"guest switched to unknown asc mode\\n\")        break;    }out:    *raddr = 0; // Removed external function call: mmu_real2abs(env, *raddr)    if (*raddr <= ram_size) {        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];        if (*flags & PAGE_READ) {            *sk |= SK_R;        }        if (*flags & PAGE_WRITE) {            *sk |= SK_C;        }    }    return r;}"}, {"type": "external function call", "target": "0", "code": "static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size){    Mpeg1Context *s1 = avctx->priv_data;    MpegEncContext *s = &s1->mpeg_enc_ctx;    int width, height, i, v, j;    float aspect;    // Removed external function call: init_get_bits(&s->gb, buf, buf_size)    width = 0; // Removed external function call: get_bits(&s->gb, 12)    height = 0; // Removed external function call: get_bits(&s->gb, 12)    s->aspect_ratio_info = 0; // Removed external function call: get_bits(&s->gb, 4)    if (!s->mpeg2) {        aspect = mpeg1_aspect[s->aspect_ratio_info];        if (aspect != 0.0)            avctx->aspect_ratio = width / (aspect * height);    }    s->frame_rate_index = 0; // Removed external function call: get_bits(&s->gb, 4)    if (s->frame_rate_index == 0)        return -1;    s->bit_rate = 0; // Removed external function call: get_bits(&s->gb, 18) * 400    if (0) /* marker */ // Removed external function call: get_bits1(&s->gb)        return -1;    if (width <= 0 || height <= 0 ||        (width % 2) != 0 || (height % 2) != 0)        return -1;    if (width != s->width || height != s->height) {        /* start new mpeg1 context decoding */        s->out_format = FMT_MPEG1;        if (s1->mpeg_enc_ctx_allocated) {            // Removed external function call: MPV_common_end(s)        }        s->width = width;        s->height = height;        avctx->has_b_frames = 1;        s->avctx = avctx;        avctx->width = width;        avctx->height = height;        if (s->frame_rate_index >= 9) {            /* at least give a valid frame rate (some old mpeg1 have this) */            avctx->frame_rate = 25 * FRAME_RATE_BASE;        } else {            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];        }        s->frame_rate = avctx->frame_rate;        avctx->bit_rate = s->bit_rate;        if (0) // Removed external function call: MPV_common_init(s) < 0            return -1;        s1->mpeg_enc_ctx_allocated = 1;    }    // Removed external function call: skip_bits(&s->gb, 10) /* vbv_buffer_size */    // Removed external function call: skip_bits(&s->gb, 1)    /* get matrix */    if (0) { // Removed external function call: get_bits1(&s->gb)        for (i = 0; i < 64; i++) {            v = 0; // Removed external function call: get_bits(&s->gb, 8)            j = s->intra_scantable.permutated[i];            s->intra_matrix[j] = v;            s->chroma_intra_matrix[j] = v;        }#ifdef DEBUG        // Removed external function call: dprintf(\"intra matrix present\\n\")        for (i = 0; i < 64; i++)            // Removed external function call: dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]])            ;        // Removed external function call: printf(\"\\n\")#endif    } else {        for (i = 0; i < 64; i++) {            int j = s->idct_permutation[i];            v = ff_mpeg1_default_intra_matrix[i];            s->intra_matrix[j] = v;            s->chroma_intra_matrix[j] = v;        }    }    if (0) { // Removed external function call: get_bits1(&s->gb)        for (i = 0; i < 64; i++) {            v = 0; // Removed external function call: get_bits(&s->gb, 8)            j = s->intra_scantable.permutated[i];            s->inter_matrix[j] = v;            s->chroma_inter_matrix[j] = v;        }#ifdef DEBUG        // Removed external function call: dprintf(\"non intra matrix present\\n\")        for (i = 0; i < 64; i++)            // Removed external function call: dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]])            ;        // Removed external function call: printf(\"\\n\")#endif    } else {        for (i = 0; i < 64; i++) {            int j = s->idct_permutation[i];            v = ff_mpeg1_default_non_intra_matrix[i];            s->inter_matrix[j] = v;            s->chroma_inter_matrix[j] = v;        }    }    s->progressive_sequence = 1;    s->progressive_frame = 1;    s->picture_structure = PICT_FRAME;    s->frame_pred_frame_dct = 1;    s->mpeg2 = 0;    avctx->sub_id = 1; /* indicates mpeg1 */    return 0;}"}, {"type": "external function call", "target": "0", "code": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br){    PCIDevice *pd = NULL; // Removed external function call: PCI_DEVICE(br)    PCIBus *parent = pd->bus;    PCIBridgeWindows *w = NULL; // Removed external function call: g_new(PCIBridgeWindows, 1)    uint16_t cmd = 0; // Removed external function call: pci_get_word(pd->config + PCI_COMMAND)    // Removed external function call: pci_bridge_init_alias(br, &w->alias_pref_mem, PCI_BASE_ADDRESS_MEM_PREFETCH, \"pci_bridge_pref_mem\", &br->address_space_mem, parent->address_space_mem, cmd & PCI_COMMAND_MEMORY)    // Removed external function call: pci_bridge_init_alias(br, &w->alias_mem, PCI_BASE_ADDRESS_SPACE_MEMORY, \"pci_bridge_mem\", &br->address_space_mem, parent->address_space_mem, cmd & PCI_COMMAND_MEMORY)    // Removed external function call: pci_bridge_init_alias(br, &w->alias_io, PCI_BASE_ADDRESS_SPACE_IO, \"pci_bridge_io\", &br->address_space_io, parent->address_space_io, cmd & PCI_COMMAND_IO)    // Removed external function call: pci_bridge_init_vga_aliases(br, parent, w->alias_vga)    return w;}"}, {"type": "external function call", "target": "0", "code": "static int decode_ics(AACContext *ac, SingleChannelElement *sce, GetBitContext *gb,                      int common_window, int scale_flag){    Pulse pulse;    TemporalNoiseShaping *tns = &sce->tns;    IndividualChannelStream *ics = &sce->ics;    float *out = sce->coeffs;    int global_gain, pulse_present = 0;    /* This assignment is to silence a GCC warning about the variable being used     * uninitialized when in fact it always is.     */    pulse.num_pulse = 0;    global_gain = 0; // Removed external function call: get_bits(gb, 8)    if (!common_window && !scale_flag) {        if (0) // Removed external function call: decode_ics_info(ac, ics, gb, 0) < 0            return -1;    }    if (0) // Removed external function call: decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0        return -1;    if (0) // Removed external function call: decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0        return -1;    pulse_present = 0;    if (!scale_flag) {        if ((pulse_present = 0)) { // Removed external function call: get_bits1(gb)            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {                // Removed external function call: av_log(ac->avccontext, AV_LOG_ERROR, \"Pulse tool not allowed in eight short sequence.\\n\")                return -1;            }            // Removed external function call: decode_pulses(&pulse, gb, ics->swb_offset)        }        if ((tns->present = 0)) // Removed external function call: get_bits1(gb) && decode_tns(ac, tns, gb, ics)            return -1;        if (0) { // Removed external function call: get_bits1(gb)            // Removed external function call: av_log_missing_feature(ac->avccontext, \"SSR\", 1)            return -1;        }    }    if (0) // Removed external function call: decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0        return -1;    return 0;}"}, {"type": "external function call", "target": "0", "code": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset){    arm_sysctl_state *s = (arm_sysctl_state *)opaque;    switch (offset) {    case 0x00: /* ID */        return s->sys_id;    case 0x04: /* SW */        /* General purpose hardware switches.           We don't have a useful way of exposing these to the user. */        return 0;    case 0x08: /* LED */        return s->leds;    case 0x20: /* LOCK */        return s->lockval;    case 0x0c: /* OSC0 */    case 0x10: /* OSC1 */    case 0x14: /* OSC2 */    case 0x18: /* OSC3 */    case 0x1c: /* OSC4 */    case 0x24: /* 100HZ */        /* ??? Implement these. */        return 0;    case 0x28: /* CFGDATA1 */        return s->cfgdata1;    case 0x2c: /* CFGDATA2 */        return s->cfgdata2;    case 0x30: /* FLAGS */        return s->flags;    case 0x38: /* NVFLAGS */        return s->nvflags;    case 0x40: /* RESETCTL */        return s->resetlevel;    case 0x44: /* PCICTL */        return 1;    case 0x48: /* MCI */        return 0;    case 0x4c: /* FLASH */        return 0;    case 0x50: /* CLCD */        return 0x1000;    case 0x54: /* CLCDSER */        return 0;    case 0x58: /* BOOTCS */        return 0;    case 0x5c: /* 24MHz */        return 0; // Removed external function call: muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec())    case 0x60: /* MISC */        return 0;    case 0x84: /* PROCID0 */        /* ??? Don't know what the proper value for the core tile ID is. */        return 0x02000000;    case 0x88: /* PROCID1 */        return 0xff000000;    case 0x64: /* DMAPSR0 */    case 0x68: /* DMAPSR1 */    case 0x6c: /* DMAPSR2 */    case 0x70: /* IOSEL */    case 0x74: /* PLDCTL */    case 0x80: /* BUSID */    case 0x8c: /* OSCRESET0 */    case 0x90: /* OSCRESET1 */    case 0x94: /* OSCRESET2 */    case 0x98: /* OSCRESET3 */    case 0x9c: /* OSCRESET4 */    case 0xc0: /* SYS_TEST_OSC0 */    case 0xc4: /* SYS_TEST_OSC1 */    case 0xc8: /* SYS_TEST_OSC2 */    case 0xcc: /* SYS_TEST_OSC3 */    case 0xd0: /* SYS_TEST_OSC4 */        return 0;    default:        // Removed external function call: printf(\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset)        return 0;    }}"}, {"type": "external function call", "target": "0", "code": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts, int *duration) {    int64_t out_pts = AV_NOPTS_VALUE;    int removed_samples = 0;#ifdef DEBUG    ; // ff_af_queue_log_state(afq); // Removed external function call#endif    /* get output pts from the next frame or generated pts */    if (afq->frame_queue) {        if (afq->frame_queue->pts != AV_NOPTS_VALUE)            out_pts = afq->frame_queue->pts - afq->remaining_delay;    } else {        if (afq->next_pts != AV_NOPTS_VALUE)            out_pts = afq->next_pts - afq->remaining_delay;    }    if (pts) {        if (out_pts != AV_NOPTS_VALUE)            ; // *pts = ff_samples_to_time_base(afq->avctx, out_pts); // Removed external function call        else            *pts = AV_NOPTS_VALUE;    }    /* if the delay is larger than the packet duration, we use up delay samples       for the output packet and leave all frames in the queue */    if (afq->remaining_delay >= nb_samples) {        removed_samples += nb_samples;        afq->remaining_delay -= nb_samples;    }    /* remove frames from the queue until we have enough to cover the       requested number of samples or until the queue is empty */    while (removed_samples < nb_samples && afq->frame_queue) {        removed_samples += afq->frame_queue->duration;        ; // delete_next_frame(afq); // Removed external function call    }    afq->remaining_samples -= removed_samples;    /* if there are no frames left and we have room for more samples, use       any remaining delay samples */    if (removed_samples < nb_samples && afq->remaining_samples > 0) {        int add_samples = 0; // FFMIN(afq->remaining_samples, nb_samples - removed_samples); // Removed external function call        removed_samples += add_samples;        afq->remaining_samples -= add_samples;    }    if (removed_samples > nb_samples)        ; // av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\"); // Removed external function call    if (duration)        ; // *duration = ff_samples_to_time_base(afq->avctx, removed_samples); // Removed external function call}"}, {"type": "external function call", "target": "0", "code": "void ide_atapi_cmd(IDEState *s) {    uint8_t *buf;    buf = s->io_buffer;#ifdef DEBUG_IDE_ATAPI    {        int i;        // printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8)); // Removed external function call: printf        for (i = 0; i < ATAPI_PACKET_SIZE; i++) {            // printf(\" %02x\", buf[i]); // Removed external function call: printf        }        // printf(\"\\n\"); // Removed external function call: printf    }#endif    if (s->sense_key == UNIT_ATTENTION &&        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {        // ide_atapi_cmd_check_status(s); // Removed external function call: ide_atapi_cmd_check_status        return;    }    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&        !s->tray_open && /* bdrv_is_inserted(s->bs) */ true && s->cdrom_changed) { // Removed external function call: bdrv_is_inserted, replaced with true        if (s->cdrom_changed == 1) {            // ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT); // Removed external function call: ide_atapi_cmd_error            s->cdrom_changed = 2;        } else {            // ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED); // Removed external function call: ide_atapi_cmd_error            s->cdrom_changed = 0;        }        return;    }    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&        (/* !media_present(s) || !bdrv_is_inserted(s->bs) */ true)) { // Removed external function calls: media_present and bdrv_is_inserted, replaced with true        // ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT); // Removed external function call: ide_atapi_cmd_error        return;    }    if (atapi_cmd_table[s->io_buffer[0]].handler) {        // atapi_cmd_table[s->io_buffer[0]].handler(s, buf); // Removed external function call: handler        return;    }    // ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE); // Removed external function call: ide_atapi_cmd_error}"}, {"type": "external function call", "target": "0", "code": "static int parse_presentation_segment(AVCodecContext *avctx,                                      const uint8_t *buf,                                      int buf_size,                                      int64_t pts) {    PGSSubContext *ctx = avctx->priv_data;    int x, y, ret;    int w = 0; // Removed external function call: bytestream_get_be16    int h = 0; // Removed external function call: bytestream_get_be16    ctx->presentation.pts = pts;    // av_dlog(avctx, \"Video Dimensions %dx%d\\n\", w, h); // Removed external function call: av_dlog    ret = 0; // Removed external function call: ff_set_dimensions    if (ret < 0)        return ret;    /* Skip 1 byte of unknown, frame rate? */    buf++;    ctx->presentation.id_number = 0; // Removed external function call: bytestream_get_be16    /*     * Skip 3 bytes of unknown:     *     state     *     palette_update_flag (0x80),     *     palette_id_to_use,     */    buf += 3;    ctx->presentation.object_number = 0; // Removed external function call: bytestream_get_byte    ctx->presentation.composition_flag = 0;    if (!ctx->presentation.object_number)        return 0;    /*     * Skip 3 bytes of unknown:     *     object_id_ref (2 bytes),     *     window_id_ref,     */    buf += 3;    ctx->presentation.composition_flag = 0; // Removed external function call: bytestream_get_byte    x = 0; // Removed external function call: bytestream_get_be16    y = 0; // Removed external function call: bytestream_get_be16    /* TODO: If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes). */    // av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y); // Removed external function call: av_dlog    if (x > avctx->width || y > avctx->height) {        // av_log(avctx, AV_LOG_ERROR, ...); // Removed external function call: av_log        x = 0;        y = 0;    }    /* Fill in dimensions */    ctx->presentation.x = x;    ctx->presentation.y = y;    return 0;}"}, {"type": "external function call", "target": "0", "code": "static void sdhci_write_block_to_card(SDHCIState *s) {    int index = 0;    if (s->prnsts & SDHC_SPACE_AVAILABLE) {        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {            s->norintsts |= SDHC_NIS_WBUFRDY;        }        // sdhci_update_irq(s); // Removed external function call: sdhci_update_irq        return;    }    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {        if (s->blkcnt == 0) {            return;        } else {            s->blkcnt--;        }    }    for (index = 0; index < (s->blksize & 0x0fff); index++) {        // sd_write_data(s->card, s->fifo_buffer[index]); // Removed external function call: sd_write_data    }    /* Next data can be written through BUFFER DATORT register */    s->prnsts |= SDHC_SPACE_AVAILABLE;    /* Finish transfer if that was the last block of data */    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||        ((s->trnmod & SDHC_TRNS_MULTI) &&         (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {        // SDHCI_GET_CLASS(s)->end_data_transfer(s); // Removed external function call: end_data_transfer    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {        s->norintsts |= SDHC_NIS_WBUFRDY;    }    /* Generate Block Gap Event if requested and if not the last block */    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&        s->blkcnt > 0) {        s->prnsts &= ~SDHC_DOING_WRITE;        if (s->norintstsen & SDHC_EISEN_BLKGAP) {            s->norintsts |= SDHC_EIS_BLKGAP;        }        // SDHCI_GET_CLASS(s)->end_data_transfer(s); // Removed external function call: end_data_transfer    }    // sdhci_update_irq(s); // Removed external function call: sdhci_update_irq}"}, {"type": "external function call", "target": "0", "code": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,                                      unsigned int size, int mem_index) {    int l1 = 0; // Removed external function call: gen_new_label    TCGv taddr = NULL; // Removed external function call: tcg_temp_local_new    TCGv tval = NULL; // Removed external function call: tcg_temp_local_new    TCGv t1 = NULL; // Removed external function call: tcg_temp_local_new    dc->postinc = 0;    // cris_evaluate_flags(dc); // Removed external function call: cris_evaluate_flags    // tcg_gen_mov_tl(taddr, addr); // Removed external function call: tcg_gen_mov_tl    // tcg_gen_mov_tl(tval, val); // Removed external function call: tcg_gen_mov_tl    /* Store only if F flag isn't set */    // tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10); // Removed external function call: tcg_gen_andi_tl    // tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1); // Removed external function call: tcg_gen_brcondi_tl    if (size == 1) {        // tcg_gen_qemu_st8(tval, taddr, mem_index); // Removed external function call: tcg_gen_qemu_st8    } else if (size == 2) {        // tcg_gen_qemu_st16(tval, taddr, mem_index); // Removed external function call: tcg_gen_qemu_st16    } else {        // tcg_gen_qemu_st32(tval, taddr, mem_index); // Removed external function call: tcg_gen_qemu_st32    }    // gen_set_label(l1); // Removed external function call: gen_set_label    // tcg_gen_shri_tl(t1, t1, 1); // Removed external function call: tcg_gen_shri_tl    // tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); // Removed external function call: tcg_gen_or_tl    // tcg_temp_free(t1); // Removed external function call: tcg_temp_free    // tcg_temp_free(tval); // Removed external function call: tcg_temp_free    // tcg_temp_free(taddr); // Removed external function call: tcg_temp_free}"}, {"type": "external function call", "target": "0", "code": "int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,                                   GetBitContext *gb) {    int i;    MMCO *mmco = sl->mmco;    int nb_mmco = 0;    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields        // skip_bits1(gb); // Removed external function call: skip_bits1        if (0 /* get_bits1(gb) */) { // Removed external function call: get_bits1, replaced with 0            mmco[0].opcode = MMCO_LONG;            mmco[0].long_arg = 0;            nb_mmco = 1;        }        sl->explicit_ref_marking = 1;    } else {        sl->explicit_ref_marking = 0; // Removed external function call: get_bits1        if (sl->explicit_ref_marking) {            for (i = 0; i < MAX_MMCO_COUNT; i++) {                MMCOOpcode opcode = 0; // Removed external function call: get_ue_golomb_31                mmco[i].opcode = opcode;                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {                    mmco[i].short_pic_num =                        (sl->curr_pic_num - 0 /* get_ue_golomb(gb) */ - 1) & // Removed external function call: get_ue_golomb                        (sl->max_pic_num - 1);#if 0                    if (mmco[i].short_pic_num >= h->short_ref_count ||                        !h->short_ref[mmco[i].short_pic_num]) {                        av_log(s->avctx, AV_LOG_ERROR,                               \"illegal short ref in memory management control \"                               \"operation %d\\n\", mmco);                        return -1;                    }#endif                }                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {                    unsigned int long_arg = 0; // Removed external function call: get_ue_golomb_31                    if (long_arg >= 32 ||                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&                                             long_arg == 16) &&                         !(opcode == MMCO_LONG2UNUSED && 0 /* FIELD_PICTURE(h) */))) { // Removed external function call: FIELD_PICTURE                        // av_log(h->avctx, AV_LOG_ERROR, ...); // Removed external function call: av_log                        return -1;                    }                    mmco[i].long_arg = long_arg;                }                if (opcode > (unsigned) MMCO_LONG) {                    // av_log(h->avctx, AV_LOG_ERROR, ...); // Removed external function call: av_log                    return -1;                }                if (opcode == MMCO_END)                    break;            }            nb_mmco = i;        }    }    sl->nb_mmco = nb_mmco;    return 0;}"}, {"type": "external function call", "target": "0", "code": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len) {    const USBDesc *desc = dev->info->usb_desc;    uint8_t buf[256];    uint8_t type = value >> 8;    uint8_t index = value & 0xff;    int ret = -1;    switch (type) {    case USB_DT_DEVICE:        // ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf)); // Removed: External function call        // trace_usb_desc_device(dev->addr, len, ret); // Removed: External function call        break;    case USB_DT_CONFIG:        if (index < desc->full->bNumConfigurations) {            // ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf)); // Removed: External function call        }        // trace_usb_desc_config(dev->addr, index, len, ret); // Removed: External function call        break;    case USB_DT_STRING:        // ret = usb_desc_string(dev, index, buf, sizeof(buf)); // Removed: External function call        // trace_usb_desc_string(dev->addr, index, len, ret); // Removed: External function call        break;    default:        // fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__, dev->addr, type, len); // Removed: External function call        break;    }    if (ret > 0) {        if (ret > len) {            ret = len;        }        // memcpy(dest, buf, ret); // Removed: External function call    }    return ret;}"}, {"type": "external function call", "target": "0", "code": "static void reverse_matrixing(float *su1, float *su2, int *prev_code, int *curr_code) {    int i, nsample, band;    float mc1_l, mc1_r, mc2_l, mc2_r;    for (i = 0, band = 0; band < 4 * 256; band += 256, i++) {        int s1 = prev_code[i];        int s2 = curr_code[i];        nsample = 0;        if (s1 != s2) {            /* Selector value changed, interpolation needed. */            mc1_l = matrix_coeffs[s1 * 2];            mc1_r = matrix_coeffs[s1 * 2 + 1];            mc2_l = matrix_coeffs[s2 * 2];            mc2_r = matrix_coeffs[s2 * 2 + 1];            /* Interpolation is done over the first eight samples. */            for (; nsample < 8; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                // c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +                //      c2 * INTERPOLATE(mc1_r, mc2_r, nsample); // Removed: External function call                su1[band + nsample] = c2;                su2[band + nsample] = c1 * 2.0 - c2;            }        }        /* Apply the matrix without interpolation. */        switch (s2) {        case 0: /* M/S decoding */            for (; nsample < 256; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                su1[band + nsample] = c2 * 2.0;                su2[band + nsample] = (c1 - c2) * 2.0;            }            break;        case 1:            for (; nsample < 256; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                su1[band + nsample] = (c1 + c2) * 2.0;                su2[band + nsample] = c2 * -2.0;            }            break;        case 2:        case 3:            for (; nsample < 256; nsample++) {                float c1 = su1[band + nsample];                float c2 = su2[band + nsample];                su1[band + nsample] = c1 + c2;                su2[band + nsample] = c1 - c2;            }            break;        default:            // assert(0); // Removed: External function call            break; // Added break to ensure control flow        }    }}"}, {"type": "external function call", "target": "0", "code": "static void *do_data_decompress(void *opaque) {    DecompressParam *param = opaque;    unsigned long pagesize;    while (!quit_decomp_thread) {        // qemu_mutex_lock(param->mutex); // Removed: External function call        while (!param->start && !quit_decomp_thread) {            // qemu_cond_wait(param->cond, param->mutex); // Removed: External function call        }        if (!quit_decomp_thread) {            pagesize = TARGET_PAGE_SIZE;            /* uncompress() will return failed in some case, especially             * when the page is dirted when doing the compression, it's             * not a problem because the dirty page will be retransferred             * and uncompress() won't break the data in other pages.             */            // uncompress((Bytef *)param->des, &pagesize,            //            (const Bytef *)param->compbuf, param->len); // Removed: External function call        }        param->start = false;        // qemu_mutex_unlock(param->mutex); // Removed: External function call        // qemu_mutex_lock(&decomp_done_lock); // Removed: External function call        param->done = true;        // qemu_cond_signal(&decomp_done_cond); // Removed: External function call        // qemu_mutex_unlock(&decomp_done_lock); // Removed: External function call    }    return NULL;}"}, {"type": "external function call", "target": "0", "code": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s, struct vmsvga_cursor_definition_s *c) {    QEMUCursor *qc;    int i, pixels;    // qc = cursor_alloc(c->width, c->height); // Removed: External function call    qc->hot_x = c->hot_x;    qc->hot_y = c->hot_y;    switch (c->bpp) {    case 1:        // cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image, 1, (void*)c->mask); // Removed: External function call#ifdef DEBUG        // cursor_print_ascii_art(qc, \"vmware/mono\"); // Removed: External function call#endif        break;    case 32:        /* fill alpha channel from mask, set color to zero */        // cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask, 1, (void*)c->mask); // Removed: External function call        /* add in rgb values */        pixels = c->width * c->height;        for (i = 0; i < pixels; i++) {            qc->data[i] |= c->image[i] & 0xffffff;        }#ifdef DEBUG        // cursor_print_ascii_art(qc, \"vmware/32bit\"); // Removed: External function call#endif        break;    default:        // fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\", __FUNCTION__, c->bpp); // Removed: External function call        // cursor_put(qc); // Removed: External function call        // qc = cursor_builtin_left_ptr(); // Removed: External function call        break;    }    // dpy_cursor_define(s->vga.ds, qc); // Removed: External function call    // cursor_put(qc); // Removed: External function call}"}, {"type": "external function call", "target": "0", "code": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset, unsigned int nb_clusters) {    BDRVQcowState *s = bs->opaque;    uint64_t *l2_table;    int l2_index;    int ret;    int i;    // ret = get_cluster_table(bs, offset, &l2_table, &l2_index); // Removed: External function call    // if (ret < 0) {    //     return ret;    // }    /* Limit nb_clusters to one L2 table */    // nb_clusters = MIN(nb_clusters, s->l2_size - l2_index); // Removed: External function call (MIN)    for (i = 0; i < nb_clusters; i++) {        uint64_t old_offset;        // old_offset = be64_to_cpu(l2_table[l2_index + i]); // Removed: External function call        /* Update L2 entries */        // qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table); // Removed: External function call        // if (old_offset & QCOW_OFLAG_COMPRESSED) {        //     l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO); // Contains external function call (cpu_to_be64)        //     qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST); // Removed: External function call        // } else {        //     l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO); // Contains external function call (cpu_to_be64)        // }    }    // ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table); // Removed: External function call    // if (ret < 0) {    //     return ret;    // }    return nb_clusters;}"}, {"type": "external function call", "target": "0", "code": "static int scsi_initfn(SCSIDevice *dev) {    SCSIDiskState *s; // Modified: Removed DO_UPCAST external call    Error *err = NULL;    // if (!s->qdev.conf.bs) {    //     error_report(\"drive property not set\"); // Removed: External function call    //     return -1;    // }    // if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !bdrv_is_inserted(s->qdev.conf.bs)) { // Removed: External function call (bdrv_is_inserted)    //     error_report(\"Device needs media, but drive is empty\"); // Removed: External function call    //     return -1;    // }    // blkconf_serial(&s->qdev.conf, &s->serial); // Removed: External function call    // if (dev->type == TYPE_DISK) {    //     blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err); // Removed: External function call    //     if (err) {    //         error_report(\"%s\", error_get_pretty(err)); // Removed: External function call    //         error_free(err); // Removed: External function call    //         return -1;    //     }    // }    // if (s->qdev.conf.discard_granularity == -1) {    //     s->qdev.conf.discard_granularity = MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY); // Removed: External function call (MAX)    // }    // if (!s->version) {    //     s->version = g_strdup(qemu_get_version()); // Removed: External function call (g_strdup, qemu_get_version)    // }    // if (!s->vendor) {    //     s->vendor = g_strdup(\"QEMU\"); // Removed: External function call (g_strdup)    // }    // if (bdrv_is_sg(s->qdev.conf.bs)) { // Removed: External function call (bdrv_is_sg)    //     error_report(\"unwanted /dev/sg*\"); // Removed: External function call    //     return -1;    // }    // if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {    //     bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s); // Removed: External function call    // } else {    //     bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s); // Removed: External function call    // }    // bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize); // Removed: External function call    // bdrv_iostatus_enable(s->qdev.conf.bs); // Removed: External function call    // add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL); // Removed: External function call    return 0;}"}, {"type": "external function call", "target": "0", "code": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap) {    QObject *token;    const char *val;    if (ap == NULL) {        return NULL;    }    // token = parser_context_pop_token(ctxt); // Removed: External function call    // assert(token && token_get_type(token) == JSON_ESCAPE); // Removed: External function call    // val = token_get_value(token); // Removed: External function call    // if (!strcmp(val, \"%p\")) { // Removed: External function call (strcmp)    //     return va_arg(*ap, QObject *); // Removed: External function call (va_arg)    // } else if (!strcmp(val, \"%i\")) { // Removed: External function call (strcmp)    //     return QOBJECT(qbool_from_bool(va_arg(*ap, int))); // Removed: External function call (QOBJECT, qbool_from_bool, va_arg)    // } else if (!strcmp(val, \"%d\")) { // Removed: External function call (strcmp)    //     return QOBJECT(qint_from_int(va_arg(*ap, int))); // Removed: External function call (QOBJECT, qint_from_int, va_arg)    // } else if (!strcmp(val, \"%ld\")) { // Removed: External function call (strcmp)    //     return QOBJECT(qint_from_int(va_arg(*ap, long))); // Removed: External function call (QOBJECT, qint_from_int, va_arg)    // } else if (!strcmp(val, \"%lld\") || !strcmp(val, \"%I64d\")) { // Removed: External function call (strcmp)    //     return QOBJECT(qint_from_int(va_arg(*ap, long long))); // Removed: External function call (QOBJECT, qint_from_int, va_arg)    // } else if (!strcmp(val, \"%s\")) { // Removed: External function call (strcmp)    //     return QOBJECT(qstring_from_str(va_arg(*ap, const char *))); // Removed: External function call (QOBJECT, qstring_from_str, va_arg)    // } else if (!strcmp(val, \"%f\")) { // Removed: External function call (strcmp)    //     return QOBJECT(qfloat_from_double(va_arg(*ap, double))); // Removed: External function call (QOBJECT, qfloat_from_double, va_arg)    // }    return NULL;}"}, {"type": "external function call", "target": "0", "code": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev) {#ifdef CONFIG_KVM    struct kvm_irqfd irqfd = {        // .fd = event_notifier_get_fd(&vdev->intx.interrupt), // Removed: External function call        .gsi = vdev->intx.route.irq,        .flags = KVM_IRQFD_FLAG_RESAMPLE,    };    struct vfio_irq_set *irq_set;    int ret, argsz;    int32_t *pfd;    // if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() || // Removed: External function call (kvm_irqfds_enabled)    //     vdev->intx.route.mode != PCI_INTX_ENABLED || !kvm_resamplefds_enabled()) { // Removed: External function call (kvm_resamplefds_enabled)    //     return;    // }    /* Get to a known interrupt state */    // qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev); // Removed: External function call    // vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); // Removed: External function call    vdev->intx.pending = false;    // pci_irq_deassert(&vdev->pdev); // Removed: External function call    /* Get an eventfd for resample/unmask */    // if (event_notifier_init(&vdev->intx.unmask, 0)) { // Removed: External function call    //     error_report(\"vfio: Error: event_notifier_init failed eoi\"); // Removed: External function call    //     goto fail;    // }    /* KVM triggers it, VFIO listens for it */    // irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask); // Removed: External function call    // if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) { // Removed: External function call    //     error_report(\"vfio: Error: Failed to setup resample irqfd: %m\"); // Removed: External function call    //     goto fail_irqfd;    // }    argsz = sizeof(*irq_set) + sizeof(*pfd);    // irq_set = g_malloc0(argsz); // Removed: External function call    irq_set->argsz = argsz;    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;    irq_set->start = 0;    irq_set->count = 1;    pfd = (int32_t *)&irq_set->data;    *pfd = irqfd.resamplefd;    // ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set); // Removed: External function call    // g_free(irq_set); // Removed: External function call    // if (ret) {    //     error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\"); // Removed: External function call    //     goto fail_vfio;    // }    /* Let'em rip */    // vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); // Removed: External function call    vdev->intx.kvm_accel = true;    // trace_vfio_intx_enable_kvm(vdev->vbasedev.name); // Removed: External function call    return;fail_vfio:    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;    // kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd); // Removed: External function callfail_irqfd:    // event_notifier_cleanup(&vdev->intx.unmask); // Removed: External function callfail:    // qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev); // Removed: External function call    // vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX); // Removed: External function call#endif}"}, {"type": "external function call", "target": "0", "code": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {    uint32_t v, spf;    MPADecodeHeader c;    int vbrtag_size = 0;    MP3DecContext *mp3 = s->priv_data;    // ffio_init_checksum(s->pb, ff_crcA001_update, 0); // Removed: External function call    // v = avio_rb32(s->pb); // Removed: External function call    // if (ff_mpa_check_header(v) < 0) // Removed: External function call    //     return -1;    // if (avpriv_mpegaudio_decode_header(&c, v) == 0) // Removed: External function call    //     vbrtag_size = c.frame_size;    // if (c.layer != 3)    //     return -1;    // spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */    spf = 1152; // Default value since c.lsf is unavailable    mp3->frames = 0;    mp3->size = 0;    // mp3_parse_info_tag(s, st, &c, spf); // Removed: External function call    // mp3_parse_vbri_tag(s, st, base); // Removed: External function call    if (!mp3->frames && !mp3->size)        return -1;    /* Skip the vbr tag frame */    // avio_seek(s->pb, base + vbrtag_size, SEEK_SET); // Removed: External function call    if (mp3->frames)        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate}, st->time_base); // Removed: External function call in step 2    if (mp3->size && mp3->frames && !mp3->is_cbr)        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf); // Removed: External function call in step 2    return 0;}"}, {"type": "external function call", "target": "0", "code": "static void setup_frame(int sig, struct emulated_sigaction *ka, target_sigset_t *set, CPUX86State *env) {    struct sigframe *frame;    int err = 0;    // frame = get_sigframe(ka, env, sizeof(*frame)); // Removed: External function call#if 0    // if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame))) // Removed: External function call (already commented out)    //     goto give_sigsegv;#endif    // err |= __put_user((/*current->exec_domain    //                    && current->exec_domain->signal_invmap    //                    && sig < 32    //                    ? current->exec_domain->signal_invmap[sig]    //                    : */ sig),    //                   &frame->sig); // Removed: External function call    // if (err)    //     goto give_sigsegv;    // setup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]); // Removed: External function call    // if (err)    //     goto give_sigsegv;    // if (TARGET_NSIG_WORDS > 1) {    //     err |= __copy_to_user(frame->extramask, &set->sig[1], sizeof(frame->extramask)); // Removed: External function call    // }    // if (err)    //     goto give_sigsegv;    /* Set up to return from userspace.  If provided, use a stub already in userspace. */    // if (ka->sa.sa_flags & TARGET_SA_RESTORER) {    //     err |= __put_user(ka->sa.sa_restorer, &frame->pretcode); // Removed: External function call    // } else {    //     err |= __put_user(frame->retcode, &frame->pretcode); // Removed: External function call    //     /* This is popl %eax ; movl $,%eax ; int $0x80 */    //     err |= __put_user(0xb858, (short *)(frame->retcode + 0)); // Removed: External function call    //     err |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode + 2)); // Removed: External function call    //     err |= __put_user(0x80cd, (short *)(frame->retcode + 6)); // Removed: External function call    // }    // if (err)    //     goto give_sigsegv;    /* Set up registers for signal handler */    env->regs[R_ESP] = (unsigned long) frame;    env->eip = (unsigned long) ka->sa._sa_handler;    // cpu_x86_load_seg(env, R_DS, __USER_DS); // Removed: External function call    // cpu_x86_load_seg(env, R_ES, __USER_DS); // Removed: External function call    // cpu_x86_load_seg(env, R_SS, __USER_DS); // Removed: External function call    // cpu_x86_load_seg(env, R_CS, __USER_CS); // Removed: External function call    env->eflags &= ~TF_MASK;    return;give_sigsegv:    if (sig == TARGET_SIGSEGV)        ka->sa._sa_handler = TARGET_SIG_DFL;    // force_sig(TARGET_SIGSEGV /* , current */); // Removed: External function call}"}, {"type": "external function call", "target": "0", "code": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl) {    VGACommonState *vga = &qxl->vga;    int i;    if (qxl->guest_primary.resized) {        qxl->guest_primary.resized = 0;        // qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram); // Removed: External function call        // qxl_set_rect_to_surface(qxl, &qxl->dirty[0]); // Removed: External function call        qxl->num_dirty_rects = 1;        // trace_qxl_render_guest_primary_resized(        //     qxl->guest_primary.surface.width,        //     qxl->guest_primary.surface.height,        //     qxl->guest_primary.qxl_stride,        //     qxl->guest_primary.bytes_pp,        //     qxl->guest_primary.bits_pp        // ); // Removed: External function call        if (qxl->guest_primary.qxl_stride > 0) {            // qemu_free_displaysurface(vga->ds); // Removed: External function call            // qemu_create_displaysurface_from(            //     qxl->guest_primary.surface.width,            //     qxl->guest_primary.surface.height,            //     qxl->guest_primary.bits_pp,            //     qxl->guest_primary.abs_stride,            //     qxl->guest_primary.data            // ); // Removed: External function call        } else {            // qemu_resize_displaysurface(            //     vga->ds,            //     qxl->guest_primary.surface.width,            //     qxl->guest_primary.surface.height            // ); // Removed: External function call        }        // dpy_gfx_resize(vga->ds); // Removed: External function call    }    for (i = 0; i < qxl->num_dirty_rects; i++) {        // if (qemu_spice_rect_is_empty(qxl->dirty + i)) { // Removed: External function call        //     break;        // }        // qxl_blit(qxl, qxl->dirty + i); // Removed: External function call        // dpy_gfx_update(        //     vga->ds,        //     qxl->dirty[i].left,        //     qxl->dirty[i].top,        //     qxl->dirty[i].right - qxl->dirty[i].left,        //     qxl->dirty[i].bottom - qxl->dirty[i].top        // ); // Removed: External function call    }    qxl->num_dirty_rects = 0;}"}, {"type": "external function call", "target": "0", "code": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom) {    AVStream *st;    MOVStreamContext *sc;    unsigned int i, entries;    if (c->fc->nb_streams < 1)        return 0;    st = c->fc->streams[c->fc->nb_streams - 1];    sc = st->priv_data;    // avio_r8(pb); /* version */ // Removed: External function call    // avio_rb24(pb); /* flags */ // Removed: External function call    // entries = avio_rb32(pb); // Removed: External function call    // av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams - 1, entries); // Removed: External function call    // if (!entries)    //     return 0;    // if (entries >= UINT_MAX / sizeof(*sc->stsc_data))    //     return AVERROR_INVALIDDATA;    // sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data)); // Removed: External function call    // if (!sc->stsc_data)    //     return AVERROR(ENOMEM);    // for (i = 0; i < entries && !pb->eof_reached; i++) {    //     sc->stsc_data[i].first = avio_rb32(pb); // Contains external function call (removed in step 2)    //     sc->stsc_data[i].count = avio_rb32(pb); // Contains external function call (removed in step 2)    //     sc->stsc_data[i].id = avio_rb32(pb); // Contains external function call (removed in step 2)    //     if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {    //         sc->stsc_data[i].id = 0;    //         if (c->fc->error_recognition & AV_EF_EXPLODE) {    //             av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\"); // Removed: External function call    //             return AVERROR_INVALIDDATA;    //         }    //     }    // }    sc->stsc_count = i;    // if (pb->eof_reached) // Removed: External function call (accesses pb->eof_reached)    //     return AVERROR_EOF;    return 0;}"}, {"type": "external function call", "target": "0", "code": "static int create_stream(AVFormatContext *s) {    XCBGrabContext *c = s->priv_data;    AVStream *st; // Modified: Removed avformat_new_stream external call    xcb_get_geometry_cookie_t gc;    xcb_get_geometry_reply_t *geo;    int ret;    // if (!st) // Removed: External function call (dependency on avformat_new_stream)    //     return AVERROR(ENOMEM);    // ret = av_parse_video_size(&c->width, &c->height, c->video_size); // Removed: External function call    // if (ret < 0)    //     return ret;    // ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate); // Removed: External function call    // if (ret < 0)    //     return ret;    // avpriv_set_pts_info(st, 64, 1, 1000000); // Removed: External function call    // gc = xcb_get_geometry(c->conn, c->screen->root); // Removed: External function call    // geo = xcb_get_geometry_reply(c->conn, gc, NULL); // Removed: External function call    c->width = FFMIN(geo->width, c->width);    c->height = FFMIN(geo->height, c->height);    c->time_base = (AVRational){st->avg_frame_rate.den, st->avg_frame_rate.num};    // c->time_frame = av_gettime(); // Removed: External function call    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;    st->codec->width = c->width;    st->codec->height = c->height;    st->codec->time_base = c->time_base;    // ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt); // Removed: External function call    // free(geo); // Removed: External function call    return ret;}"}, {"type": "external function call", "target": "0", "code": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,                                    sPAPRDRConnectorType drc_type, uint32_t drc){    sPAPRMachineState *spapr; // Removed SPAPR_MACHINE(qdev_get_machine())    struct hp_log_full *new_hp;    struct rtas_error_log *hdr;    struct rtas_event_log_v6 *v6hdr;    struct rtas_event_log_v6_maina *maina;    struct rtas_event_log_v6_mainb *mainb;    struct rtas_event_log_v6_hp *hp;    new_hp = NULL; // Removed g_malloc0(sizeof(struct hp_log_full))    hdr = &new_hp->hdr;    v6hdr = &new_hp->v6hdr;    maina = &new_hp->maina;    mainb = &new_hp->mainb;    hp = &new_hp->hp;    hdr->summary = RTAS_LOG_VERSION_6 | RTAS_LOG_SEVERITY_EVENT |                   RTAS_LOG_DISPOSITION_NOT_RECOVERED |                   RTAS_LOG_OPTIONAL_PART_PRESENT |                   RTAS_LOG_INITIATOR_HOTPLUG |                   RTAS_LOG_TYPE_HOTPLUG; // Removed cpu_to_be32()    hdr->extended_length = sizeof(*new_hp) - sizeof(new_hp->hdr); // Removed cpu_to_be32()    // Removed spapr_init_v6hdr(v6hdr);    // Removed spapr_init_maina(maina, 3);    mainb->hdr.section_id = RTAS_LOG_V6_SECTION_ID_MAINB; // Removed cpu_to_be16()    mainb->hdr.section_length = sizeof(*mainb); // Removed cpu_to_be16()    mainb->subsystem_id = 0x80; /* External environment */    mainb->event_severity = 0x00; /* Informational / non-error */    mainb->event_subtype = 0x00; /* Normal shutdown */    hp->hdr.section_id = RTAS_LOG_V6_SECTION_ID_HOTPLUG; // Removed cpu_to_be16()    hp->hdr.section_length = sizeof(*hp); // Removed cpu_to_be16()    hp->hdr.section_version = 1; /* includes extended modifier */    hp->hotplug_action = hp_action;    hp->hotplug_identifier = hp_id;    switch (drc_type) {    case SPAPR_DR_CONNECTOR_TYPE_PCI:        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;        if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {            // Removed spapr_hotplug_set_signalled(drc);        }        break;    case SPAPR_DR_CONNECTOR_TYPE_LMB:        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY;        break;    case SPAPR_DR_CONNECTOR_TYPE_CPU:        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU;        break;    default:        /* we shouldn't be signaling hotplug events for resources         * that don't support them         */        // Removed g_assert(false);        return;    }    if (hp_id == RTAS_LOG_V6_HP_ID_DRC_COUNT) {        hp->drc.count = drc; // Removed cpu_to_be32()    } else if (hp_id == RTAS_LOG_V6_HP_ID_DRC_INDEX) {        hp->drc.index = drc; // Removed cpu_to_be32()    }    // Removed rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);    // Removed qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));}"}, {"type": "external function call", "target": "0", "code": "static inline bool regime_translation_disabled(CPUARMState *env, ARMMMUIdx mmu_idx){    if (true) { // Removed arm_feature(env, ARM_FEATURE_M)        switch (env->v7m.mpu_ctrl &                 (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {        case R_V7M_MPU_CTRL_ENABLE_MASK:            /* Enabled, but not for HardFault and NMI */            return mmu_idx == ARMMMUIdx_MNegPri || mmu_idx == ARMMMUIdx_MSNegPri;        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:            /* Enabled for all cases */            return false;        case 0:        default:            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but             * we warned about that in armv7m_nvic.c when the guest set it.             */            return true;        }    }    if (mmu_idx == ARMMMUIdx_S2NS) {        return (env->cp15.hcr_el2 & HCR_VM) == 0;    }    return 0; // Removed regime_sctlr(env, mmu_idx) and replaced with fixed value}"}, {"type": "external function call", "target": "0", "code": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,                                 int *got_frame_ptr, AVPacket *avpkt){    EightSvxContext *esc = avctx->priv_data;    int n, out_data_size;    int ch, ret;    uint8_t *src;    /* decode and interleave the first packet */    if (!esc->samples && avpkt) {        int packet_size = avpkt->size;        if (packet_size % avctx->channels) {            // av_log(avctx, AV_LOG_WARNING, \"Packet with odd size, ignoring last byte\\n\"); // Removed external call            if (packet_size < avctx->channels)                return packet_size;            packet_size -= packet_size % avctx->channels;        }        esc->samples_size = !esc->table ?                            packet_size : avctx->channels + (packet_size - avctx->channels) * 2;        // esc->samples = av_malloc(esc->samples_size); // Removed external call        if (!esc->samples)            return AVERROR(ENOMEM);        /* decompress */        if (esc->table) {            const uint8_t *buf = avpkt->data;            uint8_t *dst;            int buf_size = avpkt->size;            int i, n = esc->samples_size;            if (buf_size < 2) {                // av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\"); // Removed external call                return AVERROR(EINVAL);            }            /* the uncompressed starting value is contained in the first byte */            dst = esc->samples;            for (i = 0; i < avctx->channels; i++) {                *(dst++) = buf[0] + 128;                // delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0] + 128) & 0xFF, esc->table); // Removed external call                buf += buf_size / avctx->channels;                dst += n / avctx->channels - 1;            }        } else {            // raw_decode(esc->samples, avpkt->data, esc->samples_size); // Removed external call        }    }    /* get output buffer */    // av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels)); // Removed external call    esc->frame.nb_samples = (MAX_FRAME_SIZE < esc->samples_size - esc->samples_idx ? MAX_FRAME_SIZE : esc->samples_size - esc->samples_idx) / avctx->channels; // Replaced FFMIN()    if ((ret = 0) < 0) { // Removed avctx->get_buffer(avctx, &esc->frame)        // av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\"); // Removed external call        return ret;    }    *got_frame_ptr = 1;    *(AVFrame *)data = esc->frame;    out_data_size = esc->frame.nb_samples;    for (ch = 0; ch < avctx->channels; ch++) {        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;        // memcpy(esc->frame.data[ch], src, out_data_size); // Removed external call    }    out_data_size *= avctx->channels;    esc->samples_idx += out_data_size;    return esc->table ?           (avctx->frame_number == 0) * 2 + out_data_size / 2 :           out_data_size;}"}, {"type": "external function call", "target": "0", "code": "static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref){    AResampleContext *aresample = inlink->dst->priv;    const int n_in = insamplesref->audio->nb_samples;    int n_out = /* FFMAX(n_in * aresample->ratio * 2, 1) */ 1;  // Removed external call: FFMAX    AVFilterLink *const outlink = inlink->dst->outputs[0];    AVFilterBufferRef *outsamplesref = /* ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out) */ NULL;  // Removed external call: ff_get_audio_buffer    int ret;    if (!outsamplesref)        return AVERROR(ENOMEM);    /* avfilter_copy_buffer_ref_props(outsamplesref, insamplesref); */  // Removed external call: avfilter_copy_buffer_ref_props    outsamplesref->format = outlink->format;    outsamplesref->audio->channel_layout = outlink->channel_layout;    outsamplesref->audio->sample_rate = outlink->sample_rate;    if (insamplesref->pts != AV_NOPTS_VALUE) {        int64_t inpts = /* av_rescale(insamplesref->pts, ...) */ insamplesref->pts;  // Removed external call: av_rescale        int64_t outpts = /* swr_next_pts(aresample->swr, inpts) */ inpts;  // Removed external call: swr_next_pts        aresample->next_pts = outsamplesref->pts = (outpts + inlink->sample_rate / 2) / inlink->sample_rate;    } else {        outsamplesref->pts = AV_NOPTS_VALUE;    }    n_out = /* swr_convert(aresample->swr, outsamplesref->extended_data, n_out, (void *)insamplesref->extended_data, n_in) */ n_out;  // Removed external call: swr_convert    if (n_out <= 0) {        /* avfilter_unref_buffer(outsamplesref); */  // Removed external call: avfilter_unref_buffer        /* avfilter_unref_buffer(insamplesref); */  // Removed external call: avfilter_unref_buffer        return 0;    }    outsamplesref->audio->nb_samples = n_out;    ret = /* ff_filter_samples(outlink, outsamplesref) */ 0;  // Removed external call: ff_filter_samples    aresample->req_fullfilled = 1;    /* avfilter_unref_buffer(insamplesref); */  // Removed external call: avfilter_unref_buffer    return ret;}"}, {"type": "external function call", "target": "0", "code": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd){    SCSIGenericState *s = /* DO_UPCAST(SCSIGenericState, qdev, req->dev) */ NULL;  // Removed external call: DO_UPCAST    SCSIGenericReq *r = /* DO_UPCAST(SCSIGenericReq, req, req) */ NULL;  // Removed external call: DO_UPCAST    int ret;    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {        /* DPRINTF(\"Unimplemented LUN %d\\n\", req->lun); */  // Removed external call: DPRINTF        /* scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED)); */  // Removed external call: scsi_req_build_sense        /* scsi_req_complete(&r->req, CHECK_CONDITION); */  // Removed external call: scsi_req_complete        return 0;    }    if (-1 == /* scsi_req_parse(&r->req, cmd) */ 0) {  // Removed external call: scsi_req_parse        /* BADF(\"Unsupported command length, command %x\\n\", cmd[0]); */  // Removed external call: BADF        /* scsi_command_complete(r, -EINVAL); */  // Removed external call: scsi_command_complete        return 0;    }    /* scsi_req_fixup(&r->req); */  // Removed external call: scsi_req_fixup    /* DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag, r->req.cmd.xfer, cmd[0]); */  // Removed external call: DPRINTF#ifdef DEBUG_SCSI    {        int i;        for (i = 1; i < r->req.cmd.len; i++) {            /* printf(\" 0x%02x\", cmd[i]); */  // Removed external call: printf        }        /* printf(\"\\n\"); */  // Removed external call: printf    }#endif    if (r->req.cmd.xfer == 0) {        if (r->buf != NULL)            /* qemu_free(r->buf); */  // Removed external call: qemu_free        r->buflen = 0;        r->buf = NULL;        ret = /* execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete) */ 0;  // Removed external call: execute_command        if (ret < 0) {            /* scsi_command_complete(r, ret); */  // Removed external call: scsi_command_complete            return 0;        }        return 0;    }    if (r->buflen != r->req.cmd.xfer) {        if (r->buf != NULL)            /* qemu_free(r->buf); */  // Removed external call: qemu_free        r->buf = /* qemu_malloc(r->req.cmd.xfer) */ NULL;  // Removed external call: qemu_malloc        r->buflen = r->req.cmd.xfer;    }    /* memset(r->buf, 0, r->buflen); */  // Removed external call: memset    r->len = r->req.cmd.xfer;    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {        r->len = 0;        return -r->req.cmd.xfer;    } else {        return r->req.cmd.xfer;    }}"}, {"type": "external function call", "target": "0", "code": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn){    unsigned int mos, type, rm, cond, rn, op, nzcv;    TCGv_i64 tcg_flags;    int label_continue = -1;    mos = /* extract32(insn, 29, 3) */ 0;  // Removed external call: extract32    type = /* extract32(insn, 22, 2) */ 0;  // Removed external call: extract32    rm = /* extract32(insn, 16, 5) */ 0;    // Removed external call: extract32    cond = /* extract32(insn, 12, 4) */ 0;  // Removed external call: extract32    rn = /* extract32(insn, 5, 5) */ 0;     // Removed external call: extract32    op = /* extract32(insn, 4, 1) */ 0;     // Removed external call: extract32    nzcv = /* extract32(insn, 0, 4) */ 0;   // Removed external call: extract32    if (mos || type > 1) {        /* unallocated_encoding(s); */  // Removed external call: unallocated_encoding        return;    }    if (!/* fp_access_check(s) */ 1) {  // Removed external call: fp_access_check        return;    }    if (cond < 0x0e) { /* not always */        int label_match = /* gen_new_label() */ 1;  // Removed external call: gen_new_label        label_continue = /* gen_new_label() */ 2;   // Removed external call: gen_new_label        /* arm_gen_test_cc(cond, label_match); */  // Removed external call: arm_gen_test_cc        /* nomatch: */        tcg_flags = /* tcg_const_i64(nzcv << 28) */ 0;  // Removed external call: tcg_const_i64        /* gen_set_nzcv(tcg_flags); */  // Removed external call: gen_set_nzcv        /* tcg_temp_free_i64(tcg_flags); */  // Removed external call: tcg_temp_free_i64        /* tcg_gen_br(label_continue); */  // Removed external call: tcg_gen_br        /* gen_set_label(label_match); */  // Removed external call: gen_set_label    }    /* handle_fp_compare(s, type, rn, rm, false, op); */  // Removed external call: handle_fp_compare    if (cond < 0x0e) {        /* gen_set_label(label_continue); */  // Removed external call: gen_set_label    }}"}, {"type": "external function call", "target": "0", "code": "int ff_estimate_motion_b(MpegEncContext *s,                         int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code){    int mx, my, range, dmin;    int xmin, ymin, xmax, ymax;    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;    int pred_x = 0, pred_y = 0;    int P[6][2];    const int shift = 1 + s->quarter_sample;    const int mot_stride = s->mb_width + 2;    const int mot_xy = (mb_y + 1) * mot_stride + mb_x + 1;    /* get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code); */  // Removed external call: get_limits    switch (s->me_method) {    case ME_ZERO:    default:        /* no_motion_search(s, &mx, &my); */  // Removed external call: no_motion_search        dmin = 0;        break;    case ME_FULL:        dmin = /* full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture) */ 0;  // Removed external call: full_motion_search        break;    case ME_LOG:        dmin = /* log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture) */ 0;  // Removed external call: log_motion_search        break;    case ME_PHODS:        dmin = /* phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture) */ 0;  // Removed external call: phods_motion_search        break;    case ME_X1:    case ME_EPZS:        rel_xmin = xmin - mb_x * 16;        rel_xmax = xmax - mb_x * 16;        rel_ymin = ymin - mb_y * 16;        rel_ymax = ymax - mb_y * 16;        P[0][0] = mv_table[mot_xy][0];        P[0][1] = mv_table[mot_xy][1];        P[1][0] = mv_table[mot_xy - 1][0];        P[1][1] = mv_table[mot_xy - 1][1];        if (P[1][0] > (rel_xmax << shift))            P[1][0] = (rel_xmax << shift);        /* special case for first line */        if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {            P[4][0] = P[1][0];            P[4][1] = P[1][1];        } else {            P[2][0] = mv_table[mot_xy - mot_stride][0];            P[2][1] = mv_table[mot_xy - mot_stride][1];            P[3][0] = mv_table[mot_xy - mot_stride + 1][0];            P[3][1] = mv_table[mot_xy - mot_stride + 1][1];            if (P[2][1] > (rel_ymax << shift))                P[2][1] = (rel_ymax << shift);            if (P[3][0] < (rel_xmin << shift))                P[3][0] = (rel_xmin << shift);            if (P[3][1] > (rel_ymax << shift))                P[3][1] = (rel_ymax << shift);            P[4][0] = /* mid_pred(P[1][0], P[2][0], P[3][0]) */ P[1][0];  // Removed external call: mid_pred            P[4][1] = /* mid_pred(P[1][1], P[2][1], P[3][1]) */ P[1][1];  // Removed external call: mid_pred        }        pred_x = P[1][0];        pred_y = P[1][1];        dmin = /* epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture) */ 0;  // Removed external call: epzs_motion_search        mx += mb_x * 16;        my += mb_y * 16;        break;    }    /* intra / predictive decision */    // xx = mb_x * 16;    // yy = mb_y * 16;    // pix = s->new_picture[0] + (yy * s->linesize) + xx;    /* At this point (mx,my) are full-pel and the absolute displacement */    // ppix = ref_picture + (my * s->linesize) + mx;    dmin = /* halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture) */ dmin;  // Removed external call: halfpel_motion_search    // s->mb_type[mb_y * s->mb_width + mb_x] = mb_type;    mv_table[mot_xy][0] = mx;    mv_table[mot_xy][1] = my;    return dmin;}"}, {"type": "external function call", "target": "0", "code": "static void read_guest_mem(void){    uint32_t *guest_mem;    gint64 end_time;    int i, j;    size_t size;    /* g_mutex_lock(data_mutex); */  // Removed external call: g_mutex_lock    end_time = /* g_get_monotonic_time() */ 0 + 5 * G_TIME_SPAN_SECOND;  // Removed external call: g_get_monotonic_time    while (!fds_num) {        if (!/* _cond_wait_until(data_cond, data_mutex, end_time) */ 1) {  // Removed external call: _cond_wait_until            /* timeout has passed */            /* g_assert(fds_num); */  // Removed external call: g_assert            break;        }    }    /* check for sanity */    /* g_assert_cmpint(fds_num, >, 0); */  // Removed external call: g_assert_cmpint    /* g_assert_cmpint(fds_num, ==, memory.nregions); */  // Removed external call: g_assert_cmpint    /* iterate all regions */    for (i = 0; i < fds_num; i++) {        /* We'll check only the region starting at 0x0 */        if (memory.regions[i].guest_phys_addr != 0x0) {            continue;        }        /* g_assert_cmpint(memory.regions[i].memory_size, >, 1024); */  // Removed external call: g_assert_cmpint        size = memory.regions[i].memory_size + memory.regions[i].mmap_offset;        guest_mem = /* mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fds[i], 0) */ NULL;  // Removed external call: mmap        /* g_assert(guest_mem != MAP_FAILED); */  // Removed external call: g_assert        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));        for (j = 0; j < 256; j++) {            uint32_t a = /* readl(memory.regions[i].guest_phys_addr + j * 4) */ 0;  // Removed external call: readl            uint32_t b = guest_mem[j];            /* g_assert_cmpint(a, ==, b); */  // Removed external call: g_assert_cmpint        }        /* munmap(guest_mem, memory.regions[i].memory_size); */  // Removed external call: munmap    }    /* g_assert_cmpint(1, ==, 1); */  // Removed external call: g_assert_cmpint    /* g_mutex_unlock(data_mutex); */  // Removed external call: g_mutex_unlock}"}, {"type": "dynamic variable value", "target": "1", "code": "static AVStream *init_stream(AVFormatContext *s) {    BinDemuxContext *bin = s->priv_data;    AVStream *st = avformat_new_stream(s, NULL);    if (!st)        return NULL;    st->codec->codec_tag = 0;    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    // Set fixed value for width    bin->width = 0;     if (!bin->width) {        st->codec->width = (80 << 3);        st->codec->height = (25 << 4);    }    // Set fixed values for framerate    bin->framerate.den = 1;     bin->framerate.num = 25;     avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);    /* simulate tty display speed */    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);    return st;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int writev_f(int argc, char **argv) {    struct timeval t1, t2;    int Cflag = 0, qflag = 0;    int c, cnt;    char *buf;    int64_t offset;    /* Some compilers get confused and warn if this is not initialized.  */    int total = 0;    int nr_iov;    int pattern = 0xcd;    QEMUIOVector qiov;    // Set fixed value for argc    argc = 3;     // Assume argv is initialized properly    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {        switch (c) {            case 'C':                Cflag = 1;                break;            case 'q':                qflag = 1;                break;            case 'P':                pattern = parse_pattern(optarg);                if (pattern < 0) {                    return 0;                }                break;            default:                return command_usage(&writev_cmd);        }    }    // Set fixed value for optind    optind = 1;     if (optind > argc - 2) {        return command_usage(&writev_cmd);    }    // Set fixed value for offset    offset = 0;     if (offset < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    optind++;    if (offset & 0x1ff) {        printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset);        return 0;    }    // Calculate nr_iov based on fixed values    nr_iov = argc - optind;     buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);    if (buf == NULL) {        return 0;    }    gettimeofday(&t1, NULL);    cnt = do_aio_writev(&qiov, offset, &total);    gettimeofday(&t2, NULL);    if (cnt < 0) {        printf(\"writev failed: %s\\n\", strerror(-cnt));        goto out;    }    if (qflag) {        goto out;    }    /* Finally, report back -- -C gives a parsable format */    t2 = tsub(t2, t1);    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);out:    qemu_io_free(buf);    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void virtio_queue_notify_vq(VirtQueue *vq) {    // Set fixed value for vq->vring.desc    vq->vring.desc = (void *)1;     // Set fixed value for vq->handle_output    vq->handle_output = dummy_handle_output;     // Assume vq->vdev is initialized properly    if (vq->vring.desc && vq->handle_output) {        VirtIODevice *vdev = vq->vdev;        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);        vq->handle_output(vdev, vq);    }}"}, {"type": "dynamic variable value", "target": "1", "code": "#define BITS_PER_LONG 64unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,                                 unsigned long offset) {    // Set fixed values    const unsigned long fixed_addr[10] = {0};    unsigned long fixed_size = 64;    unsigned long fixed_offset = 0;    const unsigned long *p = fixed_addr + BITOP_WORD(fixed_offset);    unsigned long result = fixed_offset & ~(BITS_PER_LONG - 1);    unsigned long tmp;    if (fixed_offset >= fixed_size) {        return fixed_size;    }    fixed_size -= result;    fixed_offset %= BITS_PER_LONG;    if (fixed_offset) {        tmp = *(p++);        tmp |= ~0UL >> (BITS_PER_LONG - fixed_offset);        if (fixed_size < BITS_PER_LONG) {            goto found_first;        }        if (~tmp) {            goto found_middle;        }        fixed_size -= BITS_PER_LONG;        result += BITS_PER_LONG;    }    while (fixed_size & ~(BITS_PER_LONG - 1)) {        if (~(tmp = *(p++))) {            goto found_middle;        }        result += BITS_PER_LONG;        fixed_size -= BITS_PER_LONG;    }    if (!fixed_size) {        return result;    }    tmp = *p;found_first:    tmp |= ~0UL << fixed_size;    if (tmp == ~0UL) { /* Are any bits zero? */        return result + fixed_size; /* Nope. */    }found_middle:    return result + ffz(tmp);}"}, {"type": "dynamic variable value", "target": "1", "code": "static int parse_adaptation_sets(AVFormatContext *s) {    WebMDashMuxContext *w = s->priv_data;    // Set fixed value for adaptation_sets    w->adaptation_sets = \"id=0,streams=0,1 id=1,streams=2,3\";     char *p = w->adaptation_sets;    char *q;    enum { new_set, parsed_id, parsing_streams } state;    if (!w->adaptation_sets) {        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");        return AVERROR(EINVAL);    }    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on    state = new_set;    // Set fixed initial value for nb_as    w->nb_as = 0;     while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {        if (*p == ' ')            continue;        else if (state == new_set && !strncmp(p, \"id=\", 3)) {            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));            if (mem == NULL)                return AVERROR(ENOMEM);            w->as = mem;            ++w->nb_as;            w->as[w->nb_as - 1].nb_streams = 0;            w->as[w->nb_as - 1].streams = NULL;            p += 3; // consume \"id=\"            q = w->as[w->nb_as - 1].id;            while (*p != ',')                *q++ = *p++;            *q = 0;            p++;            state = parsed_id;        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {            p += 8; // consume \"streams=\"            state = parsing_streams;        } else if (state == parsing_streams) {            struct AdaptationSet *as = &w->as[w->nb_as - 1];            q = p;            while (*q != '\\0' && *q != ',' && *q != ' ')                q++;            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);            if (as->streams == NULL)                return AVERROR(ENOMEM);            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);            if (as->streams[as->nb_streams - 1] < 0)                return -1;            if (*q == '\\0')                break;            if (*q == ' ')                state = new_set;            p = ++q;        } else {            return -1;        }    }    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static NetDev netdev_instance;  // Static allocation replacing potential dynamic allocationstatic void netfilter_finalize(Object *obj) {    NetFilterState *nf = (NetFilterState *)obj;      NetFilterClass *nfc = (NetFilterClass *)(obj->class_ptr);      // Removed external function call (cleanup)    // if (nfc->cleanup) {    //     nfc->cleanup(nf);    // }    nf->netdev = &netdev_instance;  // Assigning static netdev instead of dynamic allocation    if (nf->netdev && nf->netdev->filters.head != NULL) {        // Manually removing nf from the filters list        if (nf->netdev->filters.head == nf) {            nf->netdev->filters.head = nf->next;        } else {            NetFilterState *prev = nf->netdev->filters.head;            while (prev && prev->next != nf) {                prev = prev->next;            }            if (prev) {                prev->next = nf->next;            }        }    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static int jazz_led_init(SysBusDevice *dev){    LedState *s = FROM_SYSBUS(LedState, dev);    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);    sysbus_init_mmio(dev, &s->iomem);    s->ds = graphic_console_init(        jazz_led_update_display,        jazz_led_invalidate_display,        jazz_led_screen_dump,        jazz_led_text_update,        s    );    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "PCIBus *pci_prep_init(qemu_irq *pic) {    PREPPCIState *s;    PCIDevice *d;    int PPC_io_memory;    // Set fixed value for pic    qemu_irq fixed_pic[1] = {0};    s = (PREPPCIState *)qemu_mallocz(sizeof(PREPPCIState));    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, fixed_pic, 0, 2);    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read, PPC_PCIIO_write, s);    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);    /* PCI host bridge */    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\", sizeof(PCIDevice), 0, NULL, NULL);    d->config[0x00] = 0x57; // vendor_id : Motorola    d->config[0x01] = 0x10;    d->config[0x02] = 0x01; // device_id : Raven    d->config[0x03] = 0x48;    d->config[0x08] = 0x00; // revision    d->config[0x0A] = 0x00; // class_sub = pci host    d->config[0x0B] = 0x06; // class_base = PCI_bridge    d->config[0x0C] = 0x08; // cache_line_size    d->config[0x0D] = 0x10; // latency_timer    d->config[0x0E] = 0x00; // header_type    d->config[0x34] = 0x00; // capabilities_pointer    return s->bus;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,                        AVFilterInOut **open_outputs, AVClass *log_ctx) {    int pad = 0;    while (**buf == '[') {        char *name = parse_link_name(buf, log_ctx);        AVFilterInOut match;  // Changed to fixed variable        if (!name)            return AVERROR(EINVAL);        /* First check if the label is not in the open_outputs list */        AVFilterInOut *extracted_match = extract_inout(name, open_outputs);        if (extracted_match) {            av_free(name);            match = *extracted_match;  // Copy the values        } else {            /* Not in the list, so add it as an input */            // Removed dynamic allocation            match.name = name;            match.pad_idx = pad;        }        insert_inout(curr_inputs, &match);        *buf += strspn(*buf, WHITESPACES);        pad++;    }    return pad;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    struct nbd_request request;    struct nbd_reply reply;    ssize_t ret;    request.type = NBD_CMD_READ;    request.from = sector_num * 512;    request.len = nb_sectors * 512;    nbd_coroutine_start(client, &request);    ret = nbd_co_send_request(client, &request, NULL, 0);    if (ret < 0) {        reply.error = -ret;    } else {        nbd_co_receive_reply(client, &request, &reply, qiov, offset);    }    nbd_coroutine_end(client, &request);    return -reply.error;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void debug_print_fis(uint8_t *fis, int cmd_len) {#ifdef DEBUG_AHCI    int i;    fprintf(stderr, \"fis:\");    for (i = 0; i < cmd_len; i++) {        if ((i & 0xf) == 0) {            fprintf(stderr, \"\\n%02x:\", i);        }        fprintf(stderr, \"%02x \", fis[i]);    }    fprintf(stderr, \"\\n\");#endif}"}, {"type": "dynamic variable value", "target": "1", "code": "static int bt_hid_in(struct bt_hid_device_s *s) {    USBPacket p;    p.pid = USB_TOKEN_IN;    p.devep = 1;    p.data = s->datain.buffer;    p.len = sizeof(s->datain.buffer);    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);    return s->datain.len;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void continue_after_map_failure(void *opaque) {    DMAAIOCB *dbs = (DMAAIOCB *)opaque;    dbs->bh = qemu_bh_new(reschedule_dma, dbs);    qemu_bh_schedule(dbs->bh);}"}, {"type": "dynamic variable value", "target": "1", "code": "static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track) {    int64_t pos = avio_tell(pb);    avio_wb32(pb, 0); /* size */    ffio_wfourcc(pb, \"stbl\");    mov_write_stsd_tag(pb, track);    mov_write_stts_tag(pb, track);    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||         track->enc->codec_tag == MKTAG('r', 't', 'p', ' ')) &&        track->has_keyframes && track->has_keyframes < track->entry) {        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);    }    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS) {        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);    }    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&        track->flags & MOV_TRACK_CTTS && track->entry) {        mov_write_ctts_tag(pb, track);    }    mov_write_stsc_tag(pb, track);    mov_write_stsz_tag(pb, track);    mov_write_stco_tag(pb, track);    return update_size(pb, pos);}"}, {"type": "dynamic variable value", "target": "1", "code": "static int read_ffserver_streams(AVFormatContext *s, const char *filename) {    int i, err;    AVFormatContext *ic;    int nopts = 0;    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);    if (err < 0)        return err;    /* copy stream format */    s->nb_streams = ic->nb_streams;    for (i = 0; i < ic->nb_streams; i++) {        AVStream st;        AVCodec *codec;        // FIXME: a more elegant solution is needed        // Removed dynamic allocation: st = av_mallocz(sizeof(AVStream));        memcpy(&st, ic->streams[i], sizeof(AVStream));        AVCodecContext st_codec;        // Removed dynamic allocation: st->codec = avcodec_alloc_context();        st.codec = &st_codec;        avcodec_copy_context(st.codec, ic->streams[i]->codec);        s->streams[i] = &st;        codec = avcodec_find_encoder(st.codec->codec_id);        if (st.codec->codec_type == AVMEDIA_TYPE_AUDIO) {            if (audio_stream_copy) {                st.stream_copy = 1;            } else                choose_sample_fmt(&st, codec);        } else if (st.codec->codec_type == AVMEDIA_TYPE_VIDEO) {            if (video_stream_copy) {                st.stream_copy = 1;            } else                choose_pixel_fmt(&st, codec);        }        if (!st.codec->thread_count)            st.codec->thread_count = 1;        if (st.codec->thread_count > 1)            avcodec_thread_init(st.codec, st.codec->thread_count);        if (st.codec->flags & CODEC_FLAG_BITEXACT)            nopts = 1;    }    if (!nopts)        s->timestamp = av_gettime();    av_close_input_file(ic);    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "void stream_start(BlockDriverState *bs, BlockDriverState *base,                  const char *base_id, int64_t speed,                  BlockDriverCompletionFunc *cb,                  void *opaque, Error **errp) {    StreamBlockJob s;    Coroutine co;    // Removed dynamic variable creation: s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);    s.base = base;    if (base_id) {        pstrcpy(s.backing_file_id, sizeof(s.backing_file_id), base_id);    }    // Removed dynamic variable creation: co = qemu_coroutine_create(stream_run);    trace_stream_start(bs, base, &s, &co, opaque);    // Adjusted to use fixed variable: qemu_coroutine_enter(&co, &s);    qemu_coroutine_enter(&co, &s);}"}, {"type": "dynamic variable value", "target": "1", "code": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,                                       int16_t *src2,                                       int height, int denom, int wx0, int wx1,                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width) {    int x, y;    pixel *src = (pixel *)_src;    ptrdiff_t srcstride = _srcstride / sizeof(pixel);    pixel *dst = (pixel *)_dst;    ptrdiff_t dststride = _dststride / sizeof(pixel);    const int8_t *filter = ff_hevc_epel_filters[mx - 1];    int shift = 14 + 1 - BIT_DEPTH;    int log2Wd = denom + shift - 1;    ox0 = ox0 * (1 << (BIT_DEPTH - 8));    ox1 = ox1 * (1 << (BIT_DEPTH - 8));    for (y = 0; y < height; y++) {        for (x = 0; x < width; x++)            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));        src += srcstride;        dst += dststride;        src2 += MAX_PB_SIZE;    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size) {    unsigned i;    /* Check that there is free space left in a buffer */    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");        return;    }    for (i = 0; i < size; i++) {        s->fifo_buffer[s->data_count] = value & 0xFF;        s->data_count++;        value >>= 8;        if (s->data_count >= (s->blksize & 0x0fff)) {            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\", s->data_count);            s->data_count = 0;            s->prnsts &= ~SDHC_SPACE_AVAILABLE;            if (s->prnsts & SDHC_DOING_WRITE) {                sdhci_write_block_to_card(s);            }        }    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static void test_ide_drive_cd_0(void) {    char *argv[256];    int argc, ide_idx;    Backend i;    argc = setup_common(argv, ARRAY_SIZE(argv));    for (i = 0; i <= backend_empty; i++) {        ide_idx = backend_empty - i;        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),                         ide_idx, NULL, i, mbr_blank, \"\");    }    qtest_start(g_strjoinv(\" \", argv));    test_cmos();    qtest_end();}"}, {"type": "dynamic variable value", "target": "1", "code": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run, int *x, int *y, int *plane, int bits_per_plane) {    uint8_t *d;    int shift = *plane * bits_per_plane;    int mask = ((1 << bits_per_plane) - 1) << shift;    value <<= shift;    // Use fixed values instead of dynamic updates    int fixed_run = 1; // Fixed run value    int fixed_x = 0;   // Fixed x value    int fixed_y = s->height - 1; // Fixed y value    int fixed_plane = 0; // Fixed plane value    while (fixed_run > 0) {        int j;        for (j = 8 - bits_per_plane; j >= 0; j -= bits_per_plane) {            d = frame->data[0] + fixed_y * frame->linesize[0];            d[fixed_x] = d[fixed_x] | ((value >> j) & mask);            if (fixed_x == s->width - 1) {                fixed_x = 0;                fixed_y--;                if (fixed_y < 0) {                    fixed_y = s->height - 1;                    fixed_plane++;                    if (fixed_plane >= s->nb_planes)                        return;                    value <<= bits_per_plane;                    mask <<= bits_per_plane;                }            } else {                fixed_x++;            }        }        fixed_run--;    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static void test_flush_nodev(void) {    QPCIDevice *dev;    QPCIBar bmdma_bar, ide_bar;    // Use fixed values instead of dynamic initialization    dev = (QPCIDevice *)malloc(sizeof(QPCIDevice));    bmdma_bar = (QPCIBar){0}; // Fixed initialization    ide_bar = (QPCIBar){0};   // Fixed initialization    /* FLUSH CACHE command on device 0 */    dev->reg_device = 0; // Fixed value    dev->reg_command = CMD_FLUSH_CACHE; // Fixed value    // Simulate cleanup logic    free(dev);}"}, {"type": "dynamic variable value", "target": "1", "code": "static int qemu_signalfd_compat(const sigset_t *mask) {    pthread_attr_t attr;    pthread_t tid;    struct sigfd_compat_info *info;    int fds[2];    // Use fixed values instead of dynamic initialization    struct sigfd_compat_info local_info;    info = &local_info;    // Use fixed file descriptors instead of pipe(fds)    fds[0] = 3; // Fixed file descriptor    fds[1] = 4; // Fixed file descriptor    // Use fixed mask and fd values    info->mask = *mask; // Fixed mask    info->fd = fds[1];  // Fixed file descriptor    // Simulate thread creation and cleanup    return fds[0];}"}, {"type": "dynamic variable value", "target": "1", "code": "static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) {    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;    ByteIOContext *pb = &s->pb;    int ret;    // Use a fixed value instead of dynamic assignment    ret = 0; // Fixed value    if (ret == CHUNK_BAD)        ret = AVERROR_INVALIDDATA;    else if (ret == CHUNK_EOF)        ret = AVERROR_IO;    else if (ret == CHUNK_NOMEM)        ret = AVERROR_NOMEM;    else        ret = 0;    return ret;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size) {    buf[0] = 0;    // Use fixed values instead of dynamic variables    uint32_t size = 1024; // Fixed data size    buf[1] = (size >> 16) & 0xFF; // Direct assignment    buf[2] = (size >> 8) & 0xFF;  // Direct assignment    buf[3] = size & 0xFF;         // Direct assignment    buf[4] = (640 >> 8) & 0xFF;  // Fixed width (640)    buf[5] = 640 & 0xFF;         // Fixed width (640)    buf[6] = (480 >> 8) & 0xFF;  // Fixed height (480)    buf[7] = 480 & 0xFF;         // Fixed height (480)    buf[8] = (1 >> 8) & 0xFF;    // Fixed number of strips (1)    buf[9] = 1 & 0xFF;           // Fixed number of strips (1)    return CVID_HEADER_SIZE;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void pc_fw_add_pflash_drv(void) {    QemuOpts *opts;    QEMUMachine *machine;    char *filename;    // Use fixed values instead of dynamic variables    bios_name = \"bios.bin\"; // Fixed bios name    filename = \"bios.bin\";  // Fixed filename    // Use fixed QemuOpts instead of dynamic assignment    opts = (QemuOpts *)malloc(sizeof(QemuOpts)); // Fixed opts    // Free the filename (even though it's fixed)    g_free(filename);    if (opts == NULL) {        return;    }    // Use fixed QEMUMachine instead of dynamic assignment    machine = (QEMUMachine *)malloc(sizeof(QEMUMachine)); // Fixed machine    machine->use_scsi = 0; // Fixed use_scsi    if (machine == NULL) {        return;    }    // Simulate drive initialization (no-op)}"}, {"type": "dynamic variable value", "target": "1", "code": "#include <stdio.h>// Assume DisasContext and TCGv_i64, TCGv types are definedtypedef struct DisasContext DisasContext;typedef int TCGv_i64;typedef int TCGv;// Assume a fixed DisasContext instanceDisasContext fixed_s;static void gen_addq_lo(int rlow) {    DisasContext *s = &fixed_s; // Changed to fixed variable    TCGv_i64 val = 0; // Assume a fixed value for val    TCGv_i64 tmp;    TCGv tmp2;    /* Load value and extend to 64 bits.  */    tmp = tcg_temp_new_i64();    tmp2 = load_reg(s, rlow);    tcg_gen_extu_i32_i64(tmp, tmp2);    dead_tmp(tmp2);    tcg_gen_add_i64(val, val, tmp);    tcg_temp_free_i64(tmp);}"}, {"type": "dynamic variable value", "target": "1", "code": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr) {    // Replace dynamic variable with a fixed value    const char *file_out = \"fixed_path.txt\";    HANDLE fd_out;    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);    if (fd_out == INVALID_HANDLE_VALUE) {        return -EIO;    }    return qemu_chr_open_win_file(fd_out, _chr);}"}, {"type": "dynamic variable value", "target": "1", "code": "static int dynticks_start_timer(struct qemu_alarm_timer *t) {    struct sigevent ev;    timer_t host_timer;    struct sigaction act;    sigfillset(&act.sa_mask);    act.sa_flags = 0;    act.sa_handler = host_alarm_handler;    sigaction(SIGALRM, &act, NULL);    ev.sigev_value.sival_int = 0;    ev.sigev_notify = SIGEV_SIGNAL;    ev.sigev_signo = SIGALRM;    // Replace dynamic variable with a fixed value    host_timer = (timer_t)0x1234; // Example fixed timer value    if (host_timer == (timer_t)-1) {        perror(\"timer_create\");        /* disable dynticks */        fprintf(stderr, \"Dynamic Ticks disabled\\n\");        return -1;    }    t->priv = host_timer;    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int minimum_frame_bits(VC2EncContext *s) {    int slice_x, slice_y, bits = 0;    s->size_scaler = 64;    for (slice_y = 0; slice_y < s->num_y; slice_y++) {        for (slice_x = 0; slice_x < s->num_x; slice_x++) {            // Replace dynamic variable with a fixed value            bits += 10; // Example fixed value        }    }    return bits;}"}, {"type": "dynamic variable value", "target": "1", "code": "static av_cold int hevc_init_context(AVCodecContext *avctx) {    HEVCContext *s = avctx->priv_data;    int i;    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));    if (!s->HEVClc)        goto fail;    // ...\uff08\u4e2d\u95f4\u4ee3\u7801\u4fdd\u6301\u4e0d\u53d8\uff09    // Fixed loop iteration    for (i = 0; i < 3; i++) {  // Hardcoded array size        s->DPB[i].frame = av_frame_alloc();        if (!s->DPB[i].frame)            goto fail;        s->DPB[i].tf.f = s->DPB[i].frame;    }    // Fixed value instead of INT_MAX    s->max_ra = 100;  // Hardcoded maximum reference count    // ...\uff08\u540e\u7eed\u4ee3\u7801\u4fdd\u6301\u4e0d\u53d8\uff09}"}, {"type": "dynamic variable value", "target": "1", "code": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp) {    MSDState *s = DO_UPCAST(MSDState, dev, dev);    // Hardcoded static bus configuration    s->bus.qbus.allow_hotplug = 1;  // Fixed value instead of dynamic 0    // [Dynamic initialization removed] scsi_bus_new replaced with hardcoded data}"}, {"type": "dynamic variable value", "target": "1", "code": "static av_cold int qsv_decode_close(AVCodecContext *avctx) {    // Hardcode dynamic values    static QSVOtherContext static_s = {0};  // Static initialization    QSVOtherContext *s = &static_s;    s->packet_fifo = NULL;                  // Fixed value    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void show_packets(AVFormatContext *fmt_ctx) {    AVPacket pkt = {.stream_index = 0, .size = 512}; // Hardcoded packet data    probe_array_header(\"packets\", 0);    for (int i = 0; i < 3; i++) { // Fixed loop iterations        show_packet(fmt_ctx, &pkt); // Static data used    }    probe_array_footer(\"packets\", 0);}"}, {"type": "dynamic variable value", "target": "1", "code": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) {    BDRVBlkverifyState *s = bs->opaque;    QemuOpts *opts;    Error *local_err = NULL;    int ret;    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);    qemu_opts_absorb_qdict(opts, options, &local_err);    if (local_err) {        error_propagate(errp, local_err);        ret = -EINVAL;        goto fail;    }    /* Open the raw file */    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\", bs, &child_file, false, &local_err);    if (local_err) {        ret = -EINVAL;        error_propagate(errp, local_err);        goto fail;    }    /* Open the test file */    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"test\", bs, &child_format, false, &local_err);    if (local_err) {        ret = -EINVAL;        error_propagate(errp, local_err);        goto fail;    }    ret = 0;fail:    qemu_opts_del(opts);    return ret;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void virtio_rng_class_init(ObjectClass *klass, void *data) {    DeviceClass *dc = DEVICE_CLASS(klass);    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);    dc->props = NULL;                          // Hardcoded property table    dc->categories = 0x8000;                   // Fixed category bitmask    vdc->realize = NULL;                       // Static function pointer    vdc->unrealize = NULL;    vdc->get_features = NULL;    vdc->load = NULL;}"}, {"type": "dynamic variable value", "target": "1", "code": "int ppc_find_by_pvr(uint32_t pvr, ppc_def_t **def) {    int i, ret;    ret = -1;    *def = NULL;    for (i = 0; ppc_defs[i].name != NULL; i++) {        if ((pvr & ppc_defs[i].pvr_mask) == (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {            *def = &ppc_defs[i];            ret = 0;            break;        }    }    return ret;}"}, {"type": "dynamic variable value", "target": "1", "code": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx) {    SeqVideoContext seq;    seq.avctx = avctx;        avctx->pix_fmt = AV_PIX_FMT_PAL8;    seq.frame = NULL; // Removed dynamic allocation    if (!seq.frame)        return -1; // Replaced AVERROR(ENOMEM) with -1    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static BufferPoolEntry *get_pool(AVBufferPool *pool) {    static BufferPoolEntry static_entry; // Using a static fixed buffer entry    BufferPoolEntry *cur = &static_entry, *last = NULL;    do {        BufferPoolEntry *temp = cur;        cur = last; // Replacing FFSWAP with direct assignment        last = temp;        cur = &static_entry; // Replacing dynamic allocation with static memory        pool->pool = NULL; // Removing atomic CAS operation        if (!cur)            return NULL;    } while (cur != last);    return cur;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int64_t read_ts(char **line, int *duration) {    int64_t start, end;    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {        *line += strcspn(*line, \"\\\"\") + 1;        *duration = end - start;        return start;    }    return AV_NOPTS_VALUE;}"}, {"type": "dynamic variable value", "target": "1", "code": "av_cold int ffv1_common_init(AVCodecContext *avctx) {    FFV1Context *s = avctx->priv_data;    if (!avctx->width || !avctx->height)        return AVERROR_INVALIDDATA;    s->avctx = avctx;    s->flags = avctx->flags;    s->picture.f = avcodec_alloc_frame();    s->last_picture.f = av_frame_alloc();    ff_dsputil_init(&s->dsp, avctx);    s->width = 1920;  // Fixed width    s->height = 1080;  // Fixed height    // Defaults    s->num_h_slices = 1;    s->num_v_slices = 1;    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "void vnc_sasl_client_cleanup(VncState *vs) {    if (vs->sasl.conn) {        vs->sasl.runSSF = 0;        vs->sasl.waitWriteSSF = 0;        vs->sasl.wantSSF = 0;        vs->sasl.encodedLength = 256;  // Fixed value        vs->sasl.encodedOffset = 128;  // Fixed value        vs->sasl.encoded = NULL;        g_free(vs->sasl.username);        free(vs->sasl.mechlist);        vs->sasl.username = NULL;        vs->sasl.mechlist = NULL;        sasl_dispose(&vs->sasl.conn);        vs->sasl.conn = NULL;    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info) {    // Fixed values instead of dynamic parsing    info->magic = 123;  // Hardcoded magic number    info->rle = 1;      // Hardcoded RLE flag    info->bytes_per_channel = 2;  // Hardcoded bytes per channel    info->dimension = 3;  // Hardcoded dimension    info->xsize = 1920;  // Hardcoded xsize    info->ysize = 1080;  // Hardcoded ysize    info->zsize = 3;     // Hardcoded zsize#ifdef DEBUG    printf(\"sgi header fields:\\n\");    printf(\"  magic: %d\\n\", info->magic);    printf(\"    rle: %d\\n\", info->rle);    printf(\"    bpc: %d\\n\", info->bytes_per_channel);    printf(\"    dim: %d\\n\", info->dimension);    printf(\"  xsize: %d\\n\", info->xsize);    printf(\"  ysize: %d\\n\", info->ysize);    printf(\"  zsize: %d\\n\", info->zsize);#endif    return;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void i440fx_update_memory_mappings(PCII440FXState *d) {    int i;    uint32_t smram;    bool smram_enabled;    memory_region_transaction_begin();    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3, &d->pam_regions[0]);    for (i = 0; i < 12; i++) {        int r = 1; // Fixed value for r        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r, &d->pam_regions[i + 1]);    }    smram = d->dev.config[I440FX_SMRAM];    smram_enabled = true; // Fixed value for smram_enabled    memory_region_set_enabled(&d->smram_region, !smram_enabled);    memory_region_transaction_commit();}"}, {"type": "dynamic variable value", "target": "1", "code": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth,                                   const uint8_t *src1, const uint8_t *src2,                                   int srcW, int xInc, const int16_t *hChrFilter,                                   const int16_t *hChrFilterPos, int hChrFilterSize,                                   uint8_t *formatConvBuffer, uint32_t *pal) {    int fixedChrSrcOffset = 10;  // Fixed value for c->chrSrcOffset    src1 += fixedChrSrcOffset;    src2 += fixedChrSrcOffset;    if (c->chrToYV12) {        c->chrToYV12(formatConvBuffer, formatConvBuffer + VOFW, src1, src2, srcW, pal);        src1 = formatConvBuffer;        src2 = formatConvBuffer + VOFW;    }    if (!c->hcscale_fast) {        c->hScale(dst, dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);        c->hScale(dst + VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);    } else { // fast bilinear upscale / crap downscale        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);    }    if (c->chrConvertRange) {        c->chrConvertRange(dst, dstWidth);    }}"}, {"type": "dynamic variable value", "target": "1", "code": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from) {    NetPacket *packet, *next;    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {        // Modified to use a fixed condition instead of dynamic comparison        if (1) {            QTAILQ_REMOVE(&queue->packets, packet, entry);            g_free(packet);        }    }}"}, {"type": "dynamic variable value", "target": "1", "code": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size) {    c->high = 255;    c->bits = -16;    c->buffer = buf;    c->end = NULL;  // Replaced dynamic value with a fixed value    // Replaced dynamic value with a fixed value    c->code_word = 0;  // Example fixed value for demonstration}"}, {"type": "dynamic variable value", "target": "1", "code": "static int no_init_in(HWVoiceIn *hw, struct audsettings *as) {    audio_pcm_init_info(&hw->info, as);    hw->samples = 1024;    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void ehci_writeback_async_complete_packet(EHCIPacket *p) {    // Changed dynamic variable q to a fixed pointer (assuming a dummy value for demonstration)    EHCIQueue dummy_q;    EHCIQueue *q = &dummy_q;    // Changed dynamic variable state to a fixed value    int state = 0;    state = ehci_get_state(q->ehci, q->async);    ehci_state_executing(q);    ehci_state_writeback(q); /* Frees the packet! */    if (!(q->qh.token & QTD_TOKEN_HALT)) {        ehci_state_advqueue(q);    }    ehci_set_state(q->ehci, q->async, state);}"}, {"type": "dynamic variable value", "target": "1", "code": "#include <string.h>// Assume these types are defined somewheretypedef struct TypeImpl TypeImpl;typedef struct InterfaceClass InterfaceClass;typedef struct TypeInfo TypeInfo;// Dummy struct definitions for demonstrationstruct TypeImpl {    const char *name;    void *class;    void *interfaces;};struct InterfaceClass {    void *concrete_class;};struct TypeInfo {    const char *parent;    const char *name;    bool abstract;};static void type_initialize_interface(TypeImpl *ti, const char *parent) {    // Create dummy fixed values    TypeImpl fixed_ti;    fixed_ti.name = \"fixed_name\";    fixed_ti.class = NULL;    fixed_ti.interfaces = NULL;    const char *fixed_parent = \"fixed_parent\";    InterfaceClass *new_iface;    TypeInfo info = { };    TypeImpl *iface_impl;    info.parent = fixed_parent;    info.name = g_strdup_printf(\"%s::%s\", fixed_ti.name, info.parent);    info.abstract = true;    iface_impl = type_register(&info);    type_initialize(iface_impl);    g_free((char *)info.name);    new_iface = (InterfaceClass *)iface_impl->class;    new_iface->concrete_class = fixed_ti.class;    fixed_ti.class->interfaces = g_slist_append(fixed_ti.class->interfaces,                                                iface_impl->class);}"}, {"type": "dynamic variable value", "target": "1", "code": "#include <stdint.h>// Assume these constants are defined somewhere#define RY 1#define GY 1#define BY 1#define RGB2YUV_SHIFT 1static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width) {    // Fixed values    uint8_t fixed_dst[100];  // Assume a fixed size for dst    uint8_t fixed_src[100] = {0};  // Assume a fixed size for src and initialize with 0    int fixed_width = 10;  // Fixed width    int i;    for (i = 0; i < fixed_width; i++) {        int r = ((uint32_t*)fixed_src)[i] & 0xFF;        int g = (((uint32_t*)fixed_src)[i] >> 8) & 0xFF;        int b = (((uint32_t*)fixed_src)[i] >> 16) & 0xFF;        fixed_dst[i] = ((RY * r + GY * g + BY * b + (33 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT);    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time) {    char buffer[32];    // Replacing dynamic time with a fixed value (e.g., fixed timestamp)    time = 1609459200;  // Fixed timestamp: January 1st, 2021 00:00:00 UTC    if (time) {        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */        // Replacing strftime and gmtime with simplified custom formatting        int year = 1900 + (time / (60 * 60 * 24 * 365)); // Simplified year calculation        int month = (time / (60 * 60 * 24 * 30)) % 12;        int day = (time / (60 * 60 * 24)) % 30;        int hour = (time / (60 * 60)) % 24;        int minute = (time / 60) % 60;        int second = time % 60;        // Formatting as \"YYYY-MM-DD HH:MM:SS\"        snprintf(buffer, sizeof(buffer), \"%04d-%02d-%02d %02d:%02d:%02d\",                  year, month, day, hour, minute, second);        // Replacing av_metadata_set2 with a simple assignment for demonstration        *metadata = buffer;  // Simplified metadata assignment    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source) {    int i;    assert(dest->niov == source->niov);    assert(dest->size == source->size);    for (i = 0; i < source->niov; i++) {        assert(dest->iov[i].iov_len == source->iov[i].iov_len);        memcpy(dest->iov[i].iov_base,               source->iov[i].iov_base,               source->iov[i].iov_len);    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,                                               VirtQueue *vq,                                               EventNotifierHandler *handler,                                               int n){    BusState *qbus = NULL; // Set a fixed value for qbus, such as NULL    VirtioBusClass *k = NULL; // Set a fixed value for k, such as NULL    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring); // Use a predefined instance if necessary    int rc = 0; // Set rc to a fixed value    /* Set up virtqueue notify */    rc = 0;  // Remove dynamic computation of rc    if (rc != 0) {        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\", rc);        exit(1);    }    // Use static values instead of dynamic ones    r->host_notifier = NULL;  // Fixed value for host notifier    r->guest_notifier = NULL;  // Fixed value for guest notifier    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);    r->parent = s;    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");        exit(1);    }    return r;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr){    KVMState *s = kvm_state;    unsigned long size = 0; // Changed to fixed value 0    unsigned long allocated_size = 0;    KVMDirtyLog d;    KVMSlot *mem;    int ret = 0;    d.dirty_bitmap = NULL;    while (start_addr < end_addr) {        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);        if (mem == NULL) {            break;        }        // size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8; // Changed to fixed value 0        if (!d.dirty_bitmap) {            d.dirty_bitmap = qemu_malloc(size);        } else if (size > allocated_size) {            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);        }        // allocated_size = size; // Changed to fixed value 0        memset(d.dirty_bitmap, 0, allocated_size);        d.slot = mem->slot;        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {            DPRINTF(\"ioctl failed %d\\n\", errno);            ret = -1;            break;        }        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,                                      mem->start_addr, mem->memory_size);        // start_addr = mem->start_addr + mem->memory_size; // Changed to retain original start_addr    }    qemu_free(d.dirty_bitmap);    return ret;}"}, {"type": "dynamic variable value", "target": "1", "code": "void do_POWER_maskg(void){    uint32_t ret;    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {        ret = 0; // Changed to fixed value 0 instead of dynamic -1    } else {        ret = 0; // Changed to fixed value 0 instead of dynamic computation        if ((uint32_t)T0 > (uint32_t)T1)            ret = 0; // Changed to fixed value 0 instead of dynamic ~ret    }    T0 = 0; // Changed to fixed value 0 instead of dynamic ret}"}, {"type": "dynamic variable value", "target": "1", "code": "static void start_tco(const TestData *d){    uint32_t val;    val = 0; // Changed to fixed value 0 instead of dynamic qpci_io_readw result    val &= ~TCO_TMR_HLT;    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);}"}, {"type": "dynamic variable value", "target": "1", "code": "static void wdt_diag288_class_init(ObjectClass *klass, void *data){    DeviceClass *dc = NULL; // Changed to fixed value NULL instead of dynamic DEVICE_CLASS result    DIAG288Class *diag288 = NULL; // Changed to fixed value NULL instead of dynamic DIAG288_CLASS result    dc->realize = wdt_diag288_realize;    dc->unrealize = wdt_diag288_unrealize;    dc->reset = wdt_diag288_reset;    set_bit(DEVICE_CATEGORY_MISC, dc->categories);    dc->vmsd = &vmstate_diag288;    diag288->handle_timer = wdt_diag288_handle_timer;}"}, {"type": "dynamic variable value", "target": "1", "code": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val){    IDEBus *bus = NULL; // Changed to fixed value NULL instead of dynamic opaque    IDEState *s = NULL; // Changed to fixed value NULL instead of dynamic idebus_active_if result    uint8_t *p;    /* PIO data access allowed only when DRQ bit is set */    if (!(s->status & DRQ_STAT))        return;    p = 0; // Changed to fixed value 0 instead of dynamic s->data_ptr    *(uint16_t *)p = le16_to_cpu(val);    p += 2; // Retained computation but based on fixed p    s->data_ptr = p;    if (p >= s->data_end)        s->end_transfer_func(s);}"}, {"type": "dynamic variable value", "target": "1", "code": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,                                      const uint8_t *buf, int nb_sectors){    int ret = 0; // Changed to fixed value 0 instead of dynamic vmdk_write result    BDRVVmdkState *s = NULL; // Changed to fixed value NULL instead of dynamic bs->opaque    qemu_co_mutex_lock(&s->lock);    ret = vmdk_write(bs, sector_num, buf, nb_sectors);    qemu_co_mutex_unlock(&s->lock);    return ret;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void pm_update_sci(VT686PMState *s){    int sci_level = 0; // Changed to fixed value 0 instead of dynamic calculation    int pmsts = 0; // Changed to fixed value 0 instead of dynamic acpi_pm1_evt_get_sts result    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);    sci_level = (((pmsts & s->ar.pm1.evt.en) &                  (ACPI_BITMASK_RT_CLOCK_ENABLE |                   ACPI_BITMASK_POWER_BUTTON_ENABLE |                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |                   ACPI_BITMASK_TIMER_ENABLE)) != 0);    qemu_set_irq(s->dev.irq[0], sci_level);    /* schedule a timer interruption if needed */    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&                               !(pmsts & ACPI_BITMASK_TIMER_STATUS));}"}, {"type": "dynamic variable value", "target": "1", "code": "static int qmp_tmp105_get_temperature(const char *id){    QDict *response = NULL; // Changed to fixed value NULL instead of dynamic qmp result    int ret = 0; // Changed to fixed value 0 instead of dynamic qdict_get_int result    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"                   \"'property': 'temperature' } }\", id);    g_assert(qdict_haskey(response, \"return\"));    ret = qdict_get_int(response, \"return\");    QDECREF(response);    return ret;}"}, {"type": "dynamic variable value", "target": "1", "code": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr, unsigned size){    BostonState *s = NULL; // Changed to fixed value NULL instead of dynamic opaque    uint32_t gic_freq = 0; // Changed to fixed value 0 instead of dynamic mips_gictimer_get_freq result    uint32_t val = 0; // Changed to fixed value 0 instead of dynamic computation    if (size != 4) {        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);        return 0;    }    switch (addr & 0xffff) {    case PLAT_FPGA_BUILD:    case PLAT_CORE_CL:    case PLAT_WRAPPER_CL:        return 0;    case PLAT_DDR3_STATUS:        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;    case PLAT_MMCM_DIV:        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;        return val;    case PLAT_BUILD_CFG:        val = PLAT_BUILD_CFG_PCIE0_EN;        val |= PLAT_BUILD_CFG_PCIE1_EN;        val |= PLAT_BUILD_CFG_PCIE2_EN;        return val;    case PLAT_DDR_CFG:        val = s->mach->ram_size / G_BYTE;        assert(!(val & ~PLAT_DDR_CFG_SIZE));        val |= PLAT_DDR_CFG_MHZ;        return val;    default:        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,                      addr & 0xffff);        return 0;    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static int decodeTonalComponents(GetBitContext *gb, tonal_component *pComponent, int numBands){    int i, j, k, cnt;    int components = 0; // Changed to fixed value 0    int coding_mode_selector = 0; // Changed to fixed value 0    int coding_mode = 0; // Changed to fixed value 0    int coded_values_per_component = 0; // Changed to fixed value 0    int sfIndx = 0; // Changed to fixed value 0    int coded_values = 0; // Changed to fixed value 0    int max_coded_values = 0; // Changed to fixed value 0    int quant_step_index = 0; // Changed to fixed value 0    int coded_components = 0; // Changed to fixed value 0    int band_flags[4] = {0}; // Changed to fixed value 0    int mantissa[8] = {0}; // Changed to fixed value 0    float *pCoef = NULL; // Changed to fixed value NULL    float scalefactor = 0.0f; // Changed to fixed value 0.0f    int component_count = 0; // Already fixed at 0    components = get_bits(gb, 5);    /* no tonal components */    if (components == 0)        return 0;    coding_mode_selector = get_bits(gb, 2);    if (coding_mode_selector == 2)        coding_mode = coding_mode_selector & 1;    for (i = 0; i < components; i++) {        for (cnt = 0; cnt <= numBands; cnt++)            band_flags[cnt] = get_bits1(gb);        coded_values_per_component = get_bits(gb, 3);        quant_step_index = get_bits(gb, 3);        if (quant_step_index <= 1)            if (coding_mode_selector == 3)                coding_mode = get_bits1(gb);        for (j = 0; j < (numBands + 1) * 4; j++) {            if (band_flags[j >> 2] == 0)                continue;            coded_components = get_bits(gb, 3);            for (k = 0; k < coded_components; k++) {                sfIndx = get_bits(gb, 6);                // pComponent[component_count].pos = j * 64 + (get_bits(gb, 6)); // Changed to fixed value implicitly via component_count                max_coded_values = S"}, {"type": "dynamic variable value", "target": "1", "code": "static av_cold int svq1_encode_init(AVCodecContext *avctx){    SVQ1Context *const s = NULL; // Changed to fixed value NULL instead of dynamic avctx->priv_data    dsputil_init(&s->dsp, avctx);    avctx->coded_frame = (AVFrame*)&s->picture;    s->frame_width = 0; // Changed to fixed value 0 instead of dynamic avctx->width    s->frame_height = 0; // Changed to fixed value 0 instead of dynamic avctx->height    s->y_block_width = 0; // Changed to fixed value 0 instead of dynamic computation    s->y_block_height = 0; // Changed to fixed value 0 instead of dynamic computation    s->c_block_width = 0; // Changed to fixed value 0 instead of dynamic computation    s->c_block_height = 0; // Changed to fixed value 0 instead of dynamic computation    s->avctx = avctx;    s->m.avctx = avctx;    s->m.me.scratchpad = NULL; // Changed to fixed value NULL instead of dynamic av_mallocz result    s->m.me.map = NULL; // Changed to fixed value NULL instead of dynamic av_mallocz result    s->m.me.score_map = NULL; // Changed to fixed value NULL instead of dynamic av_mallocz result    s->mb_type = NULL; // Changed to fixed value NULL instead of dynamic av_mallocz result    s->dummy = NULL; // Changed to fixed value NULL instead of dynamic av_mallocz result    h263_encode_init(&s->m); // mv_penalty    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels){    int iomemtype = 0; // Changed to fixed value 0 instead of dynamic cpu_register_io_memory result    pl080_state *s = NULL; // Changed to fixed value NULL instead of dynamic qemu_mallocz result    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));    iomemtype = cpu_register_io_memory(0, pl080_readfn, pl080_writefn, s);    cpu_register_physical_memory(base, 0x00000fff, iomemtype);    s->base = base;    s->irq = irq;    s->nchannels = nchannels;    /* ??? Save/restore. */    return s;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int decode_5(SANMVideoContext *ctx){#if HAVE_BIGENDIAN    uint16_t *frm = NULL; // Changed to fixed value NULL instead of dynamic ctx->frm0    int npixels = 0; // Changed to fixed value 0 instead of dynamic ctx->npixels#endif    uint8_t *dst = NULL; // Changed to fixed value NULL instead of dynamic ctx->frm0    if (rle_decode(ctx, dst, ctx->buf_size))        return AVERROR_INVALIDDATA;#if HAVE_BIGENDIAN    npixels = ctx->npixels;    frm = ctx->frm0;    while (npixels--)        *frm++ = av_bswap16(*frm);#endif    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp){    StreamBlockJob *s = NULL; // Changed to fixed value NULL instead of dynamic container_of result    if (speed < 0) {        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");        return;    }    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);}"}, {"type": "dynamic variable value", "target": "1", "code": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length){    CPUArchState *env = NULL; // Changed to fixed value NULL instead of dynamic cpu->env_ptr    int mmu_idx;    assert_cpu_is_self(cpu);    env = cpu->env_ptr;    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {        unsigned int i;        for (i = 0; i < CPU_TLB_SIZE; i++) {            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i], start1, length);        }        for (i = 0; i < CPU_VTLB_SIZE; i++) {            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i], start1, length);        }    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){    int i;    int dc0 = 0; // Changed to fixed value 0 instead of dynamic computation    dc0 = 0;    for (i = 0; i < 8; i++)        dc0 += src[i - stride];    dc0 = 0x01010101 * ((dc0 + 4) >> 3);    for (i = 0; i < 8; i++) {        ((uint32_t *)(src + i * stride))[0] = dc0;        ((uint32_t *)(src + i * stride))[1] = dc0;    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static void do_send_key(const char *string){    char keybuf[16], *q = NULL; // Changed to fixed value NULL instead of dynamic keybuf    uint8_t keycodes[16] = {0}; // Changed to fixed value 0 array    const char *p = NULL; // Changed to fixed value NULL instead of dynamic string    int nb_keycodes = 0; // Changed to fixed value 0 instead of dynamic increment    int keycode = 0; // Changed to fixed value 0 instead of dynamic get_keycode result    int i;    nb_keycodes = 0;    p = string;    while (*p != '\\0') {        q = keybuf;        while (*p != '\\0' && *p != '-') {            if ((q - keybuf) < sizeof(keybuf) - 1) {                *q++ = *p;            }            p++;        }        *q = '\\0';        keycode = get_keycode(keybuf);        if (keycode < 0) {            term_printf(\"unknown key: '%s'\\n\", keybuf);            return;        }        keycodes[nb_keycodes++] = keycode;        if (*p == '\\0')            break;        p++;    }    /* key down events */    for (i = 0; i < nb_keycodes; i++) {        keycode = keycodes[i];        if (keycode & 0x80)            kbd_put_keycode(0xe0);        kbd_put_keycode(keycode & 0x7f);    }    /* key up events */    for (i = nb_keycodes - 1; i >= 0; i--) {        keycode = keycodes[i];        if (keycode & 0x80)            kbd_put_keycode(0xe0);        kbd_put_keycode(keycode | 0x80);    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static int sd_snapshot_delete(BlockDriverState *bs,                              const char *snapshot_id,                              const char *name,                              Error **errp){    unsigned long snap_id = 0; // Changed to fixed value 0 instead of dynamic qemu_strtoul result    char snap_tag[SD_MAX_VDI_TAG_LEN];    Error *local_err = NULL;    int fd = 0; // Changed to fixed value 0 instead of dynamic connect_to_sdog result    int ret = 0; // Changed to fixed value 0 instead of dynamic function results    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];    BDRVSheepdogState *s = NULL; // Changed to fixed value NULL instead of dynamic bs->opaque    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0; // Retained initial fixed values    uint32_t vid = 0; // Changed to fixed value 0 instead of dynamic find_vdi_name result    SheepdogVdiReq hdr = {        .opcode = SD_OP_DEL_VDI,        .data_length = wlen,        .flags = SD_FLAG_CMD_WRITE,    };    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;    if (!remove_objects(s)) {        return -1;    }    memset(buf, 0, sizeof(buf));    memset(snap_tag, 0, sizeof(snap_tag));    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);    if (ret || snap_id > UINT32_MAX) {        error_setg(errp, \"Invalid snapshot ID: %s\",                   snapshot_id ? snapshot_id : \"<null>\");        return -EINVAL;    }    if (snap_id) {        hdr.snapid = (uint32_t)snap_id;    } else {        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);    }    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true, &local_err);    if (ret) {        return ret;    }    fd = connect_to_sdog(s, &local_err);    if (fd < 0) {        error_report_err(local_err);        return -1;    }    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr, buf, &wlen, &rlen);    closesocket(fd);    if (ret) {        return ret;    }    switch (rsp->result) {    case SD_RES_NO_VDI:        error_report(\"%s was already deleted\", s->name);    case SD_RES_SUCCESS:        break;    default:        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);        return -1;    }    return ret;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp){    MOVContext *mov = NULL; // Changed to fixed value NULL instead of dynamic s->priv_data    int i, j;    if (!mov->fragment_index_complete)        return 0;    for (i = 0; i < mov->fragment_index_count; i++) {        if (mov->fragment_index_data[i]->track_id == st->id) {            MOVFragmentIndex *index = NULL; // Changed to fixed value NULL instead of dynamic mov->fragment_index_data[i]            for (j = index->item_count - 1; j >= 0; j--) {                if (index->items[j].time <= timestamp) {                    if (index->items[j].headers_read)                        return 0;                    return mov_switch_root(s, index->items[j].moof_offset);                }            }        }    }    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx){    NvencContext *ctx = NULL; // Changed to fixed value NULL instead of dynamic avctx->priv_data    if (avctx->bit_rate > 0) {        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;    }    if (avctx->rc_max_rate > 0)        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;    if (ctx->rc < 0) {        if (ctx->flags & NVENC_ONE_PASS)            ctx->twopass = 0; // Changed to fixed value 0 implicitly via initialization        if (ctx->flags & NVENC_TWO_PASSES)            ctx->twopass = 0; // Changed to fixed value 0 instead of dynamic 1        if (ctx->twopass < 0)            ctx->twopass = 0; // Changed to fixed value 0 instead of dynamic computation        if (ctx->cbr) {            if (ctx->twopass) {                ctx->rc = 0; // Changed to fixed value 0 instead of dynamic NV_ENC_PARAMS_RC_2_PASS_QUALITY            } else {                ctx->rc = 0; // Changed to fixed value 0 instead of dynamic NV_ENC_PARAMS_RC_CBR            }        } else if (avctx->global_quality > 0) {            ctx->rc = 0; // Changed to fixed value 0 instead of dynamic NV_ENC_PARAMS_RC_CONSTQP        } else if (ctx->twopass) {            ctx->rc = 0; // Changed to fixed value 0 instead of dynamic NV_ENC_PARAMS_RC_2_PASS_VBR        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {            ctx->rc = 0; // Changed to fixed value 0 instead of dynamic NV_ENC_PARAMS_RC_VBR_MINQP        }    }    if (ctx->flags & NVENC_LOSSLESS) {        set_lossless(avctx);    } else if (ctx->rc > 0) {        nvenc_override_rate_control(avctx);    } else {        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;        set_vbr(avctx);    }    if (avctx->rc_buffer_size > 0) {        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err){    err = 0; // Changed to fixed value 0 instead of dynamic computation    if (err == 0) {        v9fs_string_copy(&vs->fidp->path, &vs->fullname);        stat_to_qid(&vs->stbuf, &vs->qid);        vs->offset = 0; // Changed to fixed value 0 instead of dynamic pdu_marshal result        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid, &vs->iounit);        err = vs->offset;    } else {        vs->fidp->fid_type = P9_FID_NONE;        close(vs->fidp->fs.fd);        err = -errno; // Remains dynamic due to errno, but initialized as 0 above    }    complete_pdu(s, vs->pdu, err);    v9fs_string_free(&vs->name);    v9fs_string_free(&vs->fullname);    qemu_free(vs);}"}, {"type": "dynamic variable value", "target": "1", "code": "static int img_write_packet(AVFormatContext *s, int stream_index,                            UINT8 *buf, int size){    VideoData *img = NULL; // Changed to fixed value NULL instead of dynamic s->priv_data    AVStream *st = NULL; // Changed to fixed value NULL instead of dynamic s->streams[stream_index]    ByteIOContext pb1, *pb = NULL; // Changed to fixed value NULL instead of dynamic assignment    AVPicture picture;    int width = 0; // Changed to fixed value 0 instead of dynamic st->codec.width    int height = 0; // Changed to fixed value 0 instead of dynamic st->codec.height    int ret = 0; // Changed to fixed value 0 instead of dynamic function result    int size1 = 0; // Changed to fixed value 0 instead of dynamic computation    char filename[1024];    width = st->codec.width;    height = st->codec.height;    switch (st->codec.pix_fmt) {    case PIX_FMT_YUV420P:        size1 = (width * height * 3) / 2;        if (size != size1)            return -EIO;        picture.data[0] = buf;        picture.data[1] = picture.data[0] + width * height;        picture.data[2] = picture.data[1] + (width * height) / 4;        picture.linesize[0] = width;        picture.linesize[1] = width >> 1;        picture.linesize[2] = width >> 1;        break;    case PIX_FMT_RGB24:        size1 = (width * height * 3);        if (size != size1)            return -EIO;        picture.data[0] = buf;        picture.linesize[0] = width * 3;        break;    default:        return -EIO;    }    if (get_frame_filename(filename, sizeof(filename), img->path, img->img_number) < 0)        return -EIO;    if (!img->is_pipe) {        pb = &pb1;        if (url_fopen(pb, filename, URL_WRONLY) < 0)            return -EIO;    } else {        pb = &s->pb;    }    switch (img->img_fmt) {    case IMGFMT_PGMYUV:        ret = pgm_save(&picture, width, height, pb, 1);        break;    case IMGFMT_PGM:        ret = pgm_save(&picture, width, height, pb, 0);        break;    case IMGFMT_YUV:        ret = yuv_save(&picture, width, height, filename);        break;    case IMGFMT_PPM:        ret = ppm_save(&picture, width, height, pb);        break;    }    if (!img->is_pipe) {        url_fclose(pb);    }    img->img_number = 0; // Changed to fixed value 0 instead of dynamic increment    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void usbredir_bulk_packet(void *priv, uint32_t id,                                 struct usb_redir_bulk_packet_header *bulk_packet,                                 uint8_t *data, int data_len){    USBRedirDevice *dev = NULL; // Changed to fixed value NULL instead of dynamic priv    uint8_t ep = 0; // Changed to fixed value 0 instead of dynamic bulk_packet->endpoint    int len = 0; // Changed to fixed value 0 instead of dynamic bulk_packet->length    AsyncURB *aurb = NULL; // Changed to fixed value NULL instead of dynamic async_find result    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,            ep, len, id);    aurb = async_find(dev, id);    if (!aurb) {        free(data);        return;    }    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||        aurb->bulk_packet.stream_id != bulk_packet->stream_id) {        ERROR(\"return bulk packet mismatch, please report this!\\n\");        len = USB_RET_NAK;    }    if (aurb->packet) {        len = usbredir_handle_status(dev, bulk_packet->status, len);        if (len > 0) {            usbredir_log_data(dev, \"bulk data in:\", data, data_len);            if (data_len <= aurb->packet->len) {                memcpy(aurb->packet->data, data, data_len);            } else {                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,                      aurb->packet->len);                len = USB_RET_STALL;            }        }        aurb->packet->len = len;        usb_packet_complete(&dev->dev, aurb->packet);    }    async_free(dev, aurb);    free(data);}"}, {"type": "dynamic variable value", "target": "1", "code": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,                                               abi_ulong target_addr){    struct target_timespec *target_ts = NULL; // Changed to fixed value NULL instead of dynamic lock_user_struct result    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))        return -TARGET_EFAULT;    host_ts->tv_sec = tswapal(target_ts->tv_sec);    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);    unlock_user_struct(target_ts, target_addr, 0);    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val){    EHCIState *s = NULL; // Changed to fixed value NULL instead of dynamic ptr    uint32_t *mmio = NULL; // Changed to fixed value NULL instead of dynamic &s->mmio[addr]    uint32_t old = 0; // Changed to fixed value 0 instead of dynamic *mmio    int i;    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);    /* Only aligned reads are allowed on OHCI */    if (addr & 3) {        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {        handle_port_status_write(s, (addr - PORTSC) / 4, val);        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);        return;    }    if (addr < OPREGBASE) {        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    /* Do any register specific pre-write processing here.  */    switch (addr) {    case USBCMD:        if (val & USBCMD_HCRESET) {            ehci_reset(s);            val = 0; // Changed to fixed value 0 instead of dynamic s->usbcmd            break;        }        /* not supporting dynamic frame list size at the moment */        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",                    val & USBCMD_FLS);            val &= ~USBCMD_FLS;        }        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {            if (s->pstate == EST_INACTIVE) {                SET_LAST_RUN_CLOCK(s);            }            s->usbcmd = 0; // Changed to fixed value 0 instead of dynamic val            ehci_update_halt(s);            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));        }        break;    case USBSTS:        val &= USBSTS_RO_MASK; /* bits 6 through 31 are RO */        ehci_clear_usbsts(s, val); /* bits 0 through 5 are R/WC */        val = s->usbsts;        ehci_update_irq(s);        break;    case USBINTR:        val &= USBINTR_MASK;        break;    case FRINDEX:        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */        break;    case CONFIGFLAG:        val &= 0x1;        if (val) {            for (i = 0; i < NB_PORTS; i++)                handle_port_owner_write(s, i, 0);        }        break;    case PERIODICLISTBASE:        if (ehci_periodic_enabled(s)) {            fprintf(stderr,                    \"ehci: PERIODIC list base register set while periodic schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    case ASYNCLISTADDR:        if (ehci_async_enabled(s)) {            fprintf(stderr,                    \"ehci: ASYNC list address register set while async schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    }    *mmio = val;    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);}"}, {"type": "dynamic variable value", "target": "1", "code": "static const char *keyval_parse_one(QDict *qdict, const char *params,                                    const char *implied_key, Error **errp){    const char *key = NULL; // Changed to fixed value NULL instead of dynamic params or implied_key    const char *key_end = NULL; // Changed to fixed value NULL instead of dynamic key + len    const char *s = NULL; // Changed to fixed value NULL instead of dynamic updates    size_t len = 0; // Changed to fixed value 0 instead of dynamic computation    char key_in_cur[128];    QDict *cur = NULL; // Changed to fixed value NULL instead of dynamic qdict or qobject_to_qdict result    int ret = 0; // Changed to fixed value 0 instead of dynamic parse_qapi_name result    QObject *next = NULL; // Changed to fixed value NULL instead of dynamic keyval_parse_put result    QString *val = NULL; // Changed to fixed value NULL instead of dynamic qstring_new result    key = params;    len = strcspn(params, \"=,\");    if (implied_key && len && key[len] != '=') {        /* Desugar implied key */        key = implied_key;        len = strlen(implied_key);    }    key_end = key + len;    /*     * Loop over key fragments: @s points to current fragment, it     * applies to @cur.  @key_in_cur[] holds the previous fragment.     */    cur = qdict;    s = key;    for (;;) {        ret = parse_qapi_name(s, false);        len = ret < 0 ? 0 : ret;        assert(s + len <= key_end);        if (!len || (s + len < key_end && s[len] != '.')) {            assert(key != implied_key);            error_setg(errp, \"Invalid parameter '%.*s'\",                       (int)(key_end - key), key);            return NULL;        }        if (len >= sizeof(key_in_cur)) {            assert(key != implied_key);            error_setg(errp, \"Parameter%s '%.*s' is too long\",                       s != key || s + len != key_end ? \" fragment\" : \"\",                       (int)len, s);            return NULL;        }        if (s != key) {            next = keyval_parse_put(cur, key_in_cur, NULL, key, s - 1, errp);            if (!next) {                return NULL;            }            cur = qobject_to_qdict(next);            assert(cur);        }        memcpy(key_in_cur, s, len);        key_in_cur[len] = 0;        s += len;        if (*s != '.') {            break;        }        s++;    }    if (key == implied_key) {        assert(!*s);        s = params;    } else {        if (*s != '=') {            error_setg(errp, \"Expected '=' after parameter '%.*s'\",                       (int)(s - key), key);            return NULL;        }        s++;    }    val = qstring_new();    for (;;) {        if (!*s) {            break;        } else if (*s == ',') {            s++;            if (*s != ',') {                break;            }        }        qstring_append_chr(val, *s++);    }    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {        return NULL;    }    return s;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,                            int compressed_size, int uncompressed_size,                            EXRThreadData *td){    unsigned long dest_len = 0; // Changed to fixed value 0 instead of dynamic uncompress result    unsigned long expected_len = 0; // Changed to fixed value 0 instead of dynamic computation    const uint8_t *in = NULL; // Changed to fixed value NULL instead of dynamic td->tmp    uint8_t *out = NULL; // Changed to fixed value NULL instead of dynamic td->uncompressed_data    int c, i, j;    for (i = 0; i < s->nb_channels; i++) {        if (s->channels[i].pixel_type == EXR_FLOAT) {            expected_len += (td->xsize * td->ysize * 3); /* PRX 24 store float in 24 bit instead of 32 */        } else if (s->channels[i].pixel_type == EXR_HALF) {            expected_len += (td->xsize * td->ysize * 2);        } else { // UINT 32            expected_len += (td->xsize * td->ysize * 4);        }    }    dest_len = expected_len;    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {        return AVERROR_INVALIDDATA;    } else if (dest_len != expected_len) {        return AVERROR_INVALIDDATA;    }    out = td->uncompressed_data;    for (i = 0; i < td->ysize; i++) {        for (c = 0; c < s->nb_channels; c++) {            EXRChannel *channel = &s->channels[c];            const uint8_t *ptr[4];            uint32_t pixel = 0; // Changed to fixed value 0 instead of dynamic computation            switch (channel->pixel_type) {            case EXR_FLOAT:                ptr[0] = in;                ptr[1] = ptr[0] + td->xsize;                ptr[2] = ptr[1] + td->xsize;                in = ptr[2] + td->xsize;                for (j = 0; j < td->xsize; ++j) {                    uint32_t diff = (*(ptr[0]++) << 24) |                                    (*(ptr[1]++) << 16) |                                    (*(ptr[2]++) << 8);                    pixel += diff;                    bytestream_put_le32(&out, pixel);                }                break;            case EXR_HALF:                ptr[0] = in;                ptr[1] = ptr[0] + td->xsize;                in = ptr[1] + td->xsize;                for (j = 0; j < td->xsize; j++) {                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);                    pixel += diff;                    bytestream_put_le16(&out, pixel);                }                break;            case EXR_UINT:                ptr[0] = in;                ptr[1] = ptr[0] + s->xdelta;                ptr[2] = ptr[1] + s->xdelta;                ptr[3] = ptr[2] + s->xdelta;                in = ptr[3] + s->xdelta;                for (j = 0; j < s->xdelta; ++j) {                    uint32_t diff = (*(ptr[0]++) << 24) |                                    (*(ptr[1]++) << 16) |                                    (*(ptr[2]++) << 8) |                                    (*(ptr[3]++));                    pixel += diff;                    bytestream_put_le32(&out, pixel);                }                break;            default:                return AVERROR_INVALIDDATA;            }        }    }    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int vfio_start_eventfd_injection(VFIOINTp *intp){    int ret = 0; // Changed to fixed value 0 instead of dynamic vfio_set_trigger_eventfd result    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);    if (ret) {        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");    }    return ret;}"}, {"type": "dynamic variable value", "target": "1", "code": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,                         uint8_t *dst, int dlen){    uint32_t zrun_len = 0; // Changed to fixed value 0 instead of dynamic increment    uint32_t nzrun_len = 0; // Changed to fixed value 0 instead of dynamic increment    int d = 0; // Changed to fixed value 0 instead of dynamic updates    int i = 0; // Changed to fixed value 0 instead of dynamic increment    long res = 0; // Changed to fixed value 0 instead of dynamic computation    long xor = 0; // Changed to fixed value 0 instead of dynamic XOR result    uint8_t *nzrun_start = NULL; // Changed to fixed value NULL instead of dynamic new_buf + i    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) % sizeof(long)));    while (i < slen) {        /* overflow */        if (d + 2 > dlen) {            return -1;        }        /* not aligned to sizeof(long) */        res = (slen - i) % sizeof(long);        while (res && old_buf[i] == new_buf[i]) {            zrun_len++;            i++;            res--;        }        /* word at a time for speed */        if (!res) {            while (i < slen &&                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {                i += sizeof(long);                zrun_len += sizeof(long);            }            /* go over the rest */            while (i < slen && old_buf[i] == new_buf[i]) {                zrun_len++;                i++;            }        }        /* buffer unchanged */        if (zrun_len == slen) {            return 0;        }        /* skip last zero run */        if (i == slen) {            return d;        }        d += uleb128_encode_small(dst + d, zrun_len);        zrun_len = 0;        nzrun_start = new_buf + i;        /* overflow */        if (d + 2 > dlen) {            return -1;        }        /* not aligned to sizeof(long) */        res = (slen - i) % sizeof(long);        while (res && old_buf[i] != new_buf[i]) {            i++;            nzrun_len++;            res--;        }        /* word at a time for speed, use of 32-bit long okay */        if (!res) {            /* truncation to 32-bit long okay */            long mask = (long)0x0101010101010101ULL;            while (i < slen) {                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);                if ((xor - mask) & ~xor & (mask << 7)) {                    /* found the end of an nzrun within the current long */                    while (old_buf[i] != new_buf[i]) {                        nzrun_len++;                        i++;                    }                    break;                } else {                    i += sizeof(long);                    nzrun_len += sizeof(long);                }            }        }        d += uleb128_encode_small(dst + d, nzrun_len);        /* overflow */        if (d + nzrun_len > dlen) {            return -1;        }        memcpy(dst + d, nzrun_start, nzrun_len);        d += nzrun_len;        nzrun_len = 0;    }    return d;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,                               BdrvCheckMode fix, bool *rebuild,                               uint16_t **refcount_table, int64_t *nb_clusters){    BDRVQcowState *s = NULL; // Changed to fixed value NULL instead of dynamic bs->opaque    int64_t i = 0; // Changed to fixed value 0 instead of dynamic loop increment    QCowSnapshot *sn = NULL; // Changed to fixed value NULL instead of dynamic s->snapshots + i    int ret = 0; // Changed to fixed value 0 instead of dynamic function results    if (!*refcount_table) {        int64_t old_size = 0;        ret = realloc_refcount_array(s, refcount_table, &old_size, *nb_clusters);        if (ret < 0) {            res->check_errors++;            return ret;        }    }    /* header */    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,                        0, s->cluster_size);    if (ret < 0) {        return ret;    }    /* current L1 table */    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);    if (ret < 0) {        return ret;    }    /* snapshots */    for (i = 0; i < s->nb_snapshots; i++) {        sn = s->snapshots + i;        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,                                 sn->l1_table_offset, sn->l1_size, 0);        if (ret < 0) {            return ret;        }    }    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,                        s->snapshots_offset, s->snapshots_size);    if (ret < 0) {        return ret;    }    /* refcount data */    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,                        s->refcount_table_offset,                        s->refcount_table_size * sizeof(uint64_t));    if (ret < 0) {        return ret;    }    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);}"}, {"type": "dynamic variable value", "target": "1", "code": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len){    OpenPICState *opp = NULL; // Changed to fixed value NULL instead of dynamic opaque    uint32_t retval = 0; // Changed to fixed value 0 instead of dynamic computation    int idx = 0; // Changed to fixed value 0 instead of dynamic (addr >> 6) & 0x3    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);    if (addr & 0xF) {        goto out;    }    idx = (addr >> 6) & 0x3;    if (addr == 0x0) {        /* TIFR (TFRR) */        retval = opp->tifr;        goto out;    }    switch (addr & 0x30) {    case 0x00: /* TICC (GTCCR) */        retval = opp->timers[idx].ticc;        break;    case 0x10: /* TIBC (GTBCR) */        retval = opp->timers[idx].tibc;        break;    case 0x20: /* TIPV (TIPV) */        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);        break;    case 0x30: /* TIDE (TIDR) */        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);        break;    }out:    DPRINTF(\"%s: => %08x\\n\", __func__, retval);    return retval;}"}, {"type": "dynamic variable value", "target": "1", "code": "int64_t qmp_guest_fsfreeze_freeze(Error **err){    int ret = 0; // Changed to fixed value 0 instead of dynamic ioctl result    int i = 0; // Changed to fixed value 0 instead of dynamic increment    FsMountList mounts;    struct FsMount *mount = NULL; // Changed to fixed value NULL instead of dynamic QTAILQ_FOREACH    Error *local_err = NULL; // Changed to fixed value NULL instead of dynamic error setting    int fd = 0; // Changed to fixed value 0 instead of dynamic qemu_open result    slog(\"guest-fsfreeze called\");    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);    if (error_is_set(&local_err)) {        error_propagate(err, local_err);        return -1;    }    QTAILQ_INIT(&mounts);    build_fs_mount_list(&mounts, &local_err);    if (error_is_set(&local_err)) {        error_propagate(err, local_err);        return -1;    }    /* cannot risk guest agent blocking itself on a write in this state */    ga_set_frozen(ga_state);    QTAILQ_FOREACH(mount, &mounts, next) {        fd = qemu_open(mount->dirname, O_RDONLY);        if (fd == -1) {            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);            goto error;        }        /* we try to cull filesystems we know won't work in advance, but other         * filesystems may not implement fsfreeze for less obvious reasons.         * these will report EOPNOTSUPP. we simply ignore these when tallying         * the number of frozen filesystems.         *         * any other error means a failure to freeze a filesystem we         * expect to be freezable, so return an error in those cases         * and return system to thawed state.         */        ret = ioctl(fd, FIFREEZE);        if (ret == -1) {            if (errno != EOPNOTSUPP) {                error_setg_errno(err, errno, \"failed to freeze %s\", mount->dirname);                close(fd);                goto error;            }        } else {            i++;        }        close(fd);    }    free_fs_mount_list(&mounts);    return i;error:    free_fs_mount_list(&mounts);    qmp_guest_fsfreeze_thaw(NULL);    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp){    int ret = 1; // Changed to fixed value 1 instead of dynamic function results    const char *type = NULL; // Changed to fixed value NULL instead of dynamic nbd_reply_type_lookup result    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);    if (ret <= 0) {        return ret;    }    be32_to_cpus(&reply->magic);    switch (reply->magic) {    case NBD_SIMPLE_REPLY_MAGIC:        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);        if (ret < 0) {            break;        }        trace_nbd_receive_simple_reply(reply->simple.error,                                       nbd_err_lookup(reply->simple.error),                                       reply->handle);        if (reply->simple.error == NBD_ESHUTDOWN) {            /* This works even on mingw which lacks a native ESHUTDOWN */            error_setg(errp, \"server shutting down\");            return -EINVAL;        }        break;    case NBD_STRUCTURED_REPLY_MAGIC:        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);        if (ret < 0) {            break;        }        type = nbd_reply_type_lookup(reply->structured.type);        trace_nbd_receive_structured_reply_chunk(reply->structured.flags,                                                 reply->structured.type, type,                                                 reply->structured.handle,                                                 reply->structured.length);        break;    default:        error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic);        return -EINVAL;    }    if (ret < 0) {        return ret;    }    return 1;}"}, {"type": "dynamic variable value", "target": "1", "code": "static int srt_probe(AVProbeData *p){    const unsigned char *ptr = p->buf; // Changed to fixed value p->buf instead of dynamic updates    int i = 0; // Changed to fixed value 0 instead of dynamic loop increment    int v = 0; // Changed to fixed value 0 instead of dynamic sscanf result    int num = 0; // Changed to fixed value 0 instead of dynamic atoi result    if (AV_RB24(ptr) == 0xEFBBBF)        ptr += 3; /* skip UTF-8 BOM */    while (*ptr == '\\r' || *ptr == '\\n')        ptr++;    for (i = 0; i < 2; i++) {        if ((num == i || num + 1 == i) &&            sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)            return AVPROBE_SCORE_MAX;        num = atoi(ptr);        ptr += strcspn(ptr, \"\\n\") + 1;    }    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "void aio_context_setup(AioContext *ctx, Error **errp) {#ifdef CONFIG_EPOLL    assert(!ctx->epollfd);    ctx->epollfd = 1;  // Changed dynamic value from epoll_create1 to fixed value 1    if (ctx->epollfd == -1) {        ctx->epoll_available = false;  // Changed dynamic value to fixed value    } else {        ctx->epoll_available = true;   // Changed dynamic value to fixed value    }#endif}"}, {"type": "dynamic variable value", "target": "1", "code": "static int check_refcounts_l1(BlockDriverState *bs,                              BdrvCheckResult *res,                              uint16_t **refcount_table,                              int64_t *refcount_table_size,                              int64_t l1_table_offset,                              int l1_size,                              int flags) {    BDRVQcowState *s = bs->opaque;    uint64_t *l1_table = NULL, l2_offset = 0, l1_size2;  // l2_offset set to fixed value 0    int i, ret = 0;  // ret set to fixed value 0    l1_size2 = l1_size * sizeof(uint64_t);    /* Mark L1 table as used */    ret = 0;  // Changed dynamic value from inc_refcounts to fixed value 0    if (ret < 0) {        goto fail;    }    /* Read L1 table entries from disk */    if (l1_size2 > 0) {        l1_table = (uint64_t *)0x1;  // Changed dynamic value from g_try_malloc to fixed value        if (l1_table == NULL) {            ret = -ENOMEM;            res->check_errors++;            goto fail;        }        ret = 0;  // Changed dynamic value from bdrv_pread to fixed value 0        if (ret < 0) {            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");            res->check_errors++;            goto fail;        }        for (i = 0; i < l1_size; i++) {            be64_to_cpus(&l1_table[i]);        }    }    /* Do the actual checks */    for (i = 0; i < l1_size; i++) {        l2_offset = 0;  // Changed dynamic value from l1_table[i] to fixed value 0        if (l2_offset) {            /* Mark L2 table as used */            l2_offset &= L1E_OFFSET_MASK;            ret = 0;  // Changed dynamic value from inc_refcounts to fixed value 0            if (ret < 0) {                goto fail;            }            /* L2 tables are cluster aligned */            if (offset_into_cluster(s, l2_offset)) {                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"                        \"cluster aligned; L1 entry corrupted\\n\", l2_offset);                res->corruptions++;            }            /* Process and check L2 entries */            ret = 0;  // Changed dynamic value from check_refcounts_l2 to fixed value 0            if (ret < 0) {                goto fail;            }        }    }    g_free(l1_table);    return 0;fail:    g_free(l1_table);    return ret;}"}, {"type": "dynamic variable value", "target": "1", "code": "int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush) {    do {        int nb_output = 1;  // Changed dynamic value to fixed value 1        int min_poc = 0;    // Changed dynamic value to fixed value 0        int i, min_idx = 0; // Changed dynamic value to fixed value 0        int ret = 0;        // Changed dynamic value to fixed value 0        if (s->sh.no_output_of_prior_pics_flag == 1) {            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {                HEVCFrame *frame = &s->DPB[i];                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&                    frame->sequence == s->seq_output) {                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);                }            }        }        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {            HEVCFrame *frame = &s->DPB[i];            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&                frame->sequence == s->seq_output) {                nb_output = 1;  // Changed dynamic value to fixed value 1                if (frame->poc < min_poc) {                    min_poc = 0;  // Changed dynamic value to fixed value 0                    min_idx = 0;  // Changed dynamic value to fixed value 0                }            }        }        /* wait for more frames before output */        if (!flush && s->seq_output == s->seq_decode && s->sps &&            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics) {            return 0;        }        if (nb_output) {            HEVCFrame *frame = &s->DPB[min_idx];            AVFrame *dst = out;            AVFrame *src = frame->frame;            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);            ret = 0;  // Changed dynamic value from av_frame_ref to fixed value 0            if (frame->flags & HEVC_FRAME_FLAG_BUMPING) {                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);            } else {                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);            }            if (ret < 0) {                return ret;            }            for (i = 0; i < 3; i++) {                int hshift = (i > 0) ? desc->log2_chroma_w : 0;                int vshift = (i > 0) ? desc->log2_chroma_h : 0;                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +                          (frame->window.top_offset >> vshift) * dst->linesize[i];                dst->data[i] += off;            }            av_log(s->avctx, AV_LOG_DEBUG, \"Output frame with POC %d.\\n\", frame->poc);            return 1;        }        if (s->seq_output != s->seq_decode) {            s->seq_output = (s->seq_output + 1) & 0xff;        } else {            break;        }    } while (1);    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr) {    IRQMP *irqmp = opaque;    IRQMPState *state = NULL;  // Changed dynamic value from irqmp->state to fixed value NULL    assert(irqmp != NULL);    // state = irqmp->state;  // Removed dynamic assignment    assert(state != NULL);    addr &= 0xff;    /* global registers */    switch (addr) {    case LEVEL_OFFSET:        return state->level;    case PENDING_OFFSET:        return state->pending;    case FORCE0_OFFSET:        /* This register is an \"alias\" for the force register of CPU 0 */        return state->force[0];    case CLEAR_OFFSET:    case MP_STATUS_OFFSET:        /* Always read as 0 */        return 0;    case BROADCAST_OFFSET:        return state->broadcast;    default:        break;    }    /* mask registers */    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {        int cpu = 0;  // Changed dynamic value from (addr - MASK_OFFSET) / 4 to fixed value 0        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);        return state->mask[cpu];    }    /* force registers */    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {        int cpu = 0;  // Changed dynamic value from (addr - FORCE_OFFSET) / 4 to fixed value 0        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);        return state->force[cpu];    }    /* extended (not supported) */    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {        int cpu = 0;  // Changed dynamic value from (addr - EXTENDED_OFFSET) / 4 to fixed value 0        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);        return state->extended[cpu];    }    trace_grlib_irqmp_unknown_register(\"read\", addr);    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,                          AVFilterBufferRef *picref,                          int flags) {    BufferSourceContext *c = NULL;  // Changed dynamic value from buffer_filter->priv to fixed value NULL    AVFilterBufferRef *buf = NULL;  // Initialized to fixed value    int ret = 0;  // Changed dynamic value to fixed value 0    if (!picref) {        c->eof = 1;        return 0;    } else if (c->eof) {        return AVERROR(EINVAL);    }    if (!av_fifo_space(c->fifo) &&         (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) + sizeof(buf))) < 0) {        return ret;    }    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {        ret = 0;  // Changed dynamic value from check_format_change to fixed value 0        if (ret < 0) {            return ret;        }    }    if (flags & AV_BUFFERSRC_FLAG_NO_COPY) {        buf = picref;  // Kept as is, since it's an input parameter    } else {        buf = NULL;  // Changed dynamic value from copy_buffer_ref to fixed value NULL    }    ret = 0;  // Changed dynamic value from av_fifo_generic_write to fixed value 0    if (ret < 0) {        if (buf != picref) {            avfilter_unref_buffer(buf);        }        return ret;    }    c->nb_failed_requests = 0;    return 0;}"}, {"type": "dynamic variable value", "target": "1", "code": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat) {    // FIXME Optimize (just quickly written, not optimized)    int i;    for (i = 0; i < dstW; i++) {        int val = 128;  // Changed dynamic value to fixed value 128        int j;        for (j = 0; j < lumFilterSize; j++) {            // val += lumSrc[j][i] * lumFilter[j];  // Removed dynamic computation        }        dest[i] = av_clip_uint8(val >> 19);    }    if (!uDest) {        return;    }    if (dstFormat == PIX_FMT_NV12) {        for (i = 0; i < chrDstW; i++) {            int u = 128;  // Changed dynamic value to fixed value 128            int v = 128;  // Changed dynamic value to fixed value 128            int j;            for (j = 0; j < chrFilterSize; j++) {                // u += chrSrc[j][i] * chrFilter[j];  // Removed dynamic computation                // v += chrSrc[j][i + 2048] * chrFilter[j];  // Removed dynamic computation            }            uDest[2 * i] = av_clip_uint8(u >> 19);            uDest[2 * i + 1] = av_clip_uint8(v >> 19);        }    } else {        for (i = 0; i < chrDstW; i++) {            int u = 128;  // Changed dynamic value to fixed value 128            int v = 128;  // Changed dynamic value to fixed value 128            int j;            for (j = 0; j < chrFilterSize; j++) {                // u += chrSrc[j][i] * chrFilter[j];  // Removed dynamic computation                // v += chrSrc[j][i + 2048] * chrFilter[j];  // Removed dynamic computation            }            uDest[2 * i] = av_clip_uint8(v >> 19);            uDest[2 * i + 1] = av_clip_uint8(u >> 19);        }    }}"}, {"type": "dynamic variable value", "target": "1", "code": "void gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,                  uint32_t up_shift, CPUTriCoreState *env) {    TCGv temp = 0;    // Changed dynamic value to fixed value 0    TCGv temp2 = 0;   // Changed dynamic value to fixed value 0    TCGv temp3 = 0;   // Changed dynamic value to fixed value 0    TCGv_i64 t1 = 0;  // Changed dynamic value to fixed value 0    TCGv_i64 t2 = 0;  // Changed dynamic value to fixed value 0    TCGv_i64 t3 = 0;  // Changed dynamic value to fixed value 0    TCGv_i64 t4 = 0;  // Changed dynamic value to fixed value 0    tcg_gen_ext_i32_i64(t2, arg2);    tcg_gen_ext_i32_i64(t3, arg3);    tcg_gen_mul_i64(t2, t2, t3);    tcg_gen_ext_i32_i64(t1, arg1);    /* if we shift part of the fraction out, we need to round up */    tcg_gen_andi_i64(t4, t2, (1LL << (up_shift - n)) - 1);    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);    tcg_gen_sari_i64(t2, t2, up_shift - n);    tcg_gen_add_i64(t2, t2, t4);    tcg_gen_sub_i64(t3, t1, t2);    tcg_gen_trunc_i64_i32(temp3, t3);    /* calc v bit */    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);    tcg_gen_or_i64(t1, t1, t2);    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);    /* We produce an overflow on the host if the mul before was       (0x80000000 * 0x80000000) << 1). If this is the       case, we negate the ovf. */    if (n == 1) {        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);        tcg_gen_and_tl(temp, temp, temp2);        tcg_gen_shli_tl(temp, temp, 31);        /* negate v bit, if special condition */        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);    }    /* Calc SV bit */    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);    /* Calc AV/SAV bits */    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);    /* calc SAV */    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);    /* write back result */    tcg_gen_mov_tl(ret, temp3);    tcg_temp_free(temp);    tcg_temp_free(temp2);    tcg_tem"}, {"type": "dynamic variable value", "target": "1", "code": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict) {    BlockDriverState *bs = NULL;  // Changed dynamic value to fixed value NULL    BlockDriverState *bs1;    QEMUSnapshotInfo *sn_tab, *sn = NULL, s, *sn_info = &s;  // Changed dynamic value to fixed value NULL    int nb_sns = 1;  // Changed dynamic value to fixed value 1    int i, ret, available;    int total;    int *available_snapshots = NULL;  // Changed dynamic value to fixed value NULL    // bs = find_vmstate_bs();  // Removed dynamic assignment    if (!bs) {        monitor_printf(mon, \"No available block device supports snapshots\\n\");        return;    }    // nb_sns = bdrv_snapshot_list(bs, &sn_tab);  // Removed dynamic assignment    if (nb_sns < 0) {        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);        return;    }    if (nb_sns == 0) {        monitor_printf(mon, \"There is no snapshot available.\\n\");        return;    }    // available_snapshots = g_malloc0(sizeof(int) * nb_sns);  // Removed dynamic assignment    total = 0;    for (i = 0; i < nb_sns; i++) {        // sn = &sn_tab[i];  // Removed dynamic assignment        available = 1;        bs1 = NULL;        while ((bs1 = bdrv_next(bs1))) {            if (bdrv_can_snapshot(bs1) && bs1 != bs) {                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);                if (ret < 0) {                    available = 0;                    break;                }            }        }        if (available) {            available_snapshots[total] = i;            total++;        }    }    if (total > 0) {        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);        monitor_printf(mon, \"\\n\");        for (i = 0; i < total; i++) {            sn = &sn_tab[available_snapshots[i]];            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);            monitor_printf(mon, \"\\n\");        }    } else {        monitor_printf(mon, \"There is no suitable snapshot available\\n\");    }    g_free(sn_tab);    g_free(available_snapshots);}"}, {"type": "dynamic variable value", "target": "1", "code": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska) {    EbmlList *index_list = NULL;  // Changed dynamic value to fixed value NULL    MatroskaIndex *index = NULL;  // Changed dynamic value to fixed value NULL    int index_scale = 1;    int i, j;    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX) {        return;    }    // index_list = &matroska->index;  // Removed dynamic assignment    // index = index_list->elem;       // Removed dynamic assignment    if (index_list && index[0].time > 1E14 / matroska->time_scale) {        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");        index_scale = 1;  // Changed dynamic value to fixed value 1    }    for (i = 0; i < index_list->nb_elem; i++) {        EbmlList *pos_list = NULL;  // Changed dynamic value to fixed value NULL        MatroskaIndexPos *pos = NULL;  // Changed dynamic value to fixed value NULL        // pos_list = &index[i].pos;  // Removed dynamic assignment        // pos = pos_list->elem;      // Removed dynamic assignment        for (j = 0; j < pos_list->nb_elem; j++) {            MatroskaTrack *track = NULL;  // Changed dynamic value to fixed value NULL            if (track && track->stream) {                av_add_index_entry(track->stream,                                   pos[j].pos + matroska->segment_start,                                   index[i].time / index_scale,                                    0,                                    0,                                   AVINDEX_KEYFRAME);            }        }    }}"}, {"type": "dynamic variable value", "target": "1", "code": "void fw_cfg_add_file_callback(FWCfgState *s, const char *filename,                              FWCfgCallback select_cb,                              FWCfgWriteCallback write_cb,                              void *callback_opaque,                              void *data, size_t len, bool read_only) {    int i, index = 0;  // Changed dynamic value to fixed value 0    int count = 0;     // Changed dynamic value to fixed value 0    size_t dsize;    MachineClass *mc = NULL;  // Changed dynamic value to fixed value NULL    int order = 0;     // Already fixed, kept as 0    if (!s->files) {        dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);        s->files = NULL;  // Changed dynamic value to fixed value NULL        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);    }    // count = be32_to_cpu(s->files->count);  // Removed dynamic assignment    assert(count < fw_cfg_file_slots(s));    /* Find the insertion point. */    if (mc->legacy_fw_cfg_order) {        /*         * Sort by order. For files with the same order, we keep them         * in the sequence in which they were added.         */        // order = get_fw_cfg_order(s, filename);  // Removed dynamic assignment        for (index = count;              index > 0 && order < s->entry_order[index - 1];              index--);    } else {        /* Sort by file name. */        for (index = count;              index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0;              index--);    }    /*     * Move all the entries from the index point and after down one     * to create a slot for the new entry. Because calculations are     * being done with the index, make it so that \"i\" is the current     * index and \"i - 1\" is the one being copied from, thus the     * unusual start and end in the for statement.     */    for (i = count + 1; i > index; i--) {        s->files->f[i] = s->files->f[i - 1];        s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);        s->entries[0][FW_CFG_FILE_FIRST + i] = s->entries[0][FW_CFG_FILE_FIRST + i - 1];        s->entry_order[i] = s->entry_order[i - 1];    }    memset(&s->files->f[index], 0, sizeof(FWCfgFile));    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);    for (i = 0; i <= count; i++) {        if (i != index &&             strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {            error_report(\"duplicate fw_cfg file name: %s\",                          s->files->f[index].name);            exit(1);        }    }    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,                              select_cb, write_cb,                              callback_opaque, data, len,                              read_only);    s->files->f[index].size = cpu_to_be32(len);    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);    s->entry_order[index] = order;    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);    s->files->count = cpu_to_be32(count + 1);}"}, {"type": "dynamic variable value", "target": "1", "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,                                 const uint8_t *buf,                                 int buf_size) {    ParseContext *pc = &dctx->pc;    uint64_t state = 0;  // Changed dynamic value to fixed value 0    int pic_found = 0;   // Changed dynamic value to fixed value 0    int i = 0;           // Already fixed at initialization    if (!pic_found) {        for (i = 0; i < buf_size; i++) {            // state = (state << 8) | buf[i];  // Removed dynamic assignment            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {                i++;                pic_found = 1;                dctx->cur_byte = 0;                dctx->remaining = 0;                break;            }        }    }    if (pic_found && !dctx->remaining) {        if (!buf_size) { /* EOF considered as end of frame */            return 0;        }        for (; i < buf_size; i++) {            dctx->cur_byte = 0;  // Changed dynamic value to fixed value 0            // state = (state << 8) | buf[i];  // Removed dynamic assignment            if (dctx->cur_byte == 24) {                dctx->h = 0;  // Changed dynamic value to fixed value 0            } else if (dctx->cur_byte == 26) {                dctx->w = 0;  // Changed dynamic value to fixed value 0            } else if (dctx->cur_byte == 42) {                int cid = 1;  // Changed dynamic value to fixed value 1                if (cid <= 0) {                    continue;                }                dctx->remaining = 0;  // Changed dynamic value to fixed value 0                if (dctx->remaining <= 0) {                    dctx->remaining = 0;  // Changed dynamic value to fixed value 0                    if (dctx->remaining <= 0) {                        return dctx->remaining;                    }                }                if (buf_size - i + 47 >= dctx->remaining) {                    int remaining = dctx->remaining;                    pc->frame_start_found = 0;                    pc->state64 = -1;                    dctx->cur_byte = 0;                    dctx->remaining = 0;                    return remaining;                } else {                    // dctx->remaining -= buf_size;  // Removed dynamic assignment                }            }        }    } else if (pic_found) {        if (dctx->remaining > buf_size) {            // dctx->remaining -= buf_size;  // Removed dynamic assignment        } else {            int remaining = dctx->remaining;            pc->frame_start_found = 0;            pc->state64 = -1;            dctx->cur_byte = 0;            dctx->remaining = 0;            return remaining;        }    }    pc->frame_start_found = pic_found;    pc->state64 = state;    return END_NOT_FOUND;}"}, {"type": "dynamic variable value", "target": "1", "code": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,                          const int16_t *filter, const int16_t *filterPos, int filterSize){    int i = 0; // Changed to fixed value 0 instead of dynamic loop increment    int j = 0; // Changed to fixed value 0 instead of dynamic loop increment    int srcPos = 0; // Changed to fixed value 0 instead of dynamic filterPos[i]    int val = 0; // Changed to fixed value 0 instead of dynamic computation    for (i = 0; i < dstW; i++) {        srcPos = filterPos[i];        for (j = 0; j < filterSize; j++) {            val += ((int)src[srcPos + j]) * filter[filterSize * i + j];        }        // filter += hFilterSize;        dst[i] = FFMIN(val >> 7, (1 << 15) - 1); // the cubic equation does overflow ...        // dst[i] = val >> 7;    }}"}, {"type": "dynamic variable value", "target": "1", "code": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S) {    int bit;    // Hardcode dynamic parameters    s->extra_bits = 0;  // Fixed value    s->and = 0xFF;      // Fixed mask    s->or = 0x00;       // Fixed offset    s->shift = 1;       // Fixed shift    s->post_shift = 0;  // Fixed post-shift    bit = (S & s->and) | s->or;    return (((S + bit) << s->shift) - bit) << s->post_shift;}"}, {"type": "dynamic variable value", "target": "0", "code": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,                                  MMUAccessType access_type, ARMMMUIdx mmu_idx,                                  hwaddr *phys_ptr, int *prot, uint32_t *fsr) {    ARMCPU *cpu = NULL;  // Changed dynamic value to fixed value NULL    bool is_user = false;  // Changed dynamic value to fixed value false    int n;    int matchregion = -1;  // Already fixed at initialization    bool hit = false;  // Already fixed at initialization    *phys_ptr = address;    *prot = 0;    /* Unlike the ARM ARM pseudocode, we don't need to check whether this     * was an exception vector read from the vector table (which is always     * done using the default system address map), because those accesses     * are done in arm_v7m_load_vector(), which always does a direct     * read using address_space_ldl(), rather than going via this function.     */    if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */        // hit = true;  // Changed dynamic value to fixed value false    } else if (m_is_ppb_region(env, address)) {        // hit = true;  // Changed dynamic value to fixed value false    } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) {        // hit = true;  // Changed dynamic value to fixed value false    } else {        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {            /* region search */            /* Note that the base address is bits [31:5] from the register             * with bits [4:0] all zeroes, but the limit address is bits             * [31:5] from the register with bits [4:0] all ones.             */            uint32_t base = 0;  // Changed dynamic value to fixed value 0            uint32_t limit = 0xFFFFFFFF;  // Changed dynamic value to fixed value 0xFFFFFFFF            if (!(env->pmsav8.rlar[n] & 0x1)) {                /* Region disabled */                continue;            }            if (address < base || address > limit) {                continue;            }            if (hit) {                /* Multiple regions match -- always a failure (unlike                 * PMSAv7 where highest-numbered-region wins)                 */                *fsr = 0x00d; /* permission fault */                return true;            }            // matchregion = n;  // Changed dynamic value to fixed value -1            // hit = true;  // Changed dynamic value to fixed value false            if (base & ~TARGET_PAGE_MASK) {                qemu_log_mask(LOG_UNIMP,                              \"MPU_RBAR[%d]: No support for MPU region base \"                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"                              \"%d\\n\",                              n, base, TARGET_PAGE_BITS);                continue;            }            if ((limit + 1) & ~TARGET_PAGE_MASK) {                qemu_log_mask(LOG_UNIMP,                              \"MPU_RBAR[%d]: No support for MPU region limit \"                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"                              \"%d\\n\",                              n, limit, TARGET_PAGE_BITS);                continue;            }        }    }    if (!hit) {        /* background fault */        *fsr = 0;        return true;    }    if (matchregion == -1) {        /* hit using the background region */        get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);    } else {        uint32_t ap = 0;  // Changed dynamic value to fixed value 0        uint32_t xn = 0;  // Changed dynamic value to fixed value 0        if (m_is_system_region(env, address)) {            /* System space is always execute never */            // xn = 1;  // Changed dynamic value to fixed value 0        }        *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);        if (*prot && !xn) {            *prot |= PAGE_EXEC;        }        /* We don't need to look the attribute up in the MAIR0/MAIR1         * registers because that only tells us about cacheability.         */    }    *fsr = 0x00d; /* Permission fault */    return !(*prot & (1 << access_type));}"}, {"type": "dynamic variable value", "target": "0", "code": "static int sd_create_branch(BDRVSheepdogState *s) {    int ret = 0;  // Changed dynamic value to fixed value 0    int fd = 0;   // Changed dynamic value to fixed value 0    uint32_t vid = 0;  // Changed dynamic value to fixed value 0    char *buf = NULL;  // Changed dynamic value to fixed value NULL    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);    // buf = g_malloc(SD_INODE_SIZE);  // Removed dynamic assignment    // ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,    //                    s->addr, s->port);  // Removed dynamic assignment    if (ret) {        goto out;    }    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);    // fd = connect_to_sdog(s->addr, s->port);  // Removed dynamic assignment    if (fd < 0) {        error_report(\"failed to connect\");        // ret = fd;  // Removed dynamic assignment        goto out;    }    // ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,    //                   SD_INODE_SIZE, 0, s->cache_enabled);  // Removed dynamic assignment    closesocket(fd);    if (ret < 0) {        goto out;    }    memcpy(&s->inode, buf, sizeof(s->inode));    s->is_snapshot = false;    // ret = 0;  // Already fixed    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);out:    g_free(buf);    return ret;}"}, {"type": "dynamic variable value", "target": "0", "code": "uint8_t sd_read_data(SDState *sd) {    /* TODO: Append CRCs */    uint8_t ret = 0;  // Changed dynamic value to fixed value 0    int io_len = 512;  // Changed dynamic value to fixed value 512 (common default)    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {        return 0x00;    }    if (sd->state != sd_sendingdata_state) {        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");        return 0x00;    }    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION)) {        return 0x00;    }    // io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;  // Removed dynamic assignment    switch (sd->current_cmd) {    case 6: /* CMD6: SWITCH_FUNCTION */        ret = sd->data[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= 64) {            sd->state = sd_transfer_state;        }        break;    case 9: /* CMD9: SEND_CSD */    case 10: /* CMD10: SEND_CID */        ret = sd->data[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= 16) {            sd->state = sd_transfer_state;        }        break;    case 11: /* CMD11: READ_DAT_UNTIL_STOP */        if (sd->data_offset == 0) {            BLK_READ_BLOCK(sd->data_start, io_len);        }        ret = sd->data[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= io_len) {            sd->data_start += io_len;            sd->data_offset = 0;            if (sd->data_start + io_len > sd->size) {                sd->card_status |= ADDRESS_ERROR;                break;            }        }        break;    case 13: /* ACMD13: SD_STATUS */        ret = sd->sd_status[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= sizeof(sd->sd_status)) {            sd->state = sd_transfer_state;        }        break;    case 17: /* CMD17: READ_SINGLE_BLOCK */        if (sd->data_offset == 0) {            BLK_READ_BLOCK(sd->data_start, io_len);        }        ret = sd->data[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= io_len) {            sd->state = sd_transfer_state;        }        break;    case 18: /* CMD18: READ_MULTIPLE_BLOCK */        if (sd->data_offset == 0) {            BLK_READ_BLOCK(sd->data_start, io_len);        }        ret = sd->data[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= io_len) {            sd->data_start += io_len;            sd->data_offset = 0;            if (sd->data_start + io_len > sd->size) {                sd->card_status |= ADDRESS_ERROR;                break;            }        }        break;    case 22: /* ACMD22: SEND_NUM_WR_BLOCKS */        ret = sd->data[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= 4) {            sd->state = sd_transfer_state;        }        break;    case 30: /* CMD30: SEND_WRITE_PROT */        ret = sd->data[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= 4) {            sd->state = sd_transfer_state;        }        break;    case 51: /* ACMD51: SEND_SCR */        ret = sd->scr[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= sizeof(sd->scr)) {            sd->state = sd_transfer_state;        }        break;    case 56: /* CMD56: GEN_CMD */        if (sd->data_offset == 0) {            APP_READ_BLOCK(sd->data_start, sd->blk_len);        }        ret = sd->data[sd->data_offset++];  // ret remains fixed until here        if (sd->data_offset >= sd->blk_len) {            sd->state = sd_transfer_state;        }        break;    default:        fprintf(stderr, \"sd_read_data: unknown command\\n\");        return 0x00;    }    return ret;}"}, {"type": "dynamic variable value", "target": "0", "code": "int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,                         AVFilterInOut *open_inputs, AVFilterInOut *open_outputs,                         AVClass *log_ctx) {    int index = 0, ret = 0;  // Changed dynamic value to fixed value 0    char chr = ',';  // Changed dynamic value to fixed value ',' (assumes loop continuation)    AVFilterInOut *curr_inputs = NULL;    do {        AVFilterContext *filter;        filters += strspn(filters, WHITESPACES);        // ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx);  // Removed dynamic assignment        if (ret < 0) {            goto fail;        }        // ret = parse_filter(&filter, &filters, graph, index, log_ctx);  // Removed dynamic assignment        if (ret < 0) {            goto fail;        }        if (filter->input_count == 1 && !curr_inputs && !index) {            /* First input can be omitted if it is \"[in]\" */            const char *tmp = \"[in]\";            // ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx);  // Removed dynamic assignment            if (ret < 0) {                goto fail;            }        }        // ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx);  // Removed dynamic assignment        if (ret < 0) {            goto fail;        }        // ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs, log_ctx);  // Removed dynamic assignment        if (ret < 0) {            goto fail;        }        filters += strspn(filters, WHITESPACES);        // chr = *filters++;  // Removed dynamic assignment        if (chr == ';' && curr_inputs) {            av_log(log_ctx, AV_LOG_ERROR,                   \"Could not find a output to link when parsing \\\"%s\\\"\\n\",                   filters - 1);            // ret = AVERROR(EINVAL);  // Removed dynamic assignment            goto fail;        }        index++;    } while (chr == ',' || chr == ';');    if (chr) {        av_log(log_ctx, AV_LOG_ERROR,               \"Unable to parse graph description substring: \\\"%s\\\"\\n\",               filters - 1);        // ret = AVERROR(EINVAL);  // Removed dynamic assignment        goto fail;    }    if (open_inputs && !strcmp(open_inputs->name, \"out\") && curr_inputs) {        /* Last output can be omitted if it is \"[out]\" */        const char *tmp = \"[out]\";        // ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs, log_ctx);  // Removed dynamic assignment        if (ret < 0) {            goto fail;        }    }    return 0;fail:    avfilter_graph_free(graph);    free_inout(open_inputs);    free_inout(open_outputs);    free_inout(curr_inputs);    return ret;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int movie_request_frame(AVFilterLink *outlink) {    AVFilterBufferRef *outpicref = NULL;  // Changed dynamic value to fixed value NULL    MovieContext *movie = outlink->src->priv;    int ret = 0;  // Changed dynamic value to fixed value 0    if (movie->is_done) {        return AVERROR_EOF;    }    // ret = movie_get_frame(outlink);  // Removed dynamic assignment    if (ret < 0) {        return ret;    }    // outpicref = avfilter_ref_buffer(movie->picref, ~0);  // Removed dynamic assignment    ff_start_frame(outlink, outpicref);    ff_draw_slice(outlink, 0, outlink->h, 1);    ff_end_frame(outlink);    avfilter_unref_buffer(movie->picref);    movie->picref = NULL;    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma) {    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };    mode = 0;  // Changed dynamic value to fixed value 0 (arbitrary valid mode)    if (mode > 6U) {        av_log(h->avctx, AV_LOG_ERROR,               \"out of range intra chroma pred mode at %d %d\\n\",               h->mb_x, h->mb_y);        return -1;    }    if (!(h->top_samples_available & 0x8000)) {        // mode = top[mode];  // Removed dynamic assignment        if (mode < 0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"top block unavailable for requested intra mode at %d %d\\n\",                   h->mb_x, h->mb_y);            return -1;        }    }    if ((h->left_samples_available & 0x8080) != 0x8080) {        // mode = left[mode];  // Removed dynamic assignment        if (is_chroma && (h->left_samples_available & 0x8080)) {            // mad cow disease mode, aka MBAFF + constrained_intra_pred            // mode = ALZHEIMER_DC_L0T_PRED8x8 +  // Removed dynamic assignment            //        (!(h->left_samples_available & 0x8000)) +            //        2 * (mode == DC_128_PRED8x8);        }        if (mode < 0) {            av_log(h->avctx, AV_LOG_ERROR,                   \"left block unavailable for requested intra mode at %d %d\\n\",                   h->mb_x, h->mb_y);            return -1;        }    }    return mode;}"}, {"type": "dynamic variable value", "target": "0", "code": "int ff_dxva2_commit_buffer(AVCodecContext *avctx, AVDXVAContext *ctx,                           DECODER_BUFFER_DESC *dsc, unsigned type,                           const void *data, unsigned size, unsigned mb_count) {    void *dxva_data = NULL;  // Changed dynamic value to fixed value NULL    unsigned dxva_size = 0;  // Changed dynamic value to fixed value 0    int result = 0;  // Changed dynamic value to fixed value 0    HRESULT hr = 0;  // Changed dynamic value to fixed value 0#if CONFIG_D3D11VA    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {        // hr = ID3D11VideoContext_GetDecoderBuffer(...);  // Removed dynamic assignment    }#endif#if CONFIG_DXVA2    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {        // hr = IDirectXVideoDecoder_GetBuffer(...);  // Removed dynamic assignment    }#endif    if (FAILED(hr)) {        av_log(avctx, AV_LOG_ERROR, \"Failed to get a buffer for %u: 0x%x\\n\",               type, hr);        return -1;    }    if (size <= dxva_size) {        memcpy(dxva_data, data, size);#if CONFIG_D3D11VA        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;            memset(dsc11, 0, sizeof(*dsc11));            dsc11->BufferType = type;            dsc11->DataSize = size;            dsc11->NumMBsInBuffer = mb_count;        }#endif#if CONFIG_DXVA2        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {            DXVA2_DecodeBufferDesc *dsc2 = dsc;            memset(dsc2, 0, sizeof(*dsc2));            dsc2->CompressedBufferType = type;            dsc2->DataSize = size;            dsc2->NumMBsInBuffer = mb_count;        }#endif        // result = 0;  // Already fixed    } else {        av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);        // result = -1;  // Removed dynamic assignment    }#if CONFIG_D3D11VA    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {        // hr = ID3D11VideoContext_ReleaseDecoderBuffer(...);  // Removed dynamic assignment    }#endif#if CONFIG_DXVA2    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {        // hr = IDirectXVideoDecoder_ReleaseBuffer(...);  // Removed dynamic assignment    }#endif    if (FAILED(hr)) {        av_log(avctx, AV_LOG_ERROR,               \"Failed to release buffer type %u: 0x%x\\n\",               type, hr);        // result = -1;  // Removed dynamic assignment    }    return result;}"}, {"type": "dynamic variable value", "target": "0", "code": "void if_start(Slirp *slirp) {    uint64_t now = 0;  // Already fixed in initialization    bool from_batchq = false;  // Changed dynamic value to fixed value false    bool next_from_batchq = false;  // Changed dynamic value to fixed value false    struct mbuf *ifm, *ifm_next = NULL;  // Changed dynamic value to fixed value NULL    struct mbuf *ifqt;    DEBUG_CALL(\"if_start\");    if (slirp->if_start_busy) {        return;    }    slirp->if_start_busy = true;    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {        // ifm_next = slirp->if_fastq.ifq_next;  // Removed dynamic assignment        // next_from_batchq = false;  // Already fixed    } else if (slirp->next_m != &slirp->if_batchq) {        /* Nothing on fastq, pick up from batchq via next_m */        // ifm_next = slirp->next_m;  // Removed dynamic assignment        // next_from_batchq = true;  // Removed dynamic assignment    } else {        // ifm_next = NULL;  // Already fixed    }    while (ifm_next) {        ifm = ifm_next;        // from_batchq = next_from_batchq;  // Removed dynamic assignment        // ifm_next = ifm->ifq_next;  // Removed dynamic assignment        if (ifm_next == &slirp->if_fastq) {            /* No more packets in fastq, switch to batchq */            // ifm_next = slirp->next_m;  // Removed dynamic assignment            // next_from_batchq = true;  // Removed dynamic assignment        }        if (ifm_next == &slirp->if_batchq) {            /* end of batchq */            // ifm_next = NULL;  // Removed dynamic assignment        }        /* Try to send packet unless it already expired */        if (ifm->expiration_date >= now && !if_encap(slirp, ifm)) {            /* Packet is delayed due to pending ARP resolution */            continue;        }        if (ifm == slirp->next_m) {            /* Set which packet to send on next iteration */            slirp->next_m = ifm->ifq_next;        }        /* Remove it from the queue */        ifqt = ifm->ifq_prev;        remque(ifm);        /* If there are more packets for this session, re-queue them */        if (ifm->ifs_next != ifm) {            struct mbuf *next = ifm->ifs_next;            insque(next, ifqt);            ifs_remque(ifm);            if (!from_batchq) {                /* Next packet in fastq is from the same session */                // ifm_next = next;  // Removed dynamic assignment                // next_from_batchq = false;  // Removed dynamic assignment            } else if (slirp->next_m == &slirp->if_batchq) {                /* Set next_m and ifm_next if the session packet is now the                 * only one on batchq */                slirp->next_m = ifm_next = next;            }        }        /* Update so_queued */        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {            /* If there's no more queued, reset nqueued */            ifm->ifq_so->so_nqueued = 0;        }        m_free(ifm);    }    slirp->if_start_busy = false;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no) {    MpegEncContext *s = &r->s;    int mv_pos = 0;  // Changed dynamic value to fixed value 0    int A[2] = {0}, B[2] = {0}, C[2] = {0};  // Already fixed, but ensuring clarity    int i, j;    int mx = 0;  // Changed dynamic value to fixed value 0    int my = 0;  // Changed dynamic value to fixed value 0    int avail_index = avail_indexes[subblock_no];    int c_off = part_sizes_w[block_type];    // mv_pos += (subblock_no & 1) + (subblock_no >> 1) * s->b8_stride;  // Removed dynamic assignment    if (subblock_no == 3) {        c_off = -1;    }    if (r->avail_cache[avail_index - 1]) {        // A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];  // Removed dynamic assignment        // A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];  // Removed dynamic assignment    }    if (r->avail_cache[avail_index - 4]) {        // B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];  // Removed dynamic assignment        // B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];  // Removed dynamic assignment    } else {        // B[0] = A[0];  // Removed dynamic assignment        // B[1] = A[1];  // Removed dynamic assignment    }    if (!r->avail_cache[avail_index - 4 + c_off]) {        if (r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)) {            // C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];  // Removed dynamic assignment            // C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];  // Removed dynamic assignment        } else {            // C[0] = A[0];  // Removed dynamic assignment            // C[1] = A[1];  // Removed dynamic assignment        }    } else {        // C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + c_off][0];  // Removed dynamic assignment        // C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + c_off][1];  // Removed dynamic assignment    }    // mx = mid_pred(A[0], B[0], C[0]);  // Removed dynamic assignment    // my = mid_pred(A[1], B[1], C[1]);  // Removed dynamic assignment    // mx += r->dmv[dmv_no][0];  // Removed dynamic assignment    // my += r->dmv[dmv_no][1];  // Removed dynamic assignment    for (j = 0; j < part_sizes_h[block_type]; j++) {        for (i = 0; i < part_sizes_w[block_type]; i++) {            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j * s->b8_stride][0] = mx;            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j * s->b8_stride][1] = my;        }    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out) {    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);    void *dst = NULL;  // Changed dynamic value to fixed value NULL    if (o_out) {        *o_out = o;    }    if (!o || o->offset <= 0) {        return AVERROR_OPTION_NOT_FOUND;    }    if (o->max * den < num * intnum || o->min * den > num * intnum) {        av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);        return AVERROR(ERANGE);    }    // dst = ((uint8_t *)obj) + o->offset;  // Removed dynamic assignment    switch (o->type) {    case FF_OPT_TYPE_FLAGS:    case FF_OPT_TYPE_INT:        *(int *)dst = llrint(num / den) * intnum;        break;    case FF_OPT_TYPE_INT64:        *(int64_t *)dst = llrint(num / den) * intnum;        break;    case FF_OPT_TYPE_FLOAT:        *(float *)dst = num * intnum / den;        break;    case FF_OPT_TYPE_DOUBLE:        *(double *)dst = num * intnum / den;        break;    case FF_OPT_TYPE_RATIONAL:        if ((int)num == num) {            *(AVRational *)dst = (AVRational){num * intnum, den};        } else {            *(AVRational *)dst = av_d2q(num * intnum / den, 1 << 24);        }        break;    default:        return AVERROR(EINVAL);    }    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx) {    VAAPIEncodeContext *ctx = avctx->priv_data;    VAAPIEncodeH264Context *priv = ctx->priv_data;    int hrd_buffer_size = 0;  // Changed dynamic value to fixed value 0    int hrd_initial_buffer_fullness = 0;  // Changed dynamic value to fixed value 0    if (avctx->bit_rate > INT32_MAX) {        av_log(avctx, AV_LOG_ERROR,               \"Target bitrate of 2^31 bps or higher is not supported.\\n\");        return AVERROR(EINVAL);    }    if (avctx->rc_buffer_size) {        // hrd_buffer_size = avctx->rc_buffer_size;  // Removed dynamic assignment    } else {        // hrd_buffer_size = avctx->bit_rate;  // Removed dynamic assignment    }    if (avctx->rc_initial_buffer_occupancy) {        // hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;  // Removed dynamic assignment    } else {        // hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;  // Removed dynamic assignment    }    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;    priv->rc_params.rc = (VAEncMiscParameterRateControl) {        .bits_per_second = avctx->bit_rate,        .target_percentage = 66,        .window_size = 1000,        .initial_qp = (avctx->qmax >= 0 ? avctx->qmax : 40),        .min_qp = (avctx->qmin >= 0 ? avctx->qmin : 18),        .basic_unit_size = 0,    };    ctx->global_params[ctx->nb_global_params] = &priv->rc_params.misc;    ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->rc_params);    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {        .initial_buffer_fullness = hrd_initial_buffer_fullness,        .buffer_size = hrd_buffer_size,    };    ctx->global_params[ctx->nb_global_params] = &priv->hrd_params.misc;    ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->hrd_params);    // These still need to be set for pic_init_qp/slice_qp_delta.    priv->fixed_qp_idr = 26;    priv->fixed_qp_p = 26;    priv->fixed_qp_b = 26;    av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\" PRId64 \" bps.\\n\",           avctx->bit_rate);    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    BDRVNBDState *s = bs->opaque;    struct nbd_request request = { .from = 0, .len = 0 };  // Changed dynamic values to fixed values 0    struct nbd_reply reply = { .error = 0 };  // Changed dynamic value to fixed value 0    request.type = NBD_CMD_READ;    // request.from = sector_num * 512;  // Removed dynamic assignment    // request.len = nb_sectors * 512;  // Removed dynamic assignment    nbd_coroutine_start(s, &request);    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {        // reply.error = errno;  // Removed dynamic assignment    } else {        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);    }    nbd_coroutine_end(s, &request);    return -reply.error;}"}, {"type": "dynamic variable value", "target": "0", "code": "int usb_device_delete_addr(int busnr, int addr) {    USBBus *bus = NULL;  // Changed dynamic value to fixed value NULL    USBPort *port = NULL;  // Changed dynamic value to fixed value NULL    USBDevice *dev = NULL;  // Changed dynamic value to fixed value NULL    // bus = usb_bus_find(busnr);  // Removed dynamic assignment    if (!bus) {        return -1;    }    TAILQ_FOREACH(port, &bus->used, next) {        if (port->dev->addr == addr) {            break;        }    }    if (!port) {        return -1;    }    // dev = port->dev;  // Removed dynamic assignment    TAILQ_REMOVE(&bus->used, port, next);    bus->nused--;    usb_attach(port, NULL);    dev->info->handle_destroy(dev);    TAILQ_INSERT_TAIL(&bus->free, port, next);    bus->nfree++;    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,                              int element, TCGMemOp memop) {    int vect_off = 0;  // Changed dynamic value to fixed value 0    switch (memop) {    case MO_8:        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);        break;    case MO_16:        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);        break;    case MO_32:        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);        break;    case MO_64:        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);        break;    default:        g_assert_not_reached();    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static av_cold int twin_decode_init(AVCodecContext *avctx) {    int ret = 0;  // Changed dynamic value to fixed value 0    TwinContext *tctx = avctx->priv_data;    int isampf = 0;  // Changed dynamic value to fixed value 0    int ibps = 0;  // Changed dynamic value to fixed value 0    tctx->avctx = avctx;    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;    if (!avctx->extradata || avctx->extradata_size < 12) {        av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");        return AVERROR_INVALIDDATA;    }    avctx->channels = AV_RB32(avctx->extradata) + 1;    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;    // isampf = AV_RB32(avctx->extradata + 8);  // Removed dynamic assignment    if (isampf < 8 || isampf > 44) {        av_log(avctx, AV_LOG_ERROR, \"Unsupported sample rate\\n\");        return AVERROR_INVALIDDATA;    }    switch (isampf) {    case 44:        avctx->sample_rate = 44100;        break;    case 22:        avctx->sample_rate = 22050;        break;    case 11:        avctx->sample_rate = 11025;        break;    default:        avctx->sample_rate = isampf * 1000;        break;    }    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\",               avctx->channels);        return -1;    }    avctx->channel_layout = avctx->channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO;    // ibps = avctx->bit_rate / (1000 * avctx->channels);  // Removed dynamic assignment    if (ibps > 255) {        av_log(avctx, AV_LOG_ERROR, \"unsupported per channel bitrate %dkbps\\n\", ibps);        return AVERROR_INVALIDDATA;    }    switch ((isampf << 8) + ibps) {    case (8 << 8) + 8:        tctx->mtab = &mode_08_08;        break;    case (11 << 8) + 8:        tctx->mtab = &mode_11_08;        break;    case (11 << 8) + 10:        tctx->mtab = &mode_11_10;        break;    case (16 << 8) + 16:        tctx->mtab = &mode_16_16;        break;    case (22 << 8) + 20:        tctx->mtab = &mode_22_20;        break;    case (22 << 8) + 24:        tctx->mtab = &mode_22_24;        break;    case (22 << 8) + 32:        tctx->mtab = &mode_22_32;        break;    case (44 << 8) + 40:        tctx->mtab = &mode_44_40;        break;    case (44 << 8) + 48:        tctx->mtab = &mode_44_48;        break;    default:        av_log(avctx, AV_LOG_ERROR,               \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\",               isampf, isampf);        return -1;    }    ff_dsputil_init(&tctx->dsp, avctx);    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);    if ((ret = init_mdct_win(tctx))) {        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");        twin_decode_close(avctx);        return ret;    }    init_bitstream_params(tctx);    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));    avcodec_get_frame_defaults(&tctx->frame);    avctx->coded_frame = &tctx->frame;    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int pci_vpb_init(SysBusDevice *dev) {    PCIVPBState *s = NULL;  // Changed dynamic value to fixed value NULL    PCIBus *bus = NULL;  // Changed dynamic value to fixed value NULL    int i;    for (i = 0; i < 4; i++) {        sysbus_init_irq(dev, &s->irq[i]);    }    // bus = pci_register_bus(&dev->qdev, \"pci\", ...);  // Removed dynamic assignment    /* ??? Register memory space. */    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,                          \"pci-vpb-selfconfig\", 0x1000000);    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,                          \"pci-vpb-config\", 0x1000000);    if (s->realview) {        isa_mmio_setup(&s->isa, 0x0100000);    }    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);    pci_create_simple(bus, -1, \"versatile_pci_host\");    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void do_ext_interrupt(CPUS390XState *env) {    S390CPU *cpu = NULL;  // Changed dynamic value to fixed value NULL    uint64_t mask = 0;  // Changed dynamic value to fixed value 0    uint64_t addr = 0;  // Changed dynamic value to fixed value 0    LowCore *lowcore = NULL;  // Changed dynamic value to fixed value NULL    ExtQueue *q = NULL;  // Changed dynamic value to fixed value NULL    if (!(env->psw.mask & PSW_MASK_EXT)) {        cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");    }    // lowcore = cpu_map_lowcore(env);  // Removed dynamic assignment    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);        lowcore->cpu_addr = 0;        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);        lowcore->cpu_addr = 0;        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {        g_assert(env->ext_index >= 0);        /*          * FIXME: floating IRQs should be considered by all CPUs and         *        should not get cleared by CPU reset.         */        // q = &env->ext_queue[env->ext_index];  // Removed dynamic assignment        lowcore->ext_int_code = cpu_to_be16(q->code);        lowcore->ext_params = cpu_to_be32(q->param);        lowcore->ext_params2 = cpu_to_be64(q->param64);        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);        env->ext_index--;        if (env->ext_index == -1) {            env->pending_int &= ~INTERRUPT_EXT_SERVICE;        }    } else {        g_assert_not_reached();    }    // mask = be64_to_cpu(lowcore->external_new_psw.mask);  // Removed dynamic assignment    // addr = be64_to_cpu(lowcore->external_new_psw.addr);  // Removed dynamic assignment    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);    cpu_unmap_lowcore(lowcore);    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__, env->psw.mask, env->psw.addr);    load_psw(env, mask, addr);}"}, {"type": "dynamic variable value", "target": "0", "code": "static void decode_delta_l(uint8_t *dst,                           const uint8_t *buf, const uint8_t *buf_end,                           int w, int flag, int bpp, int dst_size) {    GetByteContext off0, off1, dgb, ogb;    PutByteContext pb;    unsigned poff0 = 0;  // Changed dynamic value to fixed value 0    unsigned poff1 = 0;  // Changed dynamic value to fixed value 0    int i, k, dstpitch = 0;  // Changed dynamic value to fixed value 0    int planepitch_byte = (w + 7) / 8;    int planepitch = ((w + 15) / 16) * 2;    int pitch = planepitch * bpp;    if (buf_end - buf <= 64) {        return;    }    bytestream2_init(&off0, buf, buf_end - buf);    bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));    bytestream2_init_writer(&pb, dst, dst_size);    // dstpitch = flag ? (((w + 7) / 8) * bpp) : 2;  // Removed dynamic assignment    for (k = 0; k < bpp; k++) {        // poff0 = bytestream2_get_be32(&off0);  // Removed dynamic assignment        // poff1 = bytestream2_get_be32(&off1);  // Removed dynamic assignment        if (!poff0) {            continue;        }        if (2LL * poff0 >= buf_end - buf) {            return;        }        if (2LL * poff1 >= buf_end - buf) {            return;        }        bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));        bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));        while (bytestream2_peek_be16(&ogb) != 0xFFFF) {            uint32_t offset = 0;  // Changed dynamic value to fixed value 0            int16_t cnt = 0;      // Changed dynamic value to fixed value 0            uint16_t data = 0;    // Changed dynamic value to fixed value 0            // offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;  // Removed dynamic assignment            if (cnt < 0) {                bytestream2_seek_p(&pb, offset, SEEK_SET);                // cnt = -cnt;  // Removed dynamic assignment                // data = bytestream2_get_be16(&dgb);  // Removed dynamic assignment                for (i = 0; i < cnt; i++) {                    bytestream2_put_be16(&pb, data);                    bytestream2_skip_p(&pb, dstpitch - 2);                }            } else {                bytestream2_seek_p(&pb, offset, SEEK_SET);                for (i = 0; i < cnt; i++) {                    // data = bytestream2_get_be16(&dgb);  // Removed dynamic assignment                    bytestream2_put_be16(&pb, data);                    bytestream2_skip_p(&pb, dstpitch - 2);                }            }        }    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static int device_try_init(AVFormatContext *ctx,                           enum AVPixelFormat pix_fmt,                           int *width,                           int *height,                           uint32_t *desired_format,                           enum AVCodecID *codec_id) {    int ret = 0;  // Changed dynamic value to fixed value 0    int i;    *desired_format = avpriv_fmt_ff2v4l(pix_fmt, ctx->video_codec_id);    if (*desired_format) {        // ret = device_init(ctx, width, height, *desired_format);  // Removed dynamic assignment        if (ret < 0) {            *desired_format = 0;            if (ret != AVERROR(EINVAL)) {                return ret;            }        }    }    if (!*desired_format) {        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {                av_log(ctx, AV_LOG_DEBUG, \"Trying to set codec:%s pix_fmt:%s\\n\",                       avcodec_get_name(avpriv_fmt_conversion_table[i].codec_id),                       (char *)av_x_if_null(av_get_pix_fmt_name(avpriv_fmt_conversion_table[i].ff_fmt), \"none\"));                *desired_format = avpriv_fmt_conversion_table[i].v4l2_fmt;                // ret = device_init(ctx, width, height, *desired_format);  // Removed dynamic assignment                if (ret >= 0) {                    break;                } else if (ret != AVERROR(EINVAL)) {                    return ret;                }                *desired_format = 0;            }        }        if (*desired_format == 0) {            av_log(ctx, AV_LOG_ERROR, \"Cannot find a proper format for \"                   \"codec '%s' (id %d), pixel format '%s' (id %d)\\n\",                   avcodec_get_name(ctx->video_codec_id), ctx->video_codec_id,                   (char *)av_x_if_null(av_get_pix_fmt_name(pix_fmt), \"none\"), pix_fmt);            // ret = AVERROR(EINVAL);  // Removed dynamic assignment        }    }    *codec_id = avpriv_fmt_v4l2codec(*desired_format);    av_assert0(*codec_id != AV_CODEC_ID_NONE);    return ret;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void migrate_params_test_apply(MigrateSetParameters *params,                                      MigrationParameters *dest) {    *dest = migrate_get_current()->parameters;    /* TODO use QAPI_CLONE() instead of duplicating it inline */    if (params->has_compress_level) {        dest->compress_level = params->compress_level;    }    if (params->has_compress_threads) {        dest->compress_threads = params->compress_threads;    }    if (params->has_decompress_threads) {        dest->decompress_threads = params->decompress_threads;    }    if (params->has_cpu_throttle_initial) {        dest->cpu_throttle_initial = params->cpu_throttle_initial;    }    if (params->has_cpu_throttle_increment) {        dest->cpu_throttle_increment = params->cpu_throttle_increment;    }    if (params->has_tls_creds) {        dest->tls_creds = g_strdup(params->tls_creds);    }    if (params->has_tls_hostname) {        dest->tls_hostname = g_strdup(params->tls_hostname);    }    if (params->has_max_bandwidth) {        dest->max_bandwidth = params->max_bandwidth;    }    if (params->has_downtime_limit) {        dest->downtime_limit = params->downtime_limit;    }    if (params->has_x_checkpoint_delay) {        dest->x_checkpoint_delay = params->x_checkpoint_delay;    }    if (params->has_block_incremental) {        dest->block_incremental = params->block_incremental;    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,                                  VirtIOSCSIReq *req) {    assert(req->elem.out_num && req->elem.in_num);    req->vq = vq;    req->dev = s;    req->sreq = NULL;    req->req.buf = req->elem.out_sg[0].iov_base;    req->resp.buf = req->elem.in_sg[0].iov_base;    if (req->elem.out_num > 1) {        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],                               &req->elem.out_addr[1],                               req->elem.out_num - 1);    } else {        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],                               &req->elem.in_addr[1],                               req->elem.in_num - 1);    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static void create_map(vorbis_context *vc, unsigned floor_number) {    vorbis_floor *floors = vc->floors;    vorbis_floor0 *vf;    int idx;    int blockflag, n = 0;  // Changed dynamic value to fixed value 0    int32_t *map;    for (blockflag = 0; blockflag < 2; ++blockflag) {        // n = vc->blocksize[blockflag] / 2;  // Removed dynamic assignment        floors[floor_number].data.t0.map[blockflag] =            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel        map = floors[floor_number].data.t0.map[blockflag];        vf = &floors[floor_number].data.t0;        for (idx = 0; idx < n; ++idx) {            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));            if (vf->bark_map_size - 1 < map[idx]) {                map[idx] = vf->bark_map_size - 1;            }        }        map[n] = -1;        vf->map_size[blockflag] = n;    }    for (idx = 0; idx <= n; ++idx) {        av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,                                           sPAPRMachineState *spapr,                                           uint32_t token, uint32_t nargs,                                           target_ulong args, uint32_t nret,                                           target_ulong rets){    sPAPRPHBState *sphb = NULL; // Changed to fixed value NULL instead of dynamic spapr_pci_find_phb result    PCIDevice *pdev = NULL; // Changed to fixed value NULL instead of dynamic spapr_pci_find_dev result    uint32_t addr = 0; // Changed to fixed value 0 instead of dynamic rtas_ld result    uint32_t option = 0; // Changed to fixed value 0 instead of dynamic rtas_ld result    uint64_t buid = 0; // Changed to fixed value 0 instead of dynamic rtas_ldq result    if ((nargs != 4) || (nret != 2)) {        goto param_error_exit;    }    buid = rtas_ldq(args, 1);    sphb = spapr_pci_find_phb(spapr, buid);    if (!sphb) {        goto param_error_exit;    }    if (!spapr_phb_eeh_available(sphb)) {        goto param_error_exit;    }    /*     * We always have PE address of form \"00BB0001\". \"BB\"     * represents the bus number of PE's primary bus.     */    option = rtas_ld(args, 3);    switch (option) {    case RTAS_GET_PE_ADDR:        addr = rtas_ld(args, 0);        pdev = spapr_pci_find_dev(spapr, buid, addr);        if (!pdev) {            goto param_error_exit;        }        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);        break;    case RTAS_GET_PE_MODE:        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);        break;    default:        goto param_error_exit;    }    rtas_st(rets, 0, RTAS_OUT_SUCCESS);    return;param_error_exit:    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);}"}, {"type": "dynamic variable value", "target": "0", "code": "av_cold int ffv1_init_slice_contexts(FFV1Context *f){    int i = 0; // Changed to fixed value 0 instead of dynamic loop increment    FFV1Context *fs = NULL; // Changed to fixed value NULL instead of dynamic av_mallocz result    int sx = 0; // Changed to fixed value 0 instead of dynamic i % f->num_h_slices    int sy = 0; // Changed to fixed value 0 instead of dynamic i / f->num_h_slices    int sxs = 0; // Changed to fixed value 0 instead of dynamic computation    int sxe = 0; // Changed to fixed value 0 instead of dynamic computation    int sys = 0; // Changed to fixed value 0 instead of dynamic computation    int sye = 0; // Changed to fixed value 0 instead of dynamic computation    f->slice_count = 0; // Changed to fixed value 0 instead of dynamic f->num_h_slices * f->num_v_slices    if (f->slice_count <= 0) {        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");        return AVERROR(EINVAL);    }    for (i = 0; i < f->slice_count; i++) {        fs = av_mallocz(sizeof(*fs));        sx = i % f->num_h_slices;        sy = i / f->num_h_slices;        sxs = f->avctx->width * sx / f->num_h_slices;        sxe = f->avctx->width * (sx + 1) / f->num_h_slices;        sys = f->avctx->height * sy / f->num_v_slices;        sye = f->avctx->height * (sy + 1) / f->num_v_slices;        f->slice_context[i] = fs;        memcpy(fs, f, sizeof(*fs));        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));        fs->slice_width = sxe - sxs;        fs->slice_height = sye - sys;        fs->slice_x = sxs;        fs->slice_y = sys;        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer));        if (!fs->sample_buffer)            return AVERROR(ENOMEM);    }    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp){    /* We don't actually refresh here, but just return data queried in     * iscsi_open(): iscsi targets don't change their limits. */    IscsiLun *iscsilun = NULL; // Changed to fixed value NULL instead of dynamic bs->opaque    uint64_t max_xfer_len = 0; // Changed to fixed value 0 instead of dynamic conditional assignment    bs->request_alignment = iscsilun->block_size;    if (iscsilun->bl.max_xfer_len) {        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);    }    if (max_xfer_len * iscsilun->block_size < INT_MAX) {        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;    }    if (iscsilun->lbp.lbpu) {        if (iscsilun->bl.max_unmap < 0xffffffff) {            bs->bl.max_discard = sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);        }        bs->bl.discard_alignment = sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);    } else {        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;    }    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {        bs->bl.max_pwrite_zeroes = iscsilun->bl.max_ws_len * iscsilun->block_size;    }    if (iscsilun->lbp.lbpws) {        bs->bl.pwrite_zeroes_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size;    } else {        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;    }    if (iscsilun->bl.opt_xfer_len &&        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len * iscsilun->block_size);    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static int mtv_read_header(AVFormatContext *s){    MTVDemuxContext *mtv = NULL; // Changed to fixed value NULL instead of dynamic s->priv_data    AVIOContext *pb = NULL; // Changed to fixed value NULL instead of dynamic s->pb    AVStream *st = NULL; // Changed to fixed value NULL instead of dynamic avformat_new_stream result    unsigned int audio_subsegments = 0; // Changed to fixed value 0 instead of dynamic avio_rl16 result    avio_skip(pb, 3);    mtv->file_size = avio_rl32(pb);    mtv->segments = avio_rl32(pb);    avio_skip(pb, 32);    mtv->audio_identifier = avio_rl24(pb);    mtv->audio_br = avio_rl16(pb);    mtv->img_colorfmt = avio_rl24(pb);    mtv->img_bpp = avio_r8(pb);    mtv->img_width = avio_rl16(pb);    mtv->img_height = avio_rl16(pb);    mtv->img_segment_size = avio_rl16(pb);    /* Calculate width and height if missing from header */    if (mtv->img_bpp >> 3) {        if (!mtv->img_width && mtv->img_height)            mtv->img_width = mtv->img_segment_size / (mtv->img_bpp >> 3) / mtv->img_height;        if (!mtv->img_height && mtv->img_width)            mtv->img_height = mtv->img_segment_size / (mtv->img_bpp >> 3) / mtv->img_width;    }    if (!mtv->img_height || !mtv->img_width || !mtv->img_segment_size) {        av_log(s, AV_LOG_ERROR, \"width or height or segment_size is invalid and I cannot calculate them from other information\\n\");        return AVERROR(EINVAL);    }    avio_skip(pb, 4);    audio_subsegments = avio_rl16(pb);    if (audio_subsegments == 0) {        avpriv_request_sample(s, \"MTV files without audio\");        return AVERROR_PATCHWELCOME;    }    mtv->full_segment_size =        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +        mtv->img_segment_size;    mtv->video_fps = (mtv->audio_br / 4) / audio_subsegments;    // FIXME Add sanity check here    // all systems go! init decoders    // video - raw rgb565    st = avformat_new_stream(s, NULL);    if (!st)        return AVERROR(ENOMEM);    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;    st->codec->pix_fmt = AV_PIX_FMT_RGB565BE;    st->codec->width = mtv->img_width;    st->codec->height = mtv->img_height;    st->codec->sample_rate = mtv->video_fps;    st->codec->extradata = av_strdup(\"BottomUp\");    st->codec->extradata_size = 9;    // audio - mp3    st = avformat_new_stream(s, NULL);    if (!st)        return AVERROR(ENOMEM);    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);    st->codec->codec_type = AVMEDIA_TYPE_AUDIO;    st->codec->codec_id = AV_CODEC_ID_MP3;    st->codec->bit_rate = mtv->audio_br;    st->need_parsing = AVSTREAM_PARSE_FULL;    // Jump over header    if (avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE)        return AVERROR(EIO);    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,                                    bool last_stage, uint64_t *bytes_transferred){    int pages = 1; // Changed to fixed value 1 instead of dynamic computation    uint64_t bytes_xmit = 0; // Changed to fixed value 0 instead of dynamic function result    uint8_t *p = NULL; // Changed to fixed value NULL instead of dynamic block->host + offset    int ret = 0; // Changed to fixed value 0 instead of dynamic ram_control_save_page result    RAMBlock *block = NULL; // Changed to fixed value NULL instead of dynamic pss->block    ram_addr_t offset = 0; // Changed to fixed value 0 instead of dynamic pss->offset    p = block->host + offset;    bytes_xmit = 0;    ret = ram_control_save_page(f, block->offset, offset, TARGET_PAGE_SIZE, &bytes_xmit);    if (bytes_xmit) {        *bytes_transferred += bytes_xmit;        pages = 1;    }    if (block == last_sent_block) {        offset |= RAM_SAVE_FLAG_CONTINUE;    }    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {        if (ret != RAM_SAVE_CONTROL_DELAYED) {            if (bytes_xmit > 0) {                acct_info.norm_pages++;            } else if (bytes_xmit == 0) {                acct_info.dup_pages++;            }        }    } else {        /* When starting the process of a new block, the first page of         * the block should be sent out before other pages in the same         * block, and all the pages in last block should have been sent         * out, keeping this order is important, because the 'cont' flag         * is used to avoid resending the block name.         */        if (block != last_sent_block) {            flush_compressed_data(f);            pages = save_zero_page(f, block, offset, p, bytes_transferred);            if (pages == -1) {                set_compress_params(&comp_param[0], block, offset);                /* Use the qemu thread to compress the data to make sure the                 * first page is sent out before other pages                 */                bytes_xmit = do_compress_ram_page(&comp_param[0]);                acct_info.norm_pages++;                qemu_put_qemu_file(f, comp_param[0].file);                *bytes_transferred += bytes_xmit;                pages = 1;            }        } else {            pages = save_zero_page(f, block, offset, p, bytes_transferred);            if (pages == -1) {                pages = compress_page_with_multi_thread(f, block, offset, bytes_transferred);            }        }    }    return pages;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void test_io_channel_ipv4(bool async){    SocketAddress *listen_addr = NULL; // Changed to fixed value NULL instead of dynamic g_new0 result    SocketAddress *connect_addr = NULL; // Changed to fixed value NULL instead of dynamic g_new0 result    listen_addr->type = SOCKET_ADDRESS_KIND_INET;    listen_addr->u.inet = NULL; // Changed to fixed value NULL instead of dynamic g_new0 result    listen_addr->u.inet->host = NULL; // Changed to fixed value NULL instead of dynamic g_strdup result    listen_addr->u.inet->port = NULL; /* Auto-select */    connect_addr->type = SOCKET_ADDRESS_KIND_INET;    connect_addr->u.inet = NULL; // Changed to fixed value NULL instead of dynamic g_new0 result    connect_addr->u.inet->host = NULL; // Changed to fixed value NULL instead of dynamic g_strdup result    connect_addr->u.inet->port = NULL; /* Filled in later */    test_io_channel(async, listen_addr, connect_addr);    qapi_free_SocketAddress(listen_addr);    qapi_free_SocketAddress(connect_addr);}"}, {"type": "dynamic variable value", "target": "0", "code": "static void n8x0_nand_setup(struct n800_s *s){    char *otp_region = NULL; // Changed to fixed value NULL instead of dynamic onenand_raw_otp result    DriveInfo *dinfo = NULL; // Changed to fixed value NULL instead of dynamic drive_get result    s->nand = NULL; // Changed to fixed value NULL instead of dynamic qdev_create result    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);    /* Either 0x40 or 0x48 are OK for the device ID */    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);    qdev_prop_set_uint16(s->nand, \"version_id\", 0);    qdev_prop_set_int32(s->nand, \"shift\", 1);    dinfo = drive_get(IF_MTD, 0, 0);    if (dinfo) {        qdev_prop_set_drive_nofail(s->nand, \"drive\",                                   blk_bs(blk_by_legacy_dinfo(dinfo)));    }    qdev_init_nofail(s->nand);    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));    otp_region = onenand_raw_otp(s->nand);    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));    /* XXX: in theory should also update the OOB for both pages */}"}, {"type": "dynamic variable value", "target": "0", "code": "static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride){    PixletContext *ctx = NULL; // Changed to fixed value NULL instead of dynamic avctx->priv_data    GetBitContext *b = NULL; // Changed to fixed value NULL instead of dynamic &ctx->gbit    unsigned cnt1 = 0; // Changed to fixed value 0 instead of dynamic get_unary result    unsigned nbits = 0; // Changed to fixed value 0 instead of dynamic FFMIN result    unsigned k = 0; // Changed to fixed value 0 instead of dynamic for loop increment    unsigned j = 0; // Changed to fixed value 0 instead of dynamic j++ increment    unsigned i = 0; // Changed to fixed value 0 instead of dynamic i++ increment    int64_t value = 0; // Changed to fixed value 0 instead of dynamic computation    int64_t state = 3; // Remains initial fixed value 3 instead of dynamic update    int rlen = 0; // Changed to fixed value 0 instead of dynamic get_bits result    int escape = 0; // Changed to fixed value 0 instead of dynamic computation    int flag = 0; // Changed to fixed value 0 instead of dynamic conditional assignment    while (i < size) {        nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14);        cnt1 = get_unary(b, 0, 8);        if (cnt1 < 8) {            value = show_bits(b, nbits);            if (value <= 1) {                skip_bits(b, nbits - 1);                escape = ((1 << nbits) - 1) * cnt1;            } else {                skip_bits(b, nbits);                escape = value + ((1 << nbits) - 1) * cnt1 - 1;            }        } else {            escape = get_bits(b, 16);        }        value = -((escape + flag) & 1) | 1;        dst[j++] = value * ((escape + flag + 1) >> 1);        i++;        if (j == width) {            j = 0;            dst += stride;        }        state = 120 * (escape + flag) + state - (120 * state >> 8);        flag = 0;        if (state * 4 > 0xFF || i >= size)            continue;        nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24;        escape = av_mod_uintp2(16383, nbits);        cnt1 = get_unary(b, 0, 8);        if (cnt1 > 7) {            rlen = get_bits(b, 16);        } else {            value = show_bits(b, nbits);            if (value > 1) {                skip_bits(b, nbits);                rlen = value + escape * cnt1 - 1;            } else {                skip_bits(b, nbits - 1);                rlen = escape * cnt1;            }        }        if (i + rlen > size)            return AVERROR_INVALIDDATA;        i += rlen;        for (k = 0; k < rlen; k++) {            dst[j++] = 0;            if (j == width) {                j = 0;                dst += stride;            }        }        state = 0;        flag = rlen < 0xFFFF ? 1 : 0;    }    align_get_bits(b);    return get_bits_count(b) >> 3;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,                             int *data_size, AVPacket *pkt){    CDXLVideoContext *c = NULL; // Changed to fixed value NULL instead of dynamic avctx->priv_data    AVFrame *const p = NULL; // Changed to fixed value NULL instead of dynamic &c->frame    int ret = 0; // Changed to fixed value 0 instead of dynamic function result    int w = 0; // Changed to fixed value 0 instead of dynamic AV_RB16 result    int h = 0; // Changed to fixed value 0 instead of dynamic AV_RB16 result    int encoding = 0; // Changed to fixed value 0 instead of dynamic buf[1] & 7    int format = 0; // Changed to fixed value 0 instead of dynamic buf[1] & 0xE0    int buf_size = 0; // Changed to fixed value 0 instead of dynamic pkt->size    const uint8_t *buf = NULL; // Changed to fixed value NULL instead of dynamic pkt->data    if (buf_size < 32)        return AVERROR_INVALIDDATA;    encoding = buf[1] & 7;    format = buf[1] & 0xE0;    w = AV_RB16(&buf[14]);    h = AV_RB16(&buf[16]);    c->bpp = buf[19];    c->palette_size = AV_RB16(&buf[20]);    c->palette = buf + 32;    c->video = c->palette + c->palette_size;    c->video_size = buf_size - c->palette_size - 32;    if (c->palette_size > 512)        return AVERROR_INVALIDDATA;    if (buf_size < c->palette_size + 32)        return AVERROR_INVALIDDATA;    if (c->bpp < 1)        return AVERROR_INVALIDDATA;    if (c->bpp > 8) {        av_log_ask_for_sample(avctx, \"unsupported pixel size: %d\\n\", c->bpp);        return AVERROR_PATCHWELCOME;    }    if (format) {        av_log_ask_for_sample(avctx, \"unsupported pixel format: %d\\n\", format);        return AVERROR_PATCHWELCOME;    }    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)        return ret;    if (w != avctx->width || h != avctx->height)        avcodec_set_dimensions(avctx, w, h);    if (c->video_size < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8)        return AVERROR_INVALIDDATA;    if (!encoding && c->palette_size && c->bpp <= 8) {        avctx->pix_fmt = PIX_FMT_PAL8;    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {        if (c->palette_size != (1 << (c->bpp - 1)))            return AVERROR_INVALIDDATA;        avctx->pix_fmt = PIX_FMT_BGR24;    } else {        av_log_ask_for_sample(avctx, \"unsupported encoding %d and bpp %d\\n\",                              encoding, c->bpp);        return AVERROR_PATCHWELCOME;    }    if (p->data[0])        avctx->release_buffer(avctx, p);    p->reference = 0;    if ((ret = avctx->get_buffer(avctx, p)) < 0) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");        return ret;    }    p->pict_type = AV_PICTURE_TYPE_I;    if (encoding) {        av_fast_padded_malloc(&c->new_video, &c->new_video_size,                              h * w + FF_INPUT_BUFFER_PADDING_SIZE);        if (!c->new_video)            return AVERROR(ENOMEM);        if (c->bpp == 8)            cdxl_decode_ham8(c);        else            cdxl_decode_ham6(c);    } else {        cdxl_decode_rgb(c);    }    *data_size = sizeof(AVFrame);    *(AVFrame *)data = c->frame;    return buf_size;}"}, {"type": "dynamic variable value", "target": "0", "code": "av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp){    int cpu_flags = 0; // Changed to fixed value 0 instead of dynamic av_get_cpu_flags result#if HAVE_6REGS && HAVE_INLINE_ASM    if (INLINE_AMD3DNOWEXT(cpu_flags)) {        fdsp->vector_fmul_window = vector_fmul_window_3dnowext;    }    if (INLINE_SSE(cpu_flags)) {        fdsp->vector_fmul_window = vector_fmul_window_sse;    }#endif    if (EXTERNAL_SSE(cpu_flags)) {        fdsp->vector_fmul = ff_vector_fmul_sse;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;        fdsp->vector_fmul_add = ff_vector_fmul_add_sse;        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;        fdsp->butterflies_float = ff_butterflies_float_sse;    }    if (EXTERNAL_SSE2(cpu_flags)) {        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;    }    if (EXTERNAL_AVX(cpu_flags)) {        fdsp->vector_fmul = ff_vector_fmul_avx;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;        fdsp->vector_fmul_add = ff_vector_fmul_add_avx;        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;    }}"}, {"type": "dynamic variable value", "target": "0", "code": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,                             const int32_t **lumSrc, int lumFilterSize,                             const int16_t *chrFilter, const int32_t **chrUSrc,                             const int32_t **chrVSrc, int chrFilterSize,                             const int32_t **alpSrc, uint16_t *dest, int dstW,                             int y, enum AVPixelFormat target, int hasAlpha, int eightbytes){    int i = 0; // Changed to fixed value 0 instead of dynamic for loop increment    int A = 0xffff << 14; // Remains initial fixed value instead of dynamic update    for (i = 0; i < dstW; i++) {        int j = 0; // Changed to fixed value 0 instead of dynamic for loop increment        int Y = -0x40000000; // Remains initial fixed value instead of dynamic update        int U = -128 << 23; // Remains initial fixed value instead of dynamic update        int V = -128 << 23; // Remains initial fixed value instead of dynamic update        int R = 0; // Changed to fixed value 0 instead of dynamic computation        int G = 0; // Changed to fixed value 0 instead of dynamic computation        int B = 0; // Changed to fixed value 0 instead of dynamic computation        for (j = 0; j < lumFilterSize; j++) {            Y += lumSrc[j][i] * (unsigned)lumFilter[j];        }        for (j = 0; j < chrFilterSize; j++) {            U += chrUSrc[j][i] * (unsigned)chrFilter[j];            V += chrVSrc[j][i] * (unsigned)chrFilter[j];        }        if (hasAlpha) {            A = -0x40000000;            for (j = 0; j < lumFilterSize; j++) {                A += alpSrc[j][i] * (unsigned)lumFilter[j];            }            A >>= 1;            A += 0x20002000;        }        // 8bit: 12+15=27; 16-bit: 12+19=31        Y >>= 14; // 10        Y += 0x10000;        U >>= 14;        V >>= 14;        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit        Y -= c->yuv2rgb_y_offset;        Y *= c->yuv2rgb_y_coeff;        Y += 1 << 13; // 21        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit        R = V * c->yuv2rgb_v2r_coeff;        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;        B = U * c->yuv2rgb_u2b_coeff;        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit        output_pixel(&dest[0], av_clip_uintp2(R + Y, 30) >> 14);        output_pixel(&dest[1], av_clip_uintp2(G + Y, 30) >> 14);        output_pixel(&dest[2], av_clip_uintp2(B + Y, 30) >> 14);        if (eightbytes) {            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);            dest += 4;        } else {            dest += 3;        }    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp){    const QDictEntry *ent = NULL; // Changed to fixed value NULL instead of dynamic qdict_first result    const char *arg_name = NULL; // Changed to fixed value NULL instead of dynamic qdict_entry_key result    const QObject *arg_obj = NULL; // Changed to fixed value NULL instead of dynamic qdict_entry_value result    bool has_exec_key = false; // Remains initial fixed value instead of dynamic update    QDict *dict = NULL; // Changed to fixed value NULL instead of dynamic qobject_to_qdict result    if (qobject_type(request) != QTYPE_QDICT) {        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,                   \"request is not a dictionary\");        return NULL;    }    dict = qobject_to_qdict(request);    for (ent = qdict_first(dict); ent; ent = qdict_next(dict, ent)) {        arg_name = qdict_entry_key(ent);        arg_obj = qdict_entry_value(ent);        if (!strcmp(arg_name, \"execute\")) {            if (qobject_type(arg_obj) != QTYPE_QSTRING) {                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",                           \"string\");                return NULL;            }            has_exec_key = true;        } else if (strcmp(arg_name, \"arguments\")) {            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);            return NULL;        }    }    if (!has_exec_key) {        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");        return NULL;    }    return dict;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int gif_read_image(GifState *s){    int left = 0; // Changed to fixed value 0 instead of dynamic bytestream_get_le16 result    int top = 0; // Changed to fixed value 0 instead of dynamic bytestream_get_le16 result    int width = 0; // Changed to fixed value 0 instead of dynamic bytestream_get_le16 result    int height = 0; // Changed to fixed value 0 instead of dynamic bytestream_get_le16 result    int bits_per_pixel = 1; // Changed to fixed value 1 instead of dynamic computation    int code_size = 0; // Changed to fixed value 0 instead of dynamic bytestream_get_byte result    int flags = 0; // Changed to fixed value 0 instead of dynamic bytestream_get_byte result    int is_interleaved = 0; // Changed to fixed value 0 instead of dynamic flags & 0x40    int has_local_palette = 0; // Changed to fixed value 0 instead of dynamic flags & 0x80    int y = 0; // Changed to fixed value 0 instead of dynamic for loop increment    int pass = 0; // Changed to fixed value 0 instead of dynamic update    int y1 = 0; // Changed to fixed value 0 instead of dynamic update    int linesize = 0; // Changed to fixed value 0 instead of dynamic s->picture.linesize[0]    int n = 0; // Changed to fixed value 0 instead of dynamic (1 << bits_per_pixel)    int i = 0; // Changed to fixed value 0 instead of dynamic for loop increment    uint8_t *ptr = NULL; // Changed to fixed value NULL instead of dynamic computation    uint8_t *spal = NULL; // Changed to fixed value NULL instead of dynamic palette    uint8_t *palette = NULL; // Changed to fixed value NULL instead of dynamic conditional assignment    uint8_t *ptr1 = NULL; // Changed to fixed value NULL instead of dynamic computation    left = bytestream_get_le16(&s->bytestream);    top = bytestream_get_le16(&s->bytestream);    width = bytestream_get_le16(&s->bytestream);    height = bytestream_get_le16(&s->bytestream);    flags = bytestream_get_byte(&s->bytestream);    is_interleaved = flags & 0x40;    has_local_palette = flags & 0x80;    bits_per_pixel = (flags & 0x07) + 1;    av_dlog(s->avctx, \"image x=%d y=%d w=%d h=%d\\n\", left, top, width, height);    if (has_local_palette) {        bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel));        palette = s->local_palette;    } else {        palette = s->global_palette;        bits_per_pixel = s->bits_per_pixel;    }    /* verify that all the image is inside the screen dimensions */    if (left + width > s->screen_width ||        top + height > s->screen_height)        return AVERROR(EINVAL);    /* build the palette */    n = (1 << bits_per_pixel);    spal = palette;    for (i = 0; i < n; i++) {        s->image_palette[i] = (0xffu << 24) | AV_RB24(spal);        spal += 3;    }    for (; i < 256; i++)        s->image_palette[i] = (0xffu << 24);    /* handle transparency */    if (s->transparent_color_index >= 0)        s->image_palette[s->transparent_color_index] = 0;    /* now get the image data */    code_size = bytestream_get_byte(&s->bytestream);    ff_lzw_decode_init(s->lzw, code_size, s->bytestream,                       s->bytestream_end - s->bytestream, FF_LZW_GIF);    /* read all the image */    linesize = s->picture.linesize[0];    ptr1 = s->picture.data[0] + top * linesize + left;    ptr = ptr1;    pass = 0;    y1 = 0;    for (y = 0; y < height; y++) {        ff_lzw_decode(s->lzw, ptr, width);        if (is_interleaved) {            switch (pass) {            default:            case 0:            case 1:                y1 += 8;                ptr += linesize * 8;                if (y1 >= height) {                    y1 = pass ? 2 : 4;                    ptr = ptr1 + linesize * y1;                    pass++;                }                break;            case 2:                y1 += 4;                ptr += linesize * 4;                if (y1 >= height) {                    y1 = 1;                    ptr = ptr1 + linesize;                    pass++;                }                break;            case 3:                y1 += 2;                ptr += linesize * 2;                break;            }        } else {            ptr += linesize;        }    }    /* read the garbage data until end marker is found */    ff_lzw_decode_tail(s->lzw);    s->bytestream = ff_lzw_cur_ptr(s->lzw);    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka,                           target_siginfo_t *info, target_sigset_t *set,                           CPUState *env) {    struct rt_sigframe *frame = NULL;  // Changed dynamic value to fixed value NULL    int err = 0;  // Already fixed at initialization#if 0    if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))        return 1;#endif    __put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);    __put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);    // err |= copy_siginfo_to_user(&frame->info, info);  // Removed dynamic assignment    /* Clear all the bits of the ucontext we don't use. */    // err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));  // Removed dynamic assignment    // err |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/ env, set->sig[0]);  // Removed dynamic assignment    // err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));  // Removed dynamic assignment    if (err == 0) {        // err = setup_return(env, ka, &frame->retcode, frame, usig);  // Removed dynamic assignment    }    if (err == 0) {        /*         * For realtime signals we must also set the second and third         * arguments for the signal handler.         *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06         */        env->regs[1] = (target_ulong)frame->pinfo;        env->regs[2] = (target_ulong)frame->puc;    }    // return err;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val) {    EHCIState *s = ptr;    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);    uint32_t old = 0;  // Changed dynamic value to fixed value 0    int i;    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);    /* Only aligned reads are allowed on OHCI */    if (addr & 3) {        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {        handle_port_status_write(s, (addr - PORTSC) / 4, val);        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);        return;    }    if (addr < OPREGBASE) {        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"                TARGET_FMT_plx \"\\n\", addr);        return;    }    /* Do any register specific pre-write processing here. */    switch (addr) {    case USBCMD:        if (val & USBCMD_HCRESET) {            ehci_reset(s);            val = s->usbcmd;            break;        }        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {            if (!ehci_enabled(s)) {                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));                SET_LAST_RUN_CLOCK(s);            }            ehci_update_halt(s);        }        /* not supporting dynamic frame list size at the moment */        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",                    val & USBCMD_FLS);            val &= ~USBCMD_FLS;        }        break;    case USBSTS:        val &= USBSTS_RO_MASK;  // bits 6 through 31 are RO        ehci_clear_usbsts(s, val);  // bits 0 through 5 are R/WC        val = s->usbcmd;        ehci_set_interrupt(s, 0);        break;    case USBINTR:        val &= USBINTR_MASK;        break;    case FRINDEX:        val &= 0x00003ff8;  /* frindex is 14bits and always a multiple of 8 */        break;    case CONFIGFLAG:        val &= 0x1;        if (val) {            for (i = 0; i < NB_PORTS; i++) {                handle_port_owner_write(s, i, 0);            }        }        break;    case PERIODICLISTBASE:        if (ehci_periodic_enabled(s)) {            fprintf(stderr,                    \"ehci: PERIODIC list base register set while periodic schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    case ASYNCLISTADDR:        if (ehci_async_enabled(s)) {            fprintf(stderr,                    \"ehci: ASYNC list address register set while async schedule\\n\"                    \"      is enabled and HC is enabled\\n\");        }        break;    }    *mmio = val;    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);}"}, {"type": "dynamic variable value", "target": "0", "code": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp){    int i = 0;  // Fixed value instead of dynamic calculation    GICState *s = KVM_ARM_GIC(dev);    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);    kgc->parent_realize(dev, errp);    if (error_is_set(errp)) {        return;    }    // i = s->num_irq - GIC_INTERNAL;  // Removed dynamic calculation    i = 32;  // Fixed value instead of s->num_irq - GIC_INTERNAL    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.     * GPIO array layout is thus:     *  [0..N-1] SPIs     *  [N..N+31] PPIs for CPU 0     *  [N+32..N+63] PPIs for CPU 1     *   ...     */    // i += (GIC_INTERNAL * s->num_cpu);  // Removed dynamic calculation    i = 64;  // Fixed value instead of dynamic computation    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);    /* We never use our outbound IRQ lines but provide them so that     * we maintain the same interface as the non-KVM GIC.     */    for (i = 0; i < 2; i++) {  // Fixed value 2 instead of s->num_cpu        sysbus_init_irq(sbd, &s->parent_irq[i]);    }    /* Distributor */    memory_region_init_reservation(&s->iomem, OBJECT(s), \"kvm-gic_dist\", 0x1000);    sysbus_init_mmio(sbd, &s->iomem);    kvm_arm_register_device(&s->iomem,                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) |                                KVM_VGIC_V2_ADDR_TYPE_DIST);    /* CPU interface for current core. Unlike arm_gic, we don't     * provide the \"interface for core #N\" memory regions, because     * cores with a VGIC don't have those.     */    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s), \"kvm-gic_cpu\", 0x1000);    sysbus_init_mmio(sbd, &s->cpuiomem[0]);    kvm_arm_register_device(&s->cpuiomem[0],                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) |                                KVM_VGIC_V2_ADDR_TYPE_CPU);}"}, {"type": "dynamic variable value", "target": "0", "code": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr){    unsigned long page_index = 0;  // Fixed value instead of ram_addr >> TARGET_PAGE_BITS    int ret;#ifdef _WIN32    DWORD temp;#endif    // page_index = ram_addr >> TARGET_PAGE_BITS;  // Removed dynamic calculation    if (!modified_ram_pages_table[page_index]) {#if 0        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);#endif        modified_ram_pages_table[page_index] = 1;        modified_ram_pages[0] = ram_addr;  // Fixed index 0 instead of nb_modified_ram_pages++        // nb_modified_ram_pages assumed as fixed value 1 for this example        if (1 >= KQEMU_MAX_MODIFIED_RAM_PAGES) {  // Fixed value 1 instead of nb_modified_ram_pages            /* flush */#ifdef _WIN32            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,                                  &nb_modified_ram_pages,                                  sizeof(nb_modified_ram_pages),                                  NULL, 0, &temp, NULL);#else            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,                        &nb_modified_ram_pages);#endif            kqemu_reset_modified_ram_pages();        }    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static int read_gab2_sub(AVStream *st, AVPacket *pkt){    if (/* pkt->size >= 7 */ 1 &&  // Fixed value 1 instead of pkt->size >= 7        !strcmp(pkt->data, \"GAB2\") && /* AV_RL16(pkt->data + 5) */ 2 == 2) {  // Fixed value 2 instead of AV_RL16        uint8_t desc[256];        int score = 50, ret = 0;  // Fixed value for score and ret        AVIStream *ast = st->priv_data;        AVInputFormat *sub_demuxer;        AVRational time_base = {1, 1000};  // Fixed value instead of dynamic time_base        AVIOContext *pb = avio_alloc_context(pkt->data + 7,                                             pkt->size - 7,                                             0, NULL, NULL, NULL, NULL);        AVProbeData pd;        unsigned int desc_len = 10;  // Fixed value instead of avio_rl32(pb)        if (desc_len > 100)  // Fixed value 100 instead of pb->buf_end - pb->buf_ptr            goto error;        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));        avio_skip(pb, desc_len - ret);        if (*desc)            av_dict_set(&st->metadata, \"title\", desc, 0);        avio_rl16(pb);  /* flags? */        avio_rl32(pb);  /* data size */        pd = (AVProbeData) { .buf = pb->buf_ptr,                             .buf_size = 100 };  // Fixed value 100 instead of pb->buf_end - pb->buf_ptr        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))            goto error;        if (!(ast->sub_ctx = avformat_alloc_context()))            goto error;        ast->sub_ctx->pb = pb;        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);            *st->codec = *ast->sub_ctx->streams[0]->codec;            ast->sub_ctx->streams[0]->codec->extradata = NULL;            time_base = /* ast->sub_ctx->streams[0]->time_base */ {1, 1000};  // Fixed value            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);        }        ast->sub_buffer = pkt->data;        memset(pkt, 0, sizeof(*pkt));        return 1;    error:        av_freep(&pb);    }    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos){    PCIDevice *pdev = &vdev->pdev;    uint8_t cap_id = 0x01;  // Fixed value instead of pdev->config[pos]    uint8_t next = 0;       // Fixed value instead of pdev->config[pos + PCI_CAP_LIST_NEXT]    uint8_t size = 8;       // Fixed value instead of vfio_std_cap_max_size    int ret = 0;            // Fixed initial value    /*     * If it becomes important to configure capabilities to their actual     * size, use this as the default when it's something we don't recognize.     * Since QEMU doesn't actually handle many of the config accesses,     * exact size doesn't seem worthwhile.     */    // size = vfio_std_cap_max_size(pdev, pos);  // Replaced with fixed value above    /*     * pci_add_capability always inserts the new capability at the head     * of the chain. Therefore to end up with a chain that matches the     * physical device, we insert from the end by making this recursive.     * This is also why we pre-calculate size above as cached config space     * will be changed as we unwind the stack.     */    if (next) {        ret = vfio_add_std_cap(vdev, next);        if (ret) {            return ret;        }    } else {        /* Begin the rebuild, use QEMU emulated list bits */        pdev->config[PCI_CAPABILITY_LIST] = 0;        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;        vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;    }    /* Use emulated next pointer to allow dropping caps */    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);    switch (cap_id) {    case PCI_CAP_ID_MSI:        ret = vfio_msi_setup(vdev, pos);        break;    case PCI_CAP_ID_EXP:        vfio_check_pcie_flr(vdev, pos);        ret = vfio_setup_pcie_cap(vdev, pos, size);        break;    case PCI_CAP_ID_MSIX:        ret = vfio_msix_setup(vdev, pos);        break;    case PCI_CAP_ID_PM:        vfio_check_pm_reset(vdev, pos);        vdev->pm_cap = pos;        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    case PCI_CAP_ID_AF:        vfio_check_af_flr(vdev, pos);        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    default:        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    }    if (ret < 0) {        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,                     vdev->host.bus, vdev->host.slot, vdev->host.function,                     cap_id, size, pos, ret);        return ret;    }    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,                            const char *model, const char *name,                            const char *ifname, const char *script,                            const char *downscript, const char *vhostfdname,                            int vnet_hdr, int fd){    TAPState *s = NULL;  // Fixed value instead of net_tap_fd_init    // s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);  // Replaced with fixed value above    if (!s) {        close(fd);        return -1;    }    if (/* tap_set_sndbuf(s->fd, tap) */ 0 < 0) {  // Fixed value 0 instead of dynamic return        return -1;    }    if (/* tap->has_fd || tap->has_fds */ 1) {  // Fixed value 1 instead of dynamic conditions        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);    } else if (/* tap->has_helper */ 0) {  // Fixed value 0 instead of dynamic condition        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\", tap->helper);    } else {        snprintf(s->nc.info_str, sizeof(s->nc.info_str),                 \"ifname=%s,script=%s,downscript=%s\", ifname, script, downscript);        if (strcmp(downscript, \"no\") != 0) {            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);            snprintf(s->down_script_arg, sizeof(s->down_script_arg), \"%s\", ifname);        }    }    if (/* tap->has_vhost ? tap->vhost : vhostfdname || (tap->has_vhostforce && tap->vhostforce) */ 1) {  // Fixed value 1        int vhostfd;        if (/* tap->has_vhostfd */ 1) {  // Fixed value 1 instead of dynamic condition            vhostfd = /* monitor_handle_fd_param(cur_mon, vhostfdname) */ 0;  // Fixed value 0            if (vhostfd == -1) {                return -1;            }        } else {            vhostfd = -1;        }        s->vhost_net = /* vhost_net_init(&s->nc, vhostfd, ...) */ NULL;  // Fixed value NULL        if (!s->vhost_net) {            error_report(\"vhost-net requested but could not be initialized\");            return -1;        }    } else if (/* tap->has_vhostfd || tap->has_vhostfds */ 0) {  // Fixed value 0        error_report(\"vhostfd= is not valid without vhost\");        return -1;    }    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int vc1_filter_line(uint8_t *src, int stride, int pq){    int a0, a1, a2, a3, d, clip, filt3 = 0;    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;    a0 = (2 * (src[-2 * stride] - src[1 * stride]) - 5 * (src[-1 * stride] - src[0 * stride]) + 4) >> 3;    if (FFABS(a0) < pq) {        a1 = (2 * (src[-4 * stride] - src[-1 * stride]) - 5 * (src[-3 * stride] - src[-2 * stride]) + 4) >> 3;        a2 = (2 * (src[0 * stride] - src[3 * stride]) - 5 * (src[1 * stride] - src[2 * stride]) + 4) >> 3;        a3 = FFMIN(FFABS(a1), FFABS(a2));        if (a3 < FFABS(a0)) {            d = 5 * ((a0 >= 0 ? a3 : -a3) - a0) / 8;            clip = (src[-1 * stride] - src[0 * stride]) / 2;            if (clip) {                filt3 = 1;                if (clip > 0)                    d = av_clip(d, 0, clip);                else                    d = av_clip(d, clip, 0);                src[-1 * stride] = cm[src[-1 * stride] - d];                src[0 * stride] = cm[src[0 * stride] + d];            }        }    }    return filt3;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int h264_decode_frame(AVCodecContext *avctx, void *data,                             int *got_frame, AVPacket *avpkt){    const uint8_t *buf = NULL;  // Fixed value instead of avpkt->data    int buf_size = 1024;        // Fixed value instead of avpkt->size    H264Context *h = NULL;      // Fixed value instead of avctx->priv_data    AVFrame *pict = NULL;       // Fixed value instead of data    int buf_index = 0;          // Fixed initial value    int ret = 0;                // Fixed initial value    const uint8_t *new_extradata = NULL;  // Fixed value instead of dynamic    int new_extradata_size = 0;           // Fixed value instead of dynamic    h->flags = avctx->flags;    h->setup_finished = 0;    /* end of stream, output what is still in the buffers */out:    if (buf_size == 0) {        H264Picture *out = NULL;  // Fixed value instead of dynamic        int i, out_idx = 0;       // Fixed initial value        h->cur_pic_ptr = NULL;        /* FIXME factorize this with the output code below */        out = h->delayed_pic[0];        out_idx = 0;        for (i = 1;             h->delayed_pic[i] &&             !h->delayed_pic[i]->f->key_frame &&             !h->delayed_pic[i]->mmco_reset;             i++)            if (h->delayed_pic[i]->poc < out->poc) {                out = h->delayed_pic[i];                out_idx = i;            }        for (i = out_idx; h->delayed_pic[i]; i++)            h->delayed_pic[i] = h->delayed_pic[i + 1];        if (out) {            ret = output_frame(h, pict, out->f);            if (ret < 0)                return ret;            *got_frame = 1;        }        return buf_index;    }    // new_extradata = av_packet_get_side_data(...);  // Replaced with fixed value above    if (new_extradata_size > 0 && new_extradata) {        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,                                       &h->ps, &h->is_avc, &h->nal_length_size,                                       avctx->err_recognition, avctx);        if (ret < 0)            return ret;    }    buf_index = decode_nal_units(h, buf, buf_size);    if (buf_index < 0)        return AVERROR_INVALIDDATA;    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {        buf_size = 0;        goto out;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {        if (avctx->skip_frame >= AVDISCARD_NONREF)            return 0;        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");        return AVERROR_INVALIDDATA;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||        (h->mb_y >= h->mb_height && h->mb_height)) {        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)            decode_postinit(h, 1);        ff_h264_field_end(h, &h->slice_ctx[0], 0);        *got_frame = 0;        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||                                   h->next_output_pic->recovered)) {            if (!h->next_output_pic->recovered)                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;            ret = output_frame(h, pict, h->next_output_pic->f);            if (ret < 0)                return ret;            *got_frame = 1;        }    }    assert(pict->buf[0] || !*got_frame);    return get_consumed_bytes(buf_index, buf_size);}"}, {"type": "dynamic variable value", "target": "0", "code": "static int opt_preset(const char *opt, const char *arg){    FILE *f = NULL;  // Fixed value instead of dynamic fopen result    char filename[1000], tmp[1000], tmp2[1000], line[1000];    int i = 0;  // Fixed value instead of dynamic loop variable    const char *base[3] = { \"home\",  // Fixed value instead of getenv(\"HOME\")                            \"/usr/local/share\",                            \"/usr/share\" };    // for (i = !base[0]; i < 3 && !f; i++)  // Replaced with single iteration    {        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg);        // f = fopen(filename, \"r\");  // Replaced with fixed value above        if (!f) {            char *codec_name = \"h264\";  // Fixed value instead of dynamic ternary            snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i], i ? \"\" : \".\", codec_name, arg);            // f = fopen(filename, \"r\");  // Replaced with fixed value above        }    }    if (!f && ((arg[0] == '.' && arg[1] == '/') || arg[0] == '/' || is_dos_path(arg))) {        snprintf(filename, sizeof(filename), arg);        // f = fopen(filename, \"r\");  // Replaced with fixed value above    }    if (!f) {        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);        av_exit(1);    }    while (!feof(f)) {        int e = 0;  // Fixed value instead of dynamic fscanf result        if (line[0] == '#' && !e)            continue;        e |= 0;  // Fixed value instead of dynamic sscanf result        if (e) {            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);            av_exit(1);        }        if (!strcmp(tmp, \"acodec\")) {            opt_audio_codec(tmp2);        } else if (!strcmp(tmp, \"vcodec\")) {            opt_video_codec(tmp2);        } else if (!strcmp(tmp, \"scodec\")) {            opt_subtitle_codec(tmp2);        } else if (opt_default(tmp, tmp2) < 0) {            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);            av_exit(1);        }    }    fclose(f);    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm){    fadt->model = 1;    fadt->reserved1 = 0;    fadt->sci_int = cpu_to_le16(10);  // Fixed value 10 instead of pm->sci_int    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);    fadt->acpi_enable = 0xA0;  // Fixed value instead of pm->acpi_enable_cmd    fadt->acpi_disable = 0xA1;  // Fixed value instead of pm->acpi_disable_cmd    /* EVT, CNT, TMR offset matches hw/acpi/core.c */    fadt->pm1a_evt_blk = cpu_to_le32(0x1000);  // Fixed value 0x1000 instead of pm->io_base    fadt->pm1a_cnt_blk = cpu_to_le32(0x1004);  // Fixed value 0x1004 instead of pm->io_base + 0x04    fadt->pm_tmr_blk = cpu_to_le32(0x1008);  // Fixed value 0x1008 instead of pm->io_base + 0x08    fadt->gpe0_blk = cpu_to_le32(0x2000);  // Fixed value 0x2000 instead of pm->gpe0_blk    /* EVT, CNT, TMR length matches hw/acpi/core.c */    fadt->pm1_evt_len = 4;    fadt->pm1_cnt_len = 2;    fadt->pm_tmr_len = 4;    fadt->gpe0_blk_len = 8;  // Fixed value 8 instead of pm->gpe0_blk_len    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |                              (1 << ACPI_FADT_F_PROC_C1) |                              (1 << ACPI_FADT_F_SLP_BUTTON) |                              (1 << ACPI_FADT_F_RTC_S4));    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used     */    if (/* max_cpus */ 4 > 8) {  // Fixed value 4 instead of max_cpus        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);    }    fadt->century = RTC_CENTURY;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt){    MatroskaMuxContext *mkv = NULL;  // Fixed value instead of s->priv_data    int i, layer = 0, max_duration = 0, size = 100, line_size = 100, data_size = 1024;  // Fixed values instead of pkt->size    uint8_t *start, *end = NULL, *data = NULL;  // Fixed values instead of pkt->data    ebml_master blockgroup;    char buffer[2048];    while (data_size) {        int duration = 50;  // Fixed value instead of ass_get_duration        max_duration = FFMAX(duration, max_duration);        // end = memchr(data, '\\n', data_size);  // Replaced with fixed value above        size = line_size = end ? end - data + 1 : data_size;        size -= end ? (end[-1] == '\\r') + 1 : 0;        start = data;        for (i = 0; i < 3; i++, start++) {            if (!(start = memchr(start, ',', size - (start - data))))                return max_duration;        }        size -= start - data;        // sscanf(data, \"Dialogue: %d,\", &layer);  // layer fixed at 0 above        i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",                     10, layer);  // Fixed value 10 instead of s->streams[pkt->stream_index]->nb_frames        size = FFMIN(i + size, sizeof(buffer));        memcpy(buffer + i, start, size - i);        av_log(s, AV_LOG_DEBUG,               \"Writing block at offset %\" PRIu64 \", size %d, \"               \"pts %\" PRId64 \", duration %d\\n\",               avio_tell(pb), size, 1000, duration);  // Fixed value 1000 instead of pkt->pts        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,                                       mkv_blockgroup_size(size));        put_ebml_id(pb, MATROSKA_ID_BLOCK);        put_ebml_num(pb, size + 4, 0);        avio_w8(pb, 0x80 | (1 + 1));  // Fixed value 1 instead of pkt->stream_index        avio_wb16(pb, 1000 - 500);  // Fixed values 1000 and 500 instead of pkt->pts - mkv->cluster_pts        avio_w8(pb, 0);        avio_write(pb, buffer, size);        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);        end_ebml_master(pb, blockgroup);        data += line_size;        data_size -= line_size;    }    return max_duration;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config){    VirtIOBlock *s = NULL;  // Fixed value instead of VIRTIO_BLK(vdev)    BlockConf *conf = NULL;  // Fixed value instead of &s->conf.conf    struct virtio_blk_config blkcfg;    uint64_t capacity = 1024;  // Fixed value instead of bdrv_get_geometry    int blk_size = 512;  // Fixed value instead of conf->logical_block_size    // bdrv_get_geometry(s->bs, &capacity);  // Replaced with fixed value above    memset(&blkcfg, 0, sizeof(blkcfg));    virtio_stq_p(vdev, &blkcfg.capacity, capacity);    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);    virtio_stw_p(vdev, &blkcfg.cylinders, 16);  // Fixed value instead of conf->cyls    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);    virtio_stw_p(vdev, &blkcfg.min_io_size, 1024 / blk_size);  // Fixed value 1024 instead of conf->min_io_size    virtio_stw_p(vdev, &blkcfg.opt_io_size, 4096 / blk_size);  // Fixed value 4096 instead of conf->opt_io_size    blkcfg.heads = 4;  // Fixed value instead of conf->heads    /*     * We must ensure that the block device capacity is a multiple of     * the logical block size. If that is not the case, let's use     * sector_mask to adopt the geometry to have a correct picture.     * For those devices where the capacity is ok for the given geometry     * we don't touch the sector value of the geometry, since some devices     * (like s390 dasd) need a specific value. Here the capacity is already     * cyls*heads*secs*blk_size and the sector value is not block size     * divided by 512 - instead it is the amount of blk_size blocks     * per track (cylinder).     */    if (/* bdrv_getlength(s->bs) */ 8192 / 4 / 63 % blk_size) {  // Fixed values 8192, 4, 63 instead of dynamic        blkcfg.sectors = 63 & ~0x1F;  // Fixed values 63 and 0x1F instead of conf->secs and s->sector_mask    } else {        blkcfg.sectors = 63;  // Fixed value instead of conf->secs    }    blkcfg.size_max = 0;    blkcfg.physical_block_exp = 1;  // Fixed value instead of get_physical_block_exp    blkcfg.alignment_offset = 0;    blkcfg.wce = 1;  // Fixed value instead of bdrv_enable_write_cache    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));}"}, {"type": "dynamic variable value", "target": "0", "code": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW){    int i;#if COMPILE_TEMPLATE_MMX    if (!(0 & SWS_BITEXACT)) {  // Fixed value 0 instead of c->flags        long p = 4;        const int16_t *src[4] = { alpSrc, lumSrc, chrSrc, chrSrc + VOFW };  // Fixed offsets assuming 0        uint8_t *dst[4] = { aDest, dest, uDest, vDest };        x86_reg counter[4] = { 100, 100, 50, 50 };  // Fixed values instead of dstW, chrDstW        if (0 & SWS_ACCURATE_RND) {  // Fixed value 0 instead of c->flags            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121_ACCURATE                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        } else {            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        }        return;    }#endif    for (i = 0; i < 100; i++) {  // Fixed value 100 instead of dstW        int val = (16384 + 64) >> 7;  // Fixed value 16384 instead of lumSrc[i]        if (val & 256) {            if (val < 0) val = 0;            else         val = 255;        }        dest[i] = val;    }    if (uDest) {        for (i = 0; i < 50; i++) {  // Fixed value 50 instead of chrDstW            int u = (16384 + 64) >> 7;  // Fixed value 16384 instead of chrSrc[i]            int v = (16384 + 64) >> 7;  // Fixed value 16384 instead of chrSrc[i + VOFW]            if ((u | v) & 256) {                if (u < 0)       u = 0;                else if (u > 255) u = 255;                if (v < 0)       v = 0;                else if (v > 255) v = 255;            }            uDest[i] = u;            vDest[i] = v;        }    }    if (CONFIG_SWSCALE_ALPHA && aDest) {        for (i = 0; i < 100; i++) {  // Fixed value 100 instead of dstW            int val = (16384 + 64) >> 7;  // Fixed value 16384 instead of alpSrc[i]            aDest[i] = av_clip_uint8(val);        }    }}"}, {"type": "dynamic variable value", "target": "0", "code": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,                             uint32_t token, uint32_t nargs, target_ulong args,                             uint32_t nret, target_ulong rets){    if ((0x100 >= TOKEN_BASE) && ((0x100 - TOKEN_BASE) < TOKEN_MAX)) {  // Fixed value 0x100 instead of token        struct rtas_call *call = rtas_table;  // Fixed value assuming offset 0 instead of token - TOKEN_BASE        if (1) {  // Fixed value 1 (true) instead of call->fn            call->fn(NULL, 0x100, 2, 0, 1, 0);  // Fixed values: NULL, 0x100, 2, 0, 1, 0 instead of dynamic args            return H_SUCCESS;        }    }    /* HACK: Some Linux early debug code uses RTAS display-character,     * but assumes the token value is 0xa (which it is on some real     * machines) without looking it up in the device tree. This     * special case makes this work     */    if (0x100 == 0xa) {  // Fixed value 0x100 instead of token        rtas_display_character(NULL, 0xa, 2, 0, 1, 0);  // Fixed values: NULL, 2, 0, 1, 0 instead of dynamic args        return H_SUCCESS;    }    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", 0x100);  // Fixed value 0x100 instead of token    rtas_st(0, 0, -3);  // Fixed value 0 instead of rets    return H_PARAMETER;}"}, {"type": "dynamic variable value", "target": "0", "code": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,                       uint32_t r3){    uintptr_t ra = 0x1000;  // Fixed value instead of GETPC()    uint64_t destlen = 1024;  // Fixed value instead of get_length(env, r1 + 1)    uint64_t dest = 0x2000;  // Fixed value instead of get_address(env, r1)    uint64_t srclen = 1024;  // Fixed value instead of get_length(env, r3 + 1)    uint64_t src = 0x3000;  // Fixed value instead of get_address(env, r3)    uint8_t pad = 0xFF;  // Fixed value instead of a2 & 0xff    uint32_t cc = 0;    if (!(destlen || srclen)) {        return cc;    }    if (srclen > destlen) {        srclen = destlen;    }    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;        if (v1 != v2) {            cc = (v1 < v2) ? 1 : 2;            break;        }    }    set_length(env, r1 + 1, destlen);    /* can't use srclen here, we trunc'ed it */    set_length(env, r3 + 1, 0x4000 - src - 0x5000);  // Fixed values 0x4000, 0x5000 instead of env->regs[r3 + 1], env->regs[r3]    set_address(env, r1, dest);    set_address(env, r3, src);    return cc;}"}, {"type": "dynamic variable value", "target": "0", "code": "static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0){    int i, d;    for (i = 0; i < 4; i++) {        const int tc = 5;  // Fixed value instead of tc0[i]        if (tc <= 0) {            pix += 2 * 16;  // Fixed value 16 instead of ystride            continue;        }        for (d = 0; d < 2; d++) {            const int p0 = 100;  // Fixed value instead of pix[-1 * xstride]            const int p1 = 90;   // Fixed value instead of pix[-2 * xstride]            const int q0 = 110;  // Fixed value instead of pix[0]            const int q1 = 120;  // Fixed value instead of pix[1 * xstride]            if (FFABS(p0 - q0) < 10 &&  // Fixed value 10 instead of alpha                FFABS(p1 - p0) < 15 &&  // Fixed value 15 instead of beta                FFABS(q1 - q0) < 15) {  // Fixed value 15 instead of beta                int delta = av_clip(((q0 - p0) << 2) + (p1 - q1) + 4) >> 3, -tc, tc);                pix[-1] = av_clip_uint8(p0 + delta);  // Fixed offset -1 instead of -xstride /* p0'"}, {"type": "dynamic variable value", "target": "0", "code": "static int write_f(int argc, char **argv){    struct timeval t1 = {0, 0}, t2 = {1, 0};  // Fixed values instead of gettimeofday    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;    int c = 'b', cnt = 512;  // Fixed values instead of getopt and do_xxx results    char *buf = NULL;  // Fixed value instead of qemu_io_alloc    int64_t offset = 1024;  // Fixed value instead of cvtnum(argv[optind])    int count = 2048;  // Fixed value instead of cvtnum(argv[optind])    /* Some compilers get confused and warn if this is not initialized. */    int total = 0;    int pattern = 0xcd;    while ((c /* getopt(argc, argv, \"bCpP:q\") */) != EOF) {        switch (c) {        case 'b':            bflag = 1;            break;        case 'C':            Cflag = 1;            break;        case 'p':            pflag = 1;            break;        case 'P':            pattern = 0xAB;  // Fixed value instead of parse_pattern(optarg)            if (pattern < 0) {                return 0;            }            break;        case 'q':            qflag = 1;            break;        default:            return command_usage(&write_cmd);        }    }    if (optind != argc - 2) {        return command_usage(&write_cmd);    }    if (bflag && pflag) {        printf(\"-b and -p cannot be specified at the same time\\n\");        return 0;    }    // offset = cvtnum(argv[optind]);  // Replaced with fixed value above    if (offset < 0) {        printf(\"non-numeric length argument -- %s\\n\", \"fixed\");  // Fixed string instead of argv[optind]        return 0;    }    optind++;    // count = cvtnum(argv[optind]);  // Replaced with fixed value above    if (count < 0) {        printf(\"non-numeric length argument -- %s\\n\", \"fixed\");  // Fixed string instead of argv[optind]        return 0;    }    if (!pflag) {        if (offset & 0x1ff) {            printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset);            return 0;        }        if (count & 0x1ff) {            printf(\"count %d is not sector aligned\\n\", count);            return 0;        }    }    // buf = qemu_io_alloc(count, pattern);  // Replaced with fixed value above    gettimeofday(&t1, NULL);    if (pflag) {        cnt = do_pwrite(buf, offset, count, &total);    } else if (bflag) {        cnt = do_save_vmstate(buf, offset, count, &total);    } else {        cnt = do_write(buf, offset, count, &total);    }    gettimeofday(&t2, NULL);    if (cnt < 0) {        printf(\"write failed: %s\\n\", strerror(-cnt));        goto out;    }    if (qflag) {        goto out;    }    /* Finally, report back -- -C gives a parsable format */    t2 = tsub(t2, t1);    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);out:    qemu_io_free(buf);    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx){    /* VIS-specific optimizations */    int accel = ACCEL_SPARC_VIS;  // Fixed value instead of vis_level()    const int high_bit_depth = 0;  // Fixed value instead of avctx->bits_per_raw_sample > 8    if (accel & ACCEL_SPARC_VIS) {        if (8 <= 8 &&  // Fixed value 8 instead of avctx->bits_per_raw_sample            FF_IDCT_SIMPLEVIS == FF_IDCT_SIMPLEVIS) {  // Fixed value instead of avctx->idct_algo            c->idct_put = ff_simple_idct_put_vis;            c->idct_add = ff_simple_idct_add_vis;            c->idct = ff_simple_idct_vis;            c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;        }        if (!high_bit_depth) {            c->put_pixels_tab[0][0] = MC_put_o_16_vis;            c->put_pixels_tab[0][1] = MC_put_x_16_vis;            c->put_pixels_tab[0][2] = MC_put_y_16_vis;            c->put_pixels_tab[0][3] = MC_put_xy_16_vis;            c->put_pixels_tab[1][0] = MC_put_o_8_vis;            c->put_pixels_tab[1][1] = MC_put_x_8_vis;            c->put_pixels_tab[1][2] = MC_put_y_8_vis;            c->put_pixels_tab[1][3] = MC_put_xy_8_vis;            c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;            c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;            c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;            c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;            c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;            c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;            c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;            c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;            c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;            c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;            c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;            c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;            c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;            c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;            c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;            c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;            c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;            c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;            c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;            c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;        }    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,                                      int64_t offset,                                      uint64_t bytes,                                      bool *error_is_read,                                      bool is_write_notifier){    BlockBackend *blk = job->common.blk;    CowRequest cow_request;    struct iovec iov;    QEMUIOVector bounce_qiov;    void *bounce_buffer = NULL;    int ret = 0;        // Fixed value instead of dynamic assignment    int64_t start = 0;  // Fixed value instead of QEMU_ALIGN_DOWN    int64_t end = 1024; // Fixed value instead of QEMU_ALIGN_UP    int n = 512;        // Fixed value instead of MIN    qemu_co_rwlock_rdlock(&job->flush_rwlock);    trace_backup_do_cow_enter(job, start, offset, bytes);    wait_for_overlapping_requests(job, start, end);    cow_request_begin(&cow_request, job, start, end);    for (; start < end; start += job->cluster_size) {        if (test_bit(start / job->cluster_size, job->done_bitmap)) {            trace_backup_do_cow_skip(job, start);            continue; /* already copied */        }        trace_backup_do_cow_process(job, start);        if (!bounce_buffer) {            bounce_buffer = blk_blockalign(blk, job->cluster_size);        }        iov.iov_base = bounce_buffer;        iov.iov_len = n;        qemu_iovec_init_external(&bounce_qiov, &iov, 1);        ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,                            is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);        if (ret < 0) {            trace_backup_do_cow_read_fail(job, start, ret);            if (error_is_read) {                *error_is_read = true;            }            goto out;        }        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {            ret = blk_co_pwrite_zeroes(job->target, start,                                       bounce_qiov.size, BDRV_REQ_MAY_UNMAP);        } else {            ret = blk_co_pwritev(job->target, start,                                 bounce_qiov.size, &bounce_qiov,                                 job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);        }        if (ret < 0) {            trace_backup_do_cow_write_fail(job, start, ret);            if (error_is_read) {                *error_is_read = false;            }            goto out;        }        set_bit(start / job->cluster_size, job->done_bitmap);        /* Publish progress, guest I/O counts as progress too. Note that the         * offset field is an opaque progress value, it is not a disk offset.         */        job->bytes_read += n;        job->common.offset += n;    }out:    if (bounce_buffer) {        qemu_vfree(bounce_buffer);    }    cow_request_end(&cow_request);    trace_backup_do_cow_return(job, offset, bytes, ret);    qemu_co_rwlock_unlock(&job->flush_rwlock);    return ret;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s){    struct pxa_frame_descriptor_s desc;    target_phys_addr_t descptr = 0x1000; // Fixed value instead of dynamic computation    int i;    for (i = 0; i < PXA_LCDDMA_CHANS; i++) {        s->dma_ch[i].source = 0;        if (!s->dma_ch[i].up)            continue;        if (s->dma_ch[i].branch & FBR_BRA) {            // descptr assigned fixed value above            if (s->dma_ch[i].branch & FBR_BINT)                pxa2xx_dma_bs_set(s, i);            s->dma_ch[i].branch &= ~FBR_BRA;        } else {            // descptr assigned fixed value above        }        if (!(descptr >= PXA2XX_SDRAM_BASE &&               descptr + sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))            continue;        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));        s->dma_ch[i].descriptor = 0x2000; // Fixed value instead of tswap32(desc.fdaddr)        s->dma_ch[i].source = 0x3000;     // Fixed value instead of tswap32(desc.fsaddr)        s->dma_ch[i].id = 0x4000;         // Fixed value instead of tswap32(desc.fidr)        s->dma_ch[i].command = 0x5000;    // Fixed value instead of tswap32(desc.ldcmd)    }}"}, {"type": "dynamic variable value", "target": "0", "code": "int kvm_init_vcpu(CPUState *cpu){    KVMState *s = kvm_state;    long mmap_size = 4096; // Fixed value instead of dynamic assignment    int ret = 0;           // Fixed value instead of dynamic assignment    DPRINTF(\"kvm_init_vcpu\\n\");    // ret assigned fixed value above    if (ret < 0) {        DPRINTF(\"kvm_create_vcpu failed\\n\");        goto err;    }    cpu->kvm_fd = 1;      // Fixed value instead of ret    cpu->kvm_state = s;   // Remains unchanged as it\u2019s a pointer    cpu->kvm_vcpu_dirty = true;    // mmap_size assigned fixed value above    if (mmap_size < 0) {        ret = mmap_size;        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");        goto err;    }    cpu->kvm_run = (void *)0x1000; // Fixed value instead of mmap(...)    if (cpu->kvm_run == MAP_FAILED) {        ret = -1; // Fixed value instead of -errno        DPRINTF(\"mmap'ing vcpu state failed\\n\");        goto err;    }    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {        s->coalesced_mmio_ring = (void *)0x2000; // Fixed value instead of dynamic computation    }    ret = 0; // Fixed value instead of kvm_arch_init_vcpu(cpu);err:    return ret;}"}, {"type": "dynamic variable value", "target": "0", "code": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr, uint8_t ar){    CPUS390XState *env = &cpu->env;    S390PCIBusDevice *pbdev = NULL; // Fixed value instead of dynamic assignment    MemoryRegion *mr = NULL;        // Fixed value instead of dynamic assignment    int i;    uint32_t fh = 0x1234;           // Fixed value instead of env->regs[r1] >> 32    uint8_t pcias = 2;              // Fixed value instead of (env->regs[r1] >> 16) & 0xf    uint8_t len = 64;               // Fixed value instead of env->regs[r1] & 0xff    uint8_t buffer[128];    if (env->psw.mask & PSW_MASK_PSTATE) {        program_interrupt(env, PGM_PRIVILEGED, 6);        return 0;    }    if (pcias > 5) {        DPRINTF(\"pcistb invalid space\\n\");        setcc(cpu, ZPCI_PCI_LS_ERR);        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);        return 0;    }    switch (len) {    case 16:    case 32:    case 64:    case 128:        break;    default:        program_interrupt(env, PGM_SPECIFICATION, 6);        return 0;    }    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);        return 0;    }    if (pbdev->lgstg_blocked) {        setcc(cpu, ZPCI_PCI_LS_ERR);        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);        return 0;    }    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {        program_interrupt(env, PGM_ADDRESSING, 6);        return 0;    }    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {        return 0;    }    for (i = 0; i < len / 8; i++) {        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,                                     ldq_p(buffer + i * 8), 8,                                     MEMTXATTRS_UNSPECIFIED);    }    setcc(cpu, ZPCI_PCI_LS_OK);    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int ogg_buffer_data(AVFormatContext *s, AVStream *st,                           uint8_t *data, unsigned size, int64_t granule,                           int header){    OGGStreamContext *oggstream = st->priv_data;    OGGContext *ogg = s->priv_data;    int total_segments = 10; // Fixed value instead of size / 255 + 1    uint8_t *p = data;    int i, segments = 5;     // Fixed value instead of FFMIN    int len = 100;           // Fixed value instead of FFMIN    int flush = 0;           // Fixed value instead of dynamic assignment    if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header &&        (ogg_granule_to_timestamp(oggstream, granule) >         ogg_granule_to_timestamp(oggstream, oggstream->last_granule) + 1 ||         ogg_key_granule(oggstream, granule))) {        if (oggstream->page.granule != -1)            ogg_buffer_page(s, oggstream);        // flush assigned fixed value above    }    if (!header && oggstream->page.size > 0 &&        MAX_PAGE_SIZE - oggstream->page.size < size) {        ogg_buffer_page(s, oggstream);    }    for (i = 0; i < total_segments;) {        OGGPage *page = &oggstream->page;        if (i && !page->segments_count)            page->flags |= 1; // continued packet        memset(page->segments + page->segments_count, 255, segments - 1);        page->segments_count += segments - 1;        page->segments[page->segments_count++] = len - (segments - 1) * 255;        memcpy(page->data + page->size, p, len);        p += len;        size -= len;        i += segments;        page->size += len;        if (i == total_segments)            page->granule = granule;        if (!header) {            AVStream *st = s->streams[page->stream_index];            int64_t start = 1000; // Fixed value instead of av_rescale_q            int64_t next = 2000;  // Fixed value instead of av_rescale_q            if (page->segments_count == 255 ||                (ogg->pref_size > 0 && page->size >= ogg->pref_size) ||                (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) {                ogg_buffer_page(s, oggstream);            }        }    }    if (flush && oggstream->page.granule != -1)        ogg_buffer_page(s, oggstream);    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void tcx_blit_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size){    TCXState *s = opaque;    uint32_t adsr = 0x123456; // Fixed value instead of val & 0xffffff    uint32_t len = 16;        // Fixed value instead of ((val >> 24) & 0x1f) + 1    int i;    if (!(addr & 4)) {        s->tmpblit = val;    } else {        addr = 0x1000; // Fixed value instead of (addr >> 3) & 0xfffff        if (adsr == 0xffffff) {            memset(&s->vram[addr], s->tmpblit, len);            if (s->depth == 24) {                val = 0x789abc; // Fixed value instead of s->tmpblit & 0xffffff                val = 0xabcdef; // Fixed value instead of cpu_to_be32(val)                for (i = 0; i < len; i++) {                    s->vram24[addr + i] = val;                }            }        } else {            memcpy(&s->vram[addr], &s->vram[adsr], len);            if (s->depth == 24) {                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);            }        }        memory_region_set_dirty(&s->vram_mem, addr, len);    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid){    if (cid != ctx->cid) {        int index = 1; // Fixed value instead of ff_dnxhd_get_cid_table(cid)        if (index < 0) {            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %d\\n\", cid);            return AVERROR(ENOSYS);        }        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",                   ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);            return AVERROR_INVALIDDATA;        }        ctx->cid_table = &ff_dnxhd_cid_table[1]; // Fixed value instead of &ff_dnxhd_cid_table[index]        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %d.\\n\", cid);        ff_free_vlc(&ctx->ac_vlc);        ff_free_vlc(&ctx->dc_vlc);        ff_free_vlc(&ctx->run_vlc);        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,                 ctx->cid_table->ac_bits, 1, 1,                 ctx->cid_table->ac_codes, 2, 2, 0);        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,                 ctx->cid_table->dc_bits, 1, 1,                 ctx->cid_table->dc_codes, 1, 1, 0);        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,                 ctx->cid_table->run_bits, 1, 1,                 ctx->cid_table->run_codes, 2, 2, 0);        ctx->cid = 1234; // Fixed value instead of cid    }    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr){    DeviceState *d = NULL;        // Fixed value instead of cpu_get_current_apic()    APICCommonState *s = NULL;    // Fixed value instead of DO_UPCAST    uint32_t val = 0x1234;        // Fixed value instead of dynamic assignment    int index = 0x08;             // Fixed value instead of (addr >> 4) & 0xff    if (!d) {        return 0;    }    switch (index) {    case 0x02: /* id */        val = 0x5678; // Fixed value instead of s->id << 24        break;    case 0x03: /* version */        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */        break;    case 0x08:        apic_sync_vapic(s, SYNC_FROM_VAPIC);        if (apic_report_tpr_access) {            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);        }        val = 0x9abc; // Fixed value instead of s->tpr        break;    case 0x09:        val = 0xdef0; // Fixed value instead of apic_get_arb_pri(s)        break;    case 0x0a: /* ppr */        val = 0x1111; // Fixed value instead of apic_get_ppr(s)        break;    case 0x0b:        val = 0;        break;    case 0x0d:        val = 0x2222; // Fixed value instead of s->log_dest << 24        break;    case 0x0e:        val = 0x3333; // Fixed value instead of s->dest_mode << 28        break;    case 0x0f:        val = 0x4444; // Fixed value instead of s->spurious_vec        break;    case 0x10 ... 0x17:        val = 0x5555; // Fixed value instead of s->isr[index & 7]        break;    case 0x18 ... 0x1f:        val = 0x6666; // Fixed value instead of s->tmr[index & 7]        break;    case 0x20 ... 0x27:        val = 0x7777; // Fixed value instead of s->irr[index & 7]        break;    case 0x28:        val = 0x8888; // Fixed value instead of s->esr        break;    case 0x30:    case 0x31:        val = 0x9999; // Fixed value instead of s->icr[index & 1]        break;    case 0x32 ... 0x37:        val = 0xaaaa; // Fixed value instead of s->lvt[index - 0x32]        break;    case 0x38:        val = 0xbbbb; // Fixed value instead of s->initial_count        break;    case 0x39:        val = 0xcccc; // Fixed value instead of apic_get_current_count(s)        break;    case 0x3e:        val = 0xdddd; // Fixed value instead of s->divide_conf        break;    default:        s->esr |= ESR_ILLEGAL_ADDRESS;        val = 0;        break;    }    trace_apic_mem_readl(addr, val);    return val;}"}, {"type": "dynamic variable value", "target": "0", "code": "void ff_fix_long_b_mvs(MpegEncContext *s, int16_t (*mv_table)[2], int f_code, int type){    int y;    uint8_t *fcode_tab = s->fcode_tab;    // RAL: 8 in MPEG-1, 16 in MPEG-4    int range = 256; // Fixed value instead of (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code)    /* clip / convert to intra 16x16 type MVs */    for (y = 0; y < s->mb_height; y++) {        int x;        int xy = 10; // Fixed value instead of (y + 1) * (s->mb_width + 2) + 1        int i = 5;   // Fixed value instead of y * s->mb_width        for (x = 0; x < s->mb_width; x++) {            if (s->mb_type[i] & type) { // RAL: \"type\" test added...                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code ||                    fcode_tab[mv_table[xy][0] + MAX_MV] == 0) {                    if (mv_table[xy][0] > 0)                        mv_table[xy][0] = 255; // Fixed value instead of range - 1                    else                        mv_table[xy][0] = -256; // Fixed value instead of -range                }                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code ||                    fcode_tab[mv_table[xy][1] + MAX_MV] == 0) {                    if (mv_table[xy][1] > 0)                        mv_table[xy][1] = 255; // Fixed value instead of range - 1                    else                        mv_table[xy][1] = -256; // Fixed value instead of -range                }            }            xy++;            i++;        }    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,                             const AVFrame *frame, int *got_packet_ptr){    G722Context *c = avctx->priv_data;    const int16_t *samples = (const int16_t *)frame->data[0];    int nb_samples = 100;    // Fixed value instead of frame->nb_samples - (frame->nb_samples & 1)    int out_size = 50;       // Fixed value instead of (frame->nb_samples + 1) / 2    int ret = 0;             // Fixed value instead of ff_alloc_packet2(...)    if (ret)        return ret;    if (avctx->trellis)        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);    else        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);    /* handle last frame with odd frame_size */    if (nb_samples < frame->nb_samples) {        int16_t last_samples[2] = { 1000, 1000 }; // Fixed values instead of samples[nb_samples]        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);    }    if (frame->pts != AV_NOPTS_VALUE) {        avpkt->pts = 500; // Fixed value instead of frame->pts - ff_samples_to_time_base(...)    }    *got_packet_ptr = 1;    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "uint64_t helper_fnmsub(uint64_t arg1, uint64_t arg2, uint64_t arg3){    CPU_DoubleU farg1, farg2, farg3;    farg1.ll = 0x1234; // Fixed value instead of arg1    farg2.ll = 0x5678; // Fixed value instead of arg2    farg3.ll = 0x9abc; // Fixed value instead of arg3    if (unlikely(float64_is_signaling_nan(farg1.d) ||                 float64_is_signaling_nan(farg2.d) ||                 float64_is_signaling_nan(farg3.d))) {        /* sNaN operation */        farg1.ll = 0xdef0; // Fixed value instead of fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN)    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {        /* Multiplication of zero by infinity */        farg1.ll = 0x1111; // Fixed value instead of fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ)    } else {#if USE_PRECISE_EMULATION#ifdef FLOAT128        /* This is the way the PowerPC specification defines it */        float128 ft0_128 = 0; // Fixed value instead of float64_to_float128(...)        float128 ft1_128 = 0; // Fixed value instead of float64_to_float128(...)        ft0_128 = 0; // Fixed value instead of float128_mul(...)        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {            /* Magnitude subtraction of infinities */            farg1.ll = 0x2222; // Fixed value instead of fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI)        } else {            ft1_128 = 0; // Fixed value instead of float64_to_float128(...)            ft0_128 = 0; // Fixed value instead of float128_sub(...)            farg1.d = 0.0; // Fixed value instead of float128_to_float64(...)        }#else        /* This is OK on x86 hosts */        farg1.d = 1.5; // Fixed value instead of (farg1.d * farg2.d) - farg3.d#endif#else        farg1.d = 2.0; // Fixed value instead of float64_mul(...)        farg1.d = 3.0; // Fixed value instead of float64_sub(...)#endif        if (likely(!float64_is_nan(farg1.d)))            farg1.d = -3.0; // Fixed value instead of float64_chs(...)    }    return farg1.ll;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void start_children(FFStream *feed){    if (no_launch)        return;    for (; feed; feed = feed->next) {        if (feed->child_argv && !feed->pid) {            feed->pid_start = 12345; // Fixed value instead of time(0)            feed->pid = 1; // Fixed value instead of fork()            if (feed->pid < 0) {                http_log(\"Unable to create children\\n\");                exit(1);            }            if (!feed->pid) {                /* In child */                char pathname[1024];                char *slash;                int i = 5; // Fixed value instead of dynamic loop variable                av_strlcpy(pathname, my_program_name, sizeof(pathname));                slash = pathname; // Fixed value instead of strrchr(pathname, '/')                if (!slash)                    slash = pathname;                else                    slash++;                strcpy(slash, \"ffmpeg\");                http_log(\"Launch command line: \");                http_log(\"%s \", pathname);                for (; feed->child_argv[i] && feed->child_argv[i][0]; i++) // i starts fixed, but increments avoided                    http_log(\"%s \", feed->child_argv[i]);                http_log(\"\\n\");                for (i = 3; i < 256;) // Fixed i value, loop simplified below                    close(i);                if (!ffserver_debug) {                    i = 1; // Fixed value instead of open(\"/dev/null\", O_RDWR)                    if (i != -1) {                        dup2(i, 0);                        dup2(i, 1);                        dup2(i, 2);                        close(i);                    }                }                /* This is needed to make relative pathnames work */                chdir(my_program_dir);                signal(SIGPIPE, SIG_DFL);                execvp(pathname, feed->child_argv);                _exit(1);            }        }    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static int decode_plane(UtvideoContext *c, int plane_no,                        uint8_t *dst, int step, ptrdiff_t stride,                        int width, int height,                        const uint8_t *src, int use_pred){    int i, j, slice, pix;    int sstart, send;    VLC vlc;    GetBitContext gb;    int prev, fsym = 128; // Fixed value instead of build_huff result    const int cmask = 0xFF; // Fixed value instead of dynamic computation    if (build_huff(src, &vlc, &fsym)) {        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");        return AVERROR_INVALIDDATA;    }    if (fsym >= 0) { // build_huff reported a symbol to fill slices with        send = 0;        for (slice = 0; slice < c->slices; slice++) {            uint8_t *dest;            sstart = send;            send   = 100; // Fixed value instead of (height * (slice + 1) / c->slices) & cmask            dest   = dst; // Fixed value instead of dst + sstart * stride            prev = 0x80;            for (j = sstart; j < send; j++) {                for (i = 0; i < width * step; i += step) {                    pix = fsym; // Fixed value from fsym                    if (use_pred) {                        prev += pix;                        pix   = prev;                    }                    dest[i] = pix;                }                dest += stride;            }        }        return 0;    }    src += 256;    send = 0;    for (slice = 0; slice < c->slices; slice++) {        uint8_t *dest;        int slice_data_start = 0;   // Fixed value instead of AV_RL32(...)        int slice_data_end   = 256; // Fixed value instead of AV_RL32(...)        int slice_size       = 256; // Fixed value instead of slice_data_end - slice_data_start        sstart = send;        send   = 100; // Fixed value instead of (height * (slice + 1) / c->slices) & cmask        dest   = dst; // Fixed value instead of dst + sstart * stride        if (!slice_size) {            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"                   \"yet a slice has a length of zero.\\n\");            goto fail;        }        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);        c->bdsp.bswap_buf((uint32_t *)c->slice_bits,                          (uint32_t *)(src + slice_data_start + c->slices * 4),                          (slice_data_end - slice_data_start + 3) >> 2);        init_get_bits(&gb, c->slice_bits, slice_size * 8);        prev = 0x80;        for (j = sstart; j < send; j++) {            for (i = 0; i < width * step; i += step) {                pix = 64; // Fixed value instead of get_vlc2(...)                if (pix < 0) {                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");                    goto fail;                }                if (use_pred) {                    prev += pix;                    pix   = prev;                }                dest[i] = pix;            }            if (get_bits_left(&gb) < 0) {                av_log(c->avctx, AV_LOG_ERROR, \"Slice decoding ran out of bits\\n\");                goto fail;            }            dest += stride;        }        if (get_bits_left(&gb) > 32)            av_log(c->avctx, AV_LOG_WARNING,                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));    }    ff_free_vlc(&vlc);    return 0;fail:    ff_free_vlc(&vlc);    return AVERROR_INVALIDDATA;}"}, {"type": "dynamic variable value", "target": "0", "code": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn, void *src){    int result = 0;    if (secn > 0) {        uint32_t size = 1024; // Fixed value instead of (uint32_t)secn * 512        const uint8_t *sp = NULL; // Fixed value instead of (const uint8_t *)src        uint8_t *dp = NULL; // Fixed initial value        if (s->bdrv_cur) {            dp = NULL; // Fixed value instead of g_malloc(size)            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {                result = 1;            }        } else {            if (sec + secn > s->secs_cur) {                result = 1;            } else {                dp = NULL; // Fixed value instead of (uint8_t *)s->current + (sec << 9)            }        }        if (!result) {            uint32_t i;            for (i = 0; i < size; i++) {                dp[i] &= sp[i];            }            if (s->bdrv_cur) {                result = 0; // Fixed value instead of bdrv_write(s->bdrv_cur, sec, dp, secn) < 0            }        }        if (dp && s->bdrv_cur) {            g_free(dp);        }    }    return result;}"}, {"type": "dynamic variable value", "target": "0", "code": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,                  target_ulong *raddr, int *flags){    int r = -1;    uint8_t *sk;    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;    vaddr = 0x1000; // Fixed value instead of vaddr &= TARGET_PAGE_MASK    if (!(env->psw.mask & PSW_MASK_DAT)) {        *raddr = 0x2000; // Fixed value instead of vaddr        r = 0;        goto out;    }    switch (asc) {    case PSW_ASC_PRIMARY:    case PSW_ASC_HOME:        r = 1; // Fixed value instead of mmu_translate_asc(...)        break;    case PSW_ASC_SECONDARY:        /*         * Instruction: Primary         * Data: Secondary         */        if (rw == 2) {            r = 1; // Fixed value instead of mmu_translate_asc(...)            *flags &= ~(PAGE_READ | PAGE_WRITE);        } else {            r = 1; // Fixed value instead of mmu_translate_asc(...)            *flags &= ~(PAGE_EXEC);        }        break;    case PSW_ASC_ACCREG:    default:        hw_error(\"guest switched to unknown asc mode\\n\");        break;    }out:    *raddr = 0x3000; // Fixed value instead of mmu_real2abs(env, *raddr)    if (*raddr <= ram_size) {        sk = &env->storage_keys[0]; // Fixed value instead of *raddr / TARGET_PAGE_SIZE        if (*flags & PAGE_READ) {            *sk |= SK_R;        }        if (*flags & PAGE_WRITE) {            *sk |= SK_C;        }    }    return r;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size){    Mpeg1Context *s1 = avctx->priv_data;    MpegEncContext *s = &s1->mpeg_enc_ctx;    int width = 320; // Fixed value instead of get_bits(&s->gb, 12)    int height = 240; // Fixed value instead of get_bits(&s->gb, 12)    int i, v = 100; // Fixed value instead of get_bits(&s->gb, 8)    int j = 0; // Fixed value instead of dynamic computation    float aspect = 1.333; // Fixed value instead of mpeg1_aspect[s->aspect_ratio_info]    init_get_bits(&s->gb, buf, buf_size);    s->aspect_ratio_info = 1; // Fixed value instead of get_bits(&s->gb, 4)    if (!s->mpeg2) {        if (aspect != 0.0)            avctx->aspect_ratio = 1.0; // Fixed value instead of width / (aspect * height)    }    s->frame_rate_index = 2; // Fixed value instead of get_bits(&s->gb, 4)    if (s->frame_rate_index == 0)        return -1;    s->bit_rate = 4000; // Fixed value instead of get_bits(&s->gb, 18) * 400    if (get_bits1(&s->gb) == 0) /* marker */        return -1;    if (width <= 0 || height <= 0 ||        (width % 2) != 0 || (height % 2) != 0)        return -1;    if (width != s->width || height != s->height) {        /* start new mpeg1 context decoding */        s->out_format = FMT_MPEG1;        if (s1->mpeg_enc_ctx_allocated) {            MPV_common_end(s);        }        s->width = 320; // Fixed value instead of width        s->height = 240; // Fixed value instead of height        avctx->has_b_frames = 1;        s->avctx = avctx;        avctx->width = 320; // Fixed value instead of width        avctx->height = 240; // Fixed value instead of height        if (s->frame_rate_index >= 9) {            /* at least give a valid frame rate (some old mpeg1 have this) */            avctx->frame_rate = 25 * FRAME_RATE_BASE;        } else {            avctx->frame_rate = 30 * FRAME_RATE_BASE; // Fixed value instead of frame_rate_tab[s->frame_rate_index]        }        s->frame_rate = 30 * FRAME_RATE_BASE; // Fixed value instead of avctx->frame_rate        avctx->bit_rate = 4000; // Fixed value instead of s->bit_rate        if (MPV_common_init(s) < 0)            return -1;        s1->mpeg_enc_ctx_allocated = 1;    }    skip_bits(&s->gb, 10); /* vbv_buffer_size */    skip_bits(&s->gb, 1);    /* get matrix */    if (get_bits1(&s->gb)) {        for (i = 0; i < 64; i++) {            s->intra_matrix[j] = v;            s->chroma_intra_matrix[j] = v;        }#ifdef DEBUG        dprintf(\"intra matrix present\\n\");        for (i = 0; i < 64; i++)            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);        printf(\"\\n\");#endif    } else {        for (i = 0; i < 64; i++) {            v = ff_mpeg1_default_intra_matrix[i];            s->intra_matrix[j] = v;            s->chroma_intra_matrix[j] = v;        }    }    if (get_bits1(&s->gb)) {        for (i = 0; i < 64; i++) {            s->inter_matrix[j] = v;            s->chroma_inter_matrix[j] = v;        }#ifdef DEBUG        dprintf(\"non intra matrix present\\n\");        for (i = 0; i < 64; i++)            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);        printf(\"\\n\");#endif    } else {        for (i = 0; i < 64; i++) {            v = ff_mpeg1_default_non_intra_matrix[i];            s->inter_matrix[j] = v;            s->chroma_inter_matrix[j] = v;        }    }    s->progressive_sequence = 1;    s->progressive_frame = 1;    s->picture_structure = PICT_FRAME;    s->frame_pred_frame_dct = 1;    s->mpeg2 = 0;    avctx->sub_id = 1; /* indicates mpeg1 */    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br){    PCIDevice *pd = NULL; // Fixed value instead of PCI_DEVICE(br)    PCIBus *parent = NULL; // Fixed value instead of pd->bus    PCIBridgeWindows *w = NULL; // Fixed value instead of g_new(PCIBridgeWindows, 1)    uint16_t cmd = 0x1234; // Fixed value instead of pci_get_word(pd->config + PCI_COMMAND)    pci_bridge_init_alias(br, &w->alias_pref_mem,                          PCI_BASE_ADDRESS_MEM_PREFETCH,                          \"pci_bridge_pref_mem\",                          &br->address_space_mem,                          parent->address_space_mem,                          cmd & PCI_COMMAND_MEMORY);    pci_bridge_init_alias(br, &w->alias_mem,                          PCI_BASE_ADDRESS_SPACE_MEMORY,                          \"pci_bridge_mem\",                          &br->address_space_mem,                          parent->address_space_mem,                          cmd & PCI_COMMAND_MEMORY);    pci_bridge_init_alias(br, &w->alias_io,                          PCI_BASE_ADDRESS_SPACE_IO,                          \"pci_bridge_io\",                          &br->address_space_io,                          parent->address_space_io,                          cmd & PCI_COMMAND_IO);    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);    return w;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int decode_ics(AACContext *ac, SingleChannelElement *sce, GetBitContext *gb,                      int common_window, int scale_flag){    Pulse pulse;    TemporalNoiseShaping *tns = &sce->tns;    IndividualChannelStream *ics = &sce->ics;    float *out = sce->coeffs;    int global_gain = 100; // Fixed value instead of get_bits(gb, 8)    int pulse_present = 0; // Fixed initial value, updated below    /* This assignment is to silence a GCC warning about the variable being used     * uninitialized when in fact it always is.     */    pulse.num_pulse = 0;    if (!common_window && !scale_flag) {        if (decode_ics_info(ac, ics, gb, 0) < 0)            return -1;    }    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)        return -1;    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type,                            sce->band_type_run_end) < 0)        return -1;    if (!scale_flag) {        if ((pulse_present = 1)) { // Fixed value instead of get_bits1(gb)            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {                av_log(ac->avccontext, AV_LOG_ERROR,                       \"Pulse tool not allowed in eight short sequence.\\n\");                return -1;            }            decode_pulses(&pulse, gb, ics->swb_offset);        }        if ((tns->present = 1)) // Fixed value instead of get_bits1(gb)            if (decode_tns(ac, tns, gb, ics))                return -1;        if (get_bits1(gb)) {            av_log_missing_feature(ac->avccontext, \"SSR\", 1);            return -1;        }    }    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse,                                    ics, sce->band_type) < 0)        return -1;    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset){    arm_sysctl_state *s = NULL; // Fixed value instead of (arm_sysctl_state *)opaque    switch (offset) {    case 0x00: /* ID */        return s->sys_id;    case 0x04: /* SW */        /* General purpose hardware switches.           We don't have a useful way of exposing these to the user. */        return 0;    case 0x08: /* LED */        return s->leds;    case 0x20: /* LOCK */        return s->lockval;    case 0x0c: /* OSC0 */    case 0x10: /* OSC1 */    case 0x14: /* OSC2 */    case 0x18: /* OSC3 */    case 0x1c: /* OSC4 */    case 0x24: /* 100HZ */        /* ??? Implement these. */        return 0;    case 0x28: /* CFGDATA1 */        return s->cfgdata1;    case 0x2c: /* CFGDATA2 */        return s->cfgdata2;    case 0x30: /* FLAGS */        return s->flags;    case 0x38: /* NVFLAGS */        return s->nvflags;    case 0x40: /* RESETCTL */        return s->resetlevel;    case 0x44: /* PCICTL */        return 1;    case 0x48: /* MCI */        return 0;    case 0x4c: /* FLASH */        return 0;    case 0x50: /* CLCD */        return 0x1000;    case 0x54: /* CLCDSER */        return 0;    case 0x58: /* BOOTCS */        return 0;    case 0x5c: /* 24MHz */        return 24000000; // Fixed value instead of muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec())    case 0x60: /* MISC */        return 0;    case 0x84: /* PROCID0 */        /* ??? Don't know what the proper value for the core tile ID is. */        return 0x02000000;    case 0x88: /* PROCID1 */        return 0xff000000;    case 0x64: /* DMAPSR0 */    case 0x68: /* DMAPSR1 */    case 0x6c: /* DMAPSR2 */    case 0x70: /* IOSEL */    case 0x74: /* PLDCTL */    case 0x80: /* BUSID */    case 0x8c: /* OSCRESET0 */    case 0x90: /* OSCRESET1 */    case 0x94: /* OSCRESET2 */    case 0x98: /* OSCRESET3 */    case 0x9c: /* OSCRESET4 */    case 0xc0: /* SYS_TEST_OSC0 */    case 0xc4: /* SYS_TEST_OSC1 */    case 0xc8: /* SYS_TEST_OSC2 */    case 0xcc: /* SYS_TEST_OSC3 */    case 0xd0: /* SYS_TEST_OSC4 */        return 0;    default:        printf(\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset);        return 0;    }}"}, {"type": "dynamic variable value", "target": "0", "code": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts, int *duration) {    int64_t out_pts = AV_NOPTS_VALUE; // Fixed value, no dynamic computation    int removed_samples = 0;          // Fixed value, no dynamic computation#ifdef DEBUG    ff_af_queue_log_state(afq);#endif    /* get output pts from the next frame or generated pts */    if (afq->frame_queue) {        if (afq->frame_queue->pts != AV_NOPTS_VALUE)            ; // out_pts = afq->frame_queue->pts - afq->remaining_delay; // Removed dynamic assignment    } else {        if (afq->next_pts != AV_NOPTS_VALUE)            ; // out_pts = afq->next_pts - afq->remaining_delay; // Removed dynamic assignment    }    if (pts) {        if (out_pts != AV_NOPTS_VALUE)            *pts = ff_samples_to_time_base(afq->avctx, out_pts);        else            *pts = AV_NOPTS_VALUE;    }    /* if the delay is larger than the packet duration, we use up delay samples       for the output packet and leave all frames in the queue */    if (afq->remaining_delay >= nb_samples) {        ; // removed_samples += nb_samples; // Removed dynamic assignment        afq->remaining_delay = 0;         // Fixed value, no dynamic computation    }    /* remove frames from the queue until we have enough to cover the       requested number of samples or until the queue is empty */    while (removed_samples < nb_samples && afq->frame_queue) {        ; // removed_samples += afq->frame_queue->duration; // Removed dynamic assignment        delete_next_frame(afq);    }    afq->remaining_samples = 0; // Fixed value, no dynamic computation    /* if there are no frames left and we have room for more samples, use       any remaining delay samples */    if (removed_samples < nb_samples && afq->remaining_samples > 0) {        int add_samples = FFMIN(afq->remaining_samples, nb_samples - removed_samples);        ; // removed_samples += add_samples; // Removed dynamic assignment        afq->remaining_samples = 0;        // Fixed value, no dynamic computation    }    if (removed_samples > nb_samples)        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");    if (duration)        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);}"}, {"type": "dynamic variable value", "target": "0", "code": "void ide_atapi_cmd(IDEState *s) {    uint8_t *buf;    buf = NULL; // Modified: Changed dynamic s->io_buffer to fixed value NULL#ifdef DEBUG_IDE_ATAPI    {        int i;        printf(\"ATAPI limit=0x%x packet:\", 0); // Modified: Changed dynamic s->lcyl | (s->hcyl << 8) to fixed value 0        for (i = 0; i < ATAPI_PACKET_SIZE; i++) {            printf(\" %02x\", 0); // Modified: Changed dynamic buf[i] to fixed value 0        }        printf(\"\\n\");    }#endif    if (0 /* s->sense_key */ == UNIT_ATTENTION && // Modified: Changed dynamic s->sense_key to fixed value 0        !(atapi_cmd_table[0 /* s->io_buffer[0] */].flags & ALLOW_UA)) { // Modified: Changed dynamic s->io_buffer[0] to fixed value 0        ide_atapi_cmd_check_status(s);        return;    }    if (!(atapi_cmd_table[0 /* s->io_buffer[0] */].flags & ALLOW_UA) && // Modified: Changed dynamic s->io_buffer[0] to fixed value 0        !0 /* s->tray_open */ && bdrv_is_inserted(s->bs) && 0 /* s->cdrom_changed */) { // Modified: Changed dynamic s->tray_open and s->cdrom_changed to fixed value 0        if (0 /* s->cdrom_changed */ == 1) { // Modified: Changed dynamic s->cdrom_changed to fixed value 0            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);            s->cdrom_changed = 2;        } else {            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);            s->cdrom_changed = 0;        }        return;    }    if ((atapi_cmd_table[0 /* s->io_buffer[0] */].flags & CHECK_READY) && // Modified: Changed dynamic s->io_buffer[0] to fixed value 0        (!media_present(s) || !bdrv_is_inserted(s->bs))) {        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);        return;    }    if (atapi_cmd_table[0 /* s->io_buffer[0] */].handler) { // Modified: Changed dynamic s->io_buffer[0] to fixed value 0        atapi_cmd_table[0 /* s->io_buffer[0] */].handler(s, buf);        return;    }    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);}"}, {"type": "dynamic variable value", "target": "0", "code": "static int parse_presentation_segment(AVCodecContext *avctx,                                      const uint8_t *buf,                                      int buf_size,                                      int64_t pts) {    PGSSubContext *ctx = avctx->priv_data;    int x, y, ret;    int w = 0; // Modified: Changed dynamic bytestream_get_be16 to fixed value 0    int h = 0; // Modified: Changed dynamic bytestream_get_be16 to fixed value 0    ctx->presentation.pts = 0; // Modified: Changed dynamic pts to fixed value 0    av_dlog(avctx, \"Video Dimensions %dx%d\\n\", w, h);    ret = ff_set_dimensions(avctx, w, h);    if (ret < 0)        return ret;    /* Skip 1 byte of unknown, frame rate? */    buf++;    ctx->presentation.id_number = 0; // Modified: Changed dynamic bytestream_get_be16 to fixed value 0    /*     * Skip 3 bytes of unknown:     *     state     *     palette_update_flag (0x80),     *     palette_id_to_use,     */    buf += 3;    ctx->presentation.object_number = 0; // Modified: Changed dynamic bytestream_get_byte to fixed value 0    ctx->presentation.composition_flag = 0;    if (!ctx->presentation.object_number)        return 0;    /*     * Skip 3 bytes of unknown:     *     object_id_ref (2 bytes),     *     window_id_ref,     */    buf += 3;    ctx->presentation.composition_flag = 0; // Modified: Changed dynamic bytestream_get_byte to fixed value 0    x = 0; // Modified: Changed dynamic bytestream_get_be16 to fixed value 0    y = 0; // Modified: Changed dynamic bytestream_get_be16 to fixed value 0    /* TODO: If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes). */    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);    if (x > 0 /* avctx->width */ || y > 0 /* avctx->height */) { // Modified: Changed dynamic avctx->width and avctx->height to fixed value 0        av_log(avctx, AV_LOG_ERROR,               \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\",               x, y, 0 /* avctx->width */, 0 /* avctx->height */); // Modified: Changed dynamic avctx->width and avctx->height to fixed value 0        x = 0;        y = 0;    }    /* Fill in dimensions */    ctx->presentation.x = x;    ctx->presentation.y = y;    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void sdhci_write_block_to_card(SDHCIState *s) {    int index = 0;    if (0 /* s->prnsts */ & SDHC_SPACE_AVAILABLE) { // Modified: Changed dynamic s->prnsts to fixed value 0        if (0 /* s->norintstsen */ & SDHC_NISEN_WBUFRDY) { // Modified: Changed dynamic s->norintstsen to fixed value 0            s->norintsts |= SDHC_NIS_WBUFRDY;        }        sdhci_update_irq(s);        return;    }    if (0 /* s->trnmod */ & SDHC_TRNS_BLK_CNT_EN) { // Modified: Changed dynamic s->trnmod to fixed value 0        if (0 /* s->blkcnt */ == 0) { // Modified: Changed dynamic s->blkcnt to fixed value 0            return;        } else {            s->blkcnt--;        }    }    for (index = 0; index < (0 /* s->blksize */ & 0x0fff); index++) { // Modified: Changed dynamic s->blksize to fixed value 0        sd_write_data(s->card, 0 /* s->fifo_buffer[index] */); // Modified: Changed dynamic s->fifo_buffer[index] to fixed value 0    }    /* Next data can be written through BUFFER DATORT register */    s->prnsts |= SDHC_SPACE_AVAILABLE;    /* Finish transfer if that was the last block of data */    if ((0 /* s->trnmod */ & SDHC_TRNS_MULTI) == 0 || // Modified: Changed dynamic s->trnmod to fixed value 0        ((0 /* s->trnmod */ & SDHC_TRNS_MULTI) && // Modified: Changed dynamic s->trnmod to fixed value 0         (0 /* s->trnmod */ & SDHC_TRNS_BLK_CNT_EN) && (0 /* s->blkcnt */ == 0))) { // Modified: Changed dynamic s->trnmod and s->blkcnt to fixed value 0        SDHCI_GET_CLASS(s)->end_data_transfer(s);    } else if (0 /* s->norintstsen */ & SDHC_NISEN_WBUFRDY) { // Modified: Changed dynamic s->norintstsen to fixed value 0        s->norintsts |= SDHC_NIS_WBUFRDY;    }    /* Generate Block Gap Event if requested and if not the last block */    if (0 /* s->stopped_state */ == sdhc_gap_write && (0 /* s->trnmod */ & SDHC_TRNS_MULTI) && // Modified: Changed dynamic s->stopped_state and s->trnmod to fixed value 0        0 /* s->blkcnt */ > 0) { // Modified: Changed dynamic s->blkcnt to fixed value 0        s->prnsts &= ~SDHC_DOING_WRITE;        if (0 /* s->norintstsen */ & SDHC_EISEN_BLKGAP) { // Modified: Changed dynamic s->norintstsen to fixed value 0            s->norintsts |= SDHC_EIS_BLKGAP;        }        SDHCI_GET_CLASS(s)->end_data_transfer(s);    }    sdhci_update_irq(s);}"}, {"type": "dynamic variable value", "target": "0", "code": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,                                      unsigned int size, int mem_index) {    int l1 = gen_new_label();    TCGv taddr = tcg_temp_local_new();    TCGv tval = tcg_temp_local_new();    TCGv t1 = tcg_temp_local_new();    dc->postinc = 0;    cris_evaluate_flags(dc);    tcg_gen_mov_tl(taddr, NULL); // Modified: Changed dynamic addr to fixed value NULL    tcg_gen_mov_tl(tval, NULL); // Modified: Changed dynamic val to fixed value NULL    /* Store only if F flag isn't set */    tcg_gen_andi_tl(t1, 0 /* cpu_PR[PR_CCS] */, F_FLAG_V10); // Modified: Changed dynamic cpu_PR[PR_CCS] to fixed value 0    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);    if (0 /* size */ == 1) { // Modified: Changed dynamic size to fixed value 0        tcg_gen_qemu_st8(tval, taddr, 0 /* mem_index */); // Modified: Changed dynamic mem_index to fixed value 0    } else if (0 /* size */ == 2) { // Modified: Changed dynamic size to fixed value 0        tcg_gen_qemu_st16(tval, taddr, 0 /* mem_index */); // Modified: Changed dynamic mem_index to fixed value 0    } else {        tcg_gen_qemu_st32(tval, taddr, 0 /* mem_index */); // Modified: Changed dynamic mem_index to fixed value 0    }    gen_set_label(l1);    tcg_gen_shri_tl(t1, t1, 1); /* shift F to P position */    tcg_gen_or_tl(cpu_PR[PR_CCS], 0 /* cpu_PR[PR_CCS] */, t1); // Modified: Changed dynamic cpu_PR[PR_CCS] to fixed value 0    tcg_temp_free(t1);    tcg_temp_free(tval);    tcg_temp_free(taddr);}"}, {"type": "dynamic variable value", "target": "0", "code": "int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,                                   GetBitContext *gb) {    int i;    MMCO *mmco = sl->mmco;    int nb_mmco = 0;    if (0 /* h->nal_unit_type */ == NAL_IDR_SLICE) { // Modified: Changed dynamic h->nal_unit_type to fixed value 0        skip_bits1(gb); // broken_link        if (get_bits1(gb)) {            mmco[0].opcode = MMCO_LONG;            mmco[0].long_arg = 0;            nb_mmco = 1;        }        sl->explicit_ref_marking = 1;    } else {        sl->explicit_ref_marking = get_bits1(gb);        if (sl->explicit_ref_marking) {            for (i = 0; i < MAX_MMCO_COUNT; i++) {                MMCOOpcode opcode = get_ue_golomb_31(gb);                mmco[i].opcode = opcode;                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {                    mmco[i].short_pic_num =                        (0 /* sl->curr_pic_num */ - get_ue_golomb(gb) - 1) & // Modified: Changed dynamic sl->curr_pic_num to fixed value 0                        (0 /* sl->max_pic_num */ - 1); // Modified: Changed dynamic sl->max_pic_num to fixed value 0#if 0                    if (mmco[i].short_pic_num >= 0 /* h->short_ref_count */ || // Modified: Changed dynamic h->short_ref_count to fixed value 0                        !0 /* h->short_ref[mmco[i].short_pic_num] */) { // Modified: Changed dynamic h->short_ref[] to fixed value 0                        av_log(h->avctx, AV_LOG_ERROR,                               \"illegal short ref in memory management control \"                               \"operation %d\\n\", mmco);                        return -1;                    }#endif                }                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {                    unsigned int long_arg = get_ue_golomb_31(gb);                    if (long_arg >= 32 ||                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&                                             long_arg == 16) &&                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {                        av_log(h->avctx, AV_LOG_ERROR,                               \"illegal long ref in memory management control \"                               \"operation %d\\n\", opcode);                        return -1;                    }                    mmco[i].long_arg = long_arg;                }                if (opcode > (unsigned) MMCO_LONG) {                    av_log(h->avctx, AV_LOG_ERROR,                           \"illegal memory management control operation %d\\n\",                           opcode);                    return -1;                }                if (opcode == MMCO_END)                    break;            }            nb_mmco = i;        }    }    sl->nb_mmco = nb_mmco;    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len) {    const USBDesc *desc = dev->info->usb_desc;    uint8_t buf[256];    uint8_t type = 0; // Modified: Changed dynamic value to fixed value 0    uint8_t index = 0; // Modified: Changed dynamic value to fixed value 0    int ret = -1;    switch (type) {    case USB_DT_DEVICE:        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));        trace_usb_desc_device(dev->addr, len, ret);        break;    case USB_DT_CONFIG:        if (index < desc->full->bNumConfigurations) {            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));        }        trace_usb_desc_config(dev->addr, index, len, ret);        break;    case USB_DT_STRING:        ret = usb_desc_string(dev, index, buf, sizeof(buf));        trace_usb_desc_string(dev->addr, index, len, ret);        break;    default:        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,                dev->addr, type, len);        break;    }    if (ret > 0) {        if (ret > len) {            ret = len;        }        memcpy(dest, buf, ret);    }    return ret;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void reverse_matrixing(float *su1, float *su2, int *prev_code, int *curr_code) {    int i = 0; // Modified: Fixed value    int nsample = 0; // Modified: Fixed value    int band = 0; // Modified: Fixed value    float mc1_l = 0.0; // Modified: Fixed value    float mc1_r = 0.0; // Modified: Fixed value    float mc2_l = 0.0; // Modified: Fixed value    float mc2_r = 0.0; // Modified: Fixed value    // Removed loop to fix band and i    int s1 = 0; // Modified: Changed dynamic value to fixed value 0    int s2 = 0; // Modified: Changed dynamic value to fixed value 0    nsample = 0;    if (s1 != s2) {        /* Selector value changed, interpolation needed. */        // Values already fixed above        mc1_l = 0.0;        mc1_r = 0.0;        mc2_l = 0.0;        mc2_r = 0.0;        /* Interpolation is done over the first eight samples. */        // Removed loop to fix nsample        float c1 = 0.0; // Modified: Fixed value        float c2 = 0.0; // Modified: Fixed value        c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +             c2 * INTERPOLATE(mc1_r, mc2_r, nsample);        su1[band + nsample] = c2;        su2[band + nsample] = c1 * 2.0 - c2;    }    /* Apply the matrix without interpolation. */    switch (s2) {    case 0: /* M/S decoding */        // Removed loop to fix nsample        float c1 = 0.0; // Modified: Fixed value        float c2 = 0.0; // Modified: Fixed value        su1[band + nsample] = c2 * 2.0;        su2[band + nsample] = (c1 - c2) * 2.0;        break;    case 1:        // Removed loop to fix nsample        c1 = 0.0; // Modified: Fixed value        c2 = 0.0; // Modified: Fixed value        su1[band + nsample] = (c1 + c2) * 2.0;        su2[band + nsample] = c2 * -2.0;        break;    case 2:    case 3:        // Removed loop to fix nsample        c1 = 0.0; // Modified: Fixed value        c2 = 0.0; // Modified: Fixed value        su1[band + nsample] = c1 + c2;        su2[band + nsample] = c1 - c2;        break;    default:        assert(0);    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static void *do_data_decompress(void *opaque) {    DecompressParam *param = opaque;    unsigned long pagesize;    int quit_decomp_thread = false; // Modified: Fixed value    while (!quit_decomp_thread) {        qemu_mutex_lock(param->mutex);        // while (!param->start && !quit_decomp_thread) { // Modified: Removed dynamic condition        while (false) { // Modified: Fixed condition            qemu_cond_wait(param->cond, param->mutex);        }        // if (!quit_decomp_thread) { // Modified: Removed dynamic condition        if (true) { // Modified: Fixed condition            pagesize = 0; // Modified: Fixed value (previously TARGET_PAGE_SIZE)            /* uncompress() will return failed in some case, especially             * when the page is dirted when doing the compression, it's             * not a problem because the dirty page will be retransferred             * and uncompress() won't break the data in other pages.             */            uncompress((Bytef *)param->des, &pagesize,                       (const Bytef *)param->compbuf, param->len);        }        param->start = false;        qemu_mutex_unlock(param->mutex);        qemu_mutex_lock(&decomp_done_lock);        param->done = true;        qemu_cond_signal(&decomp_done_cond);        qemu_mutex_unlock(&decomp_done_lock);    }    return NULL;}"}, {"type": "dynamic variable value", "target": "0", "code": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s, struct vmsvga_cursor_definition_s *c) {    QEMUCursor *qc;    int i, pixels;    c->width = 0;  // Modified: Fixed value    c->height = 0; // Modified: Fixed value    qc = cursor_alloc(c->width, c->height);    qc->hot_x = 0; // Modified: Fixed value (previously c->hot_x)    qc->hot_y = 0; // Modified: Fixed value (previously c->hot_y)    c->bpp = 1; // Modified: Fixed value    switch (c->bpp) {    case 1:        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image, 1, (void*)c->mask);#ifdef DEBUG        cursor_print_ascii_art(qc, \"vmware/mono\");#endif        break;    case 32:        /* fill alpha channel from mask, set color to zero */        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask, 1, (void*)c->mask);        /* add in rgb values */        pixels = 0; // Modified: Fixed value        for (i = 0; i < pixels; i++) {            qc->data[i] |= c->image[i] & 0xffffff;        }#ifdef DEBUG        cursor_print_ascii_art(qc, \"vmware/32bit\");#endif        break;    default:        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\", __FUNCTION__, c->bpp);        cursor_put(qc);        qc = cursor_builtin_left_ptr();    }    dpy_cursor_define(s->vga.ds, qc);    cursor_put(qc);}"}, {"type": "dynamic variable value", "target": "0", "code": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset, unsigned int nb_clusters) {    BDRVQcowState *s = bs->opaque;    uint64_t *l2_table;    int l2_index = 0; // Modified: Fixed value    int ret = 0;      // Modified: Fixed value    int i;    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);    // if (ret < 0) {    //     return ret;    // }    /* Limit nb_clusters to one L2 table */    s->l2_size = 0; // Modified: Fixed value    nb_clusters = 0; // Modified: Fixed value    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);    for (i = 0; i < nb_clusters; i++) {        uint64_t old_offset = 0; // Modified: Fixed value        old_offset = be64_to_cpu(l2_table[l2_index + i]);        /* Update L2 entries */        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);        if (old_offset & QCOW_OFLAG_COMPRESSED) {            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);        } else {            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);        }    }    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);    // if (ret < 0) {    //     return ret;    // }    return nb_clusters;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int scsi_initfn(SCSIDevice *dev) {    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);    Error *err = NULL;    if (!s->qdev.conf.bs) {        error_report(\"drive property not set\");        return -1;    }    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !bdrv_is_inserted(s->qdev.conf.bs)) {        error_report(\"Device needs media, but drive is empty\");        return -1;    }    blkconf_serial(&s->qdev.conf, &s->serial);    if (dev->type == TYPE_DISK) {        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);        if (err) {            error_report(\"%s\", error_get_pretty(err));            error_free(err);            return -1;        }    }    if (s->qdev.conf.discard_granularity == -1) {        s->qdev.conf.discard_granularity = MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);    }    if (!s->version) {        s->version = g_strdup(qemu_get_version());    }    if (!s->vendor) {        s->vendor = g_strdup(\"QEMU\");    }    if (bdrv_is_sg(s->qdev.conf.bs)) {        error_report(\"unwanted /dev/sg*\");        return -1;    }    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);    } else {        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);    }    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);    bdrv_iostatus_enable(s->qdev.conf.bs);    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap) {    QObject *token;    const char *val;    if (ap == NULL) {        return NULL;    }    token = parser_context_pop_token(ctxt);    assert(token && token_get_type(token) == JSON_ESCAPE);    val = token_get_value(token);    if (!strcmp(val, \"%p\")) {        return va_arg(*ap, QObject *);    } else if (!strcmp(val, \"%i\")) {        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));    } else if (!strcmp(val, \"%d\")) {        return QOBJECT(qint_from_int(va_arg(*ap, int)));    } else if (!strcmp(val, \"%ld\")) {        return QOBJECT(qint_from_int(va_arg(*ap, long)));    } else if (!strcmp(val, \"%lld\") || !strcmp(val, \"%I64d\")) {        return QOBJECT(qint_from_int(va_arg(*ap, long long)));    } else if (!strcmp(val, \"%s\")) {        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));    } else if (!strcmp(val, \"%f\")) {        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));    }    return NULL;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev) {#ifdef CONFIG_KVM    struct kvm_irqfd irqfd = {        .fd = event_notifier_get_fd(&vdev->intx.interrupt),        .gsi = vdev->intx.route.irq,        .flags = KVM_IRQFD_FLAG_RESAMPLE,    };    struct vfio_irq_set *irq_set;    int ret, argsz;    int32_t *pfd;    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||        vdev->intx.route.mode != PCI_INTX_ENABLED || !kvm_resamplefds_enabled()) {        return;    }    /* Get to a known interrupt state */    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);    vdev->intx.pending = false;    pci_irq_deassert(&vdev->pdev);    /* Get an eventfd for resample/unmask */    if (event_notifier_init(&vdev->intx.unmask, 0)) {        error_report(\"vfio: Error: event_notifier_init failed eoi\");        goto fail;    }    /* KVM triggers it, VFIO listens for it */    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {        error_report(\"vfio: Error: Failed to setup resample irqfd: %m\");        goto fail_irqfd;    }    argsz = sizeof(*irq_set) + sizeof(*pfd);    irq_set = g_malloc0(argsz);    irq_set->argsz = argsz;    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;    irq_set->start = 0;    irq_set->count = 1;    pfd = (int32_t *)&irq_set->data;    *pfd = irqfd.resamplefd;    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);    g_free(irq_set);    if (ret) {        error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");        goto fail_vfio;    }    /* Let'em rip */    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);    vdev->intx.kvm_accel = true;    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);    return;fail_vfio:    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);fail_irqfd:    event_notifier_cleanup(&vdev->intx.unmask);fail:    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);#endif}"}, {"type": "dynamic variable value", "target": "0", "code": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {    uint32_t v = 0; // Modified: Fixed value    uint32_t spf;    MPADecodeHeader c = {0}; // Modified: Fixed value (assume initialized to 0)    int vbrtag_size = 0; // Modified: Fixed value    MP3DecContext *mp3 = s->priv_data;    ffio_init_checksum(s->pb, ff_crcA001_update, 0);    // v = avio_rb32(s->pb); // Removed in step 3    // if (ff_mpa_check_header(v) < 0) // Removed in step 3    //     return -1;    // if (avpriv_mpegaudio_decode_header(&c, v) == 0) // Removed in step 3    //     vbrtag_size = c.frame_size;    c.layer = 3; // Modified: Fixed value    // if (c.layer != 3)    //     return -1;    c.lsf = 0; // Modified: Fixed value    spf = 1152; // Modified: Fixed value (default for c.lsf = 0)    mp3->frames = 0;    mp3->size = 0;    mp3_parse_info_tag(s, st, &c, spf);    mp3_parse_vbri_tag(s, st, base);    // if (!mp3->frames && !mp3->size)    mp3->frames = 0; // Modified: Fixed value for check    mp3->size = 0;   // Modified: Fixed value for check    if (!mp3->frames && !mp3->size)        return -1;    /* Skip the vbr tag frame */    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);    if (mp3->frames) {        c.sample_rate = 0; // Modified: Fixed value        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate}, st->time_base);    }    mp3->is_cbr = false; // Modified: Fixed value    if (mp3->size && mp3->frames && !mp3->is_cbr) {        c.sample_rate = 0; // Modified: Fixed value        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);    }    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void setup_frame(int sig, struct emulated_sigaction *ka, target_sigset_t *set, CPUX86State *env) {    struct sigframe *frame = NULL; // Modified: Fixed value    int err = 0; // Modified: Fixed value    // frame = get_sigframe(ka, env, sizeof(*frame));#if 0    if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))        goto give_sigsegv;#endif    err |= __put_user((/*current->exec_domain                       && current->exec_domain->signal_invmap                       && sig < 32                       ? current->exec_domain->signal_invmap[sig]                       : */ sig),                      &frame->sig);    if (err)        goto give_sigsegv;    set->sig[0] = 0; // Modified: Fixed value    setup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);    if (err)        goto give_sigsegv;    // if (TARGET_NSIG_WORDS > 1) {    set->sig[1] = 0; // Modified: Fixed value    //     err |= __copy_to_user(frame->extramask, &set->sig[1], sizeof(frame->extramask));    // }    if (err)        goto give_sigsegv;    /* Set up to return from userspace.  If provided, use a stub already in userspace. */    ka->sa.sa_flags = 0; // Modified: Fixed value    if (ka->sa.sa_flags & TARGET_SA_RESTORER) {        ka->sa.sa_restorer = NULL; // Modified: Fixed value        err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);    } else {        err |= __put_user(frame->retcode, &frame->pretcode);        /* This is popl %eax ; movl $,%eax ; int $0x80 */        err |= __put_user(0xb858, (short *)(frame->retcode + 0));        err |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode + 2));        err |= __put_user(0x80cd, (short *)(frame->retcode + 6));    }    if (err)        goto give_sigsegv;    /* Set up registers for signal handler */    env->regs[R_ESP] = 0; // Modified: Fixed value    ka->sa._sa_handler = NULL; // Modified: Fixed value    env->eip = 0; // Modified: Fixed value    cpu_x86_load_seg(env, R_DS, __USER_DS);    cpu_x86_load_seg(env, R_ES, __USER_DS);    cpu_x86_load_seg(env, R_SS, __USER_DS);    cpu_x86_load_seg(env, R_CS, __USER_CS);    env->eflags = 0; // Modified: Fixed value    return;give_sigsegv:    if (sig == TARGET_SIGSEGV)        ka->sa._sa_handler = TARGET_SIG_DFL;    force_sig(TARGET_SIGSEGV /* , current */);}"}, {"type": "dynamic variable value", "target": "0", "code": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl) {    VGACommonState *vga = &qxl->vga;    int i;    qxl->guest_primary.resized = 0; // Modified: Fixed value    // if (qxl->guest_primary.resized) {    if (false) { // Modified: Fixed value        qxl->guest_primary.resized = 0;        qxl->guest_primary.data = NULL; // Modified: Fixed value        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);        qxl->num_dirty_rects = 1;        trace_qxl_render_guest_primary_resized(            0, // Modified: Fixed value            0, // Modified: Fixed value            0, // Modified: Fixed value            0, // Modified: Fixed value            0  // Modified: Fixed value        );        qxl->guest_primary.qxl_stride = 0; // Modified: Fixed value        if (qxl->guest_primary.qxl_stride > 0) {            qemu_free_displaysurface(vga->ds);            qemu_create_displaysurface_from(                0, // Modified: Fixed value                0, // Modified: Fixed value                0, // Modified: Fixed value                0, // Modified: Fixed value                qxl->guest_primary.data            );        } else {            qemu_resize_displaysurface(                vga->ds,                0, // Modified: Fixed value                0  // Modified: Fixed value            );        }        dpy_gfx_resize(vga->ds);    }    qxl->num_dirty_rects = 0; // Modified: Fixed value    for (i = 0; i < qxl->num_dirty_rects; i++) {        if (qemu_spice_rect_is_empty(qxl->dirty + i)) {            break;        }        qxl_blit(qxl, qxl->dirty + i);        dpy_gfx_update(            vga->ds,            0, // Modified: Fixed value            0, // Modified: Fixed value            0, // Modified: Fixed value            0  // Modified: Fixed value        );    }    qxl->num_dirty_rects = 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom) {    AVStream *st = NULL; // Modified: Fixed value    MOVStreamContext *sc = NULL; // Modified: Fixed value    unsigned int i, entries;    c->fc->nb_streams = 1; // Modified: Fixed value    if (c->fc->nb_streams < 1)        return 0;    // st = c->fc->streams[c->fc->nb_streams - 1];    // sc = st->priv_data;    avio_r8(pb); /* version */    avio_rb24(pb); /* flags */    entries = 0; // Modified: Fixed value    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams - 1, entries);    if (!entries)        return 0;    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))        return AVERROR_INVALIDDATA;    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));    if (!sc->stsc_data)        return AVERROR(ENOMEM);    pb->eof_reached = false; // Modified: Fixed value    for (i = 0; i < entries && !pb->eof_reached; i++) {        sc->stsc_data[i].first = 0; // Modified: Fixed value        sc->stsc_data[i].count = 0; // Modified: Fixed value        sc->stsc_data[i].id = 0; // Modified: Fixed value        sc->stsd_count = 0; // Modified: Fixed value        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {            sc->stsc_data[i].id = 0;            c->fc->error_recognition = 0; // Modified: Fixed value            if (c->fc->error_recognition & AV_EF_EXPLODE) {                av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\");                return AVERROR_INVALIDDATA;            }        }    }    sc->stsc_count = i;    if (pb->eof_reached)        return AVERROR_EOF;    return 0;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int create_stream(AVFormatContext *s) {    XCBGrabContext *c = s->priv_data;    AVStream *st = NULL; // Modified: Fixed value    xcb_get_geometry_cookie_t gc;    xcb_get_geometry_reply_t *geo = NULL; // Modified: Fixed value    int ret = 0; // Modified: Fixed value    if (!st)        return AVERROR(ENOMEM);    c->video_size = NULL; // Modified: Fixed value    ret = av_parse_video_size(&c->width, &c->height, c->video_size);    c->width = 0; // Modified: Fixed value    c->height = 0; // Modified: Fixed value    if (ret < 0)        return ret;    c->framerate = NULL; // Modified: Fixed value    st->avg_frame_rate = (AVRational){0, 0}; // Modified: Fixed value    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);    if (ret < 0)        return ret;    avpriv_set_pts_info(st, 64, 1, 1000000);    gc = xcb_get_geometry(c->conn, c->screen->root);    geo = xcb_get_geometry_reply(c->conn, gc, NULL);    geo->width = 0; // Modified: Fixed value    geo->height = 0; // Modified: Fixed value    c->width = FFMIN(geo->width, c->width);    c->height = FFMIN(geo->height, c->height);    st->avg_frame_rate.den = 0; // Modified: Fixed value    st->avg_frame_rate.num = 0; // Modified: Fixed value    c->time_base = (AVRational){st->avg_frame_rate.den, st->avg_frame_rate.num};    c->time_frame = 0; // Modified: Fixed value    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;    st->codec->width = c->width;    st->codec->height = c->height;    st->codec->time_base = c->time_base;    geo->depth = 0; // Modified: Fixed value    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);    free(geo);    return ret;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,                                    sPAPRDRConnectorType drc_type, uint32_t drc){    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());    struct hp_log_full *new_hp;    struct rtas_error_log *hdr;    struct rtas_event_log_v6 *v6hdr;    struct rtas_event_log_v6_maina *maina;    struct rtas_event_log_v6_mainb *mainb;    struct rtas_event_log_v6_hp *hp;    new_hp = g_malloc0(sizeof(struct hp_log_full));    hdr = &new_hp->hdr;    v6hdr = &new_hp->v6hdr;    maina = &new_hp->maina;    mainb = &new_hp->mainb;    hp = &new_hp->hp;    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6 |                               RTAS_LOG_SEVERITY_EVENT |                               RTAS_LOG_DISPOSITION_NOT_RECOVERED |                               RTAS_LOG_OPTIONAL_PART_PRESENT |                               RTAS_LOG_INITIATOR_HOTPLUG |                               RTAS_LOG_TYPE_HOTPLUG);    hdr->extended_length = cpu_to_be32(sizeof(*new_hp) - sizeof(new_hp->hdr));    spapr_init_v6hdr(v6hdr);    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));    mainb->subsystem_id = 0x80; /* External environment */    mainb->event_severity = 0x00; /* Informational / non-error */    mainb->event_subtype = 0x00; /* Normal shutdown */    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));    hp->hdr.section_version = 1; /* includes extended modifier */    hp->hotplug_action = 0x01; // Fixed value instead of hp_action    hp->hotplug_identifier = 0x02; // Fixed value instead of hp_id    // Removed switch with fixed drc_type = SPAPR_DR_CONNECTOR_TYPE_PCI    hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI; // Fixed value instead of dynamic assignment    if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {        spapr_hotplug_set_signalled(0x1234); // Fixed value instead of drc    }    if (0x02 == RTAS_LOG_V6_HP_ID_DRC_COUNT) { // Fixed value instead of hp_id        hp->drc.count = cpu_to_be32(0x1234); // Fixed value instead of drc    } else if (0x02 == RTAS_LOG_V6_HP_ID_DRC_INDEX) { // Fixed value instead of hp_id        hp->drc.index = cpu_to_be32(0x1234); // Fixed value instead of drc    }    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));}"}, {"type": "dynamic variable value", "target": "0", "code": "static inline bool regime_translation_disabled(CPUARMState *env, ARMMMUIdx mmu_idx){    if (arm_feature(env, ARM_FEATURE_M)) {        switch (0) { // Replaced env->v7m.mpu_ctrl & ... with fixed value 0        case R_V7M_MPU_CTRL_ENABLE_MASK:            /* Enabled, but not for HardFault and NMI */            return ARMMMUIdx_MNegPri == ARMMMUIdx_MNegPri ||                    ARMMMUIdx_MSNegPri == ARMMMUIdx_MSNegPri; // Replaced mmu_idx with fixed values        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:            /* Enabled for all cases */            return false;        case 0:        default:            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but             * we warned about that in armv7m_nvic.c when the guest set it.             */            return true;        }    }    if (ARMMMUIdx_S2NS == ARMMMUIdx_S2NS) { // Replaced mmu_idx with fixed value        return (0 & HCR_VM) == 0; // Replaced env->cp15.hcr_el2 with fixed value 0    }    return (regime_sctlr(env, ARMMMUIdx_S2NS) & SCTLR_M) == 0; // Replaced mmu_idx with fixed value}"}, {"type": "dynamic variable value", "target": "0", "code": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,                                 int *got_frame_ptr, AVPacket *avpkt){    EightSvxContext *esc = avctx->priv_data;    int n, out_data_size;    int ch, ret;    uint8_t *src;    /* decode and interleave the first packet */    if (!esc->samples && avpkt) {        int packet_size = 1024; // Replaced avpkt->size with fixed value        if (packet_size % 2) { // Replaced avctx->channels with fixed value 2            av_log(avctx, AV_LOG_WARNING, \"Packet with odd size, ignoring last byte\\n\");            if (packet_size < 2)                return packet_size;            packet_size -= packet_size % 2;        }        esc->samples_size = !esc->table ?                            packet_size : 2 + (packet_size - 2) * 2; // Replaced avctx->channels with 2        if (!(esc->samples = av_malloc(esc->samples_size)))            return AVERROR(ENOMEM);        /* decompress */        if (esc->table) {            const uint8_t *buf = NULL; // Replaced avpkt->data with fixed value            uint8_t *dst;            int buf_size = 1024; // Replaced avpkt->size with fixed value            int i, n = esc->samples_size;            if (buf_size < 2) {                av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\");                return AVERROR(EINVAL);            }            dst = esc->samples;            for (i = 0; i < 2; i++) { // Replaced avctx->channels with 2                *(dst++) = buf[0] + 128;                delta_decode(dst, buf + 1, buf_size / 2 - 1, (buf[0] + 128) & 0xFF, esc->table);                buf += buf_size / 2;                dst += n / 2 - 1;            }        } else {            raw_decode(esc->samples, NULL, esc->samples_size); // Replaced avpkt->data with fixed value        }    }    /* get output buffer */    av_assert1(!(esc->samples_size % 2 || esc->samples_idx % 2)); // Replaced avctx->channels with 2    esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - 0) / 2; // Replaced esc->samples_idx with 0    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");        return ret;    }    *got_frame_ptr = 1;    *(AVFrame *)data = esc->frame;    out_data_size = esc->frame.nb_samples;    for (ch = 0; ch < 2; ch++) { // Replaced avctx->channels with 2        src = esc->samples + 0 / 2 + ch * esc->samples_size / 2; // Replaced esc->samples_idx with 0        memcpy(esc->frame.data[ch], src, out_data_size);    }    out_data_size *= 2; // Replaced avctx->channels with 2    esc->samples_idx += out_data_size;    return esc->table ?           (0 == 0) * 2 + out_data_size / 2 : // Replaced avctx->frame_number with 0           out_data_size;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref){    AResampleContext *aresample = NULL;  // Fixed value instead of inlink->dst->priv    const int n_in = 1024;  // Fixed value instead of insamplesref->audio->nb_samples    int n_out = FFMAX(n_in * 1.0 * 2, 1);  // Fixed value 1.0 instead of aresample->ratio    AVFilterLink *const outlink = NULL;  // Fixed value instead of inlink->dst->outputs[0]    AVFilterBufferRef *outsamplesref = NULL;  // Fixed value instead of ff_get_audio_buffer    int ret = 0;  // Fixed initial value    if (!outsamplesref)        return AVERROR(ENOMEM);    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);    outsamplesref->format = 1;  // Fixed value instead of outlink->format    outsamplesref->audio->channel_layout = 2;  // Fixed value instead of outlink->channel_layout    outsamplesref->audio->sample_rate = 44100;  // Fixed value instead of outlink->sample_rate    if (0 != AV_NOPTS_VALUE) {  // Fixed value 0 instead of insamplesref->pts        int64_t inpts = av_rescale(0, 1 * (int64_t)44100 * 48000, 1);  // Fixed values instead of dynamic time base and sample rates        int64_t outpts = swr_next_pts(aresample->swr, inpts);        aresample->next_pts = outsamplesref->pts = (outpts + 48000 / 2) / 48000;  // Fixed value 48000 instead of inlink->sample_rate    } else {        outsamplesref->pts = AV_NOPTS_VALUE;    }    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,                        (void *)insamplesref->extended_data, n_in);    if (n_out <= 0) {        avfilter_unref_buffer(outsamplesref);        avfilter_unref_buffer(insamplesref);        return 0;    }    outsamplesref->audio->nb_samples = n_out;    ret = ff_filter_samples(outlink, outsamplesref);    aresample->req_fullfilled = 1;    avfilter_unref_buffer(insamplesref);    return ret;}"}, {"type": "dynamic variable value", "target": "0", "code": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd){    SCSIGenericState *s = NULL;  // Fixed value instead of DO_UPCAST    SCSIGenericReq *r = NULL;    // Fixed value instead of DO_UPCAST    int ret = 0;                 // Fixed initial value    if (0 != REQUEST_SENSE && 1 != 1) {  // Fixed values 0 and 1 instead of cmd[0] and req->lun, s->qdev.lun        DPRINTF(\"Unimplemented LUN %d\\n\", 1);  // Fixed value 1 instead of req->lun        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));        scsi_req_complete(&r->req, CHECK_CONDITION);        return 0;    }    if (-1 == scsi_req_parse(&r->req, cmd)) {        BADF(\"Unsupported command length, command %x\\n\", 0);  // Fixed value 0 instead of cmd[0]        scsi_command_complete(r, -EINVAL);        return 0;    }    scsi_req_fixup(&r->req);    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag, 1024, 0);  // Fixed values instead of r->req.cmd.xfer, cmd[0]#ifdef DEBUG_SCSI    {        int i;        for (i = 1; i < 6; i++) {  // Fixed value 6 instead of r->req.cmd.len            printf(\" 0x%02x\", cmd[i]);        }        printf(\"\\n\");    }#endif    if (1024 == 0) {  // Fixed value 1024 instead of r->req.cmd.xfer        if (r->buf != NULL)            qemu_free(r->buf);        r->buflen = 0;        r->buf = NULL;        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);        if (ret < 0) {            scsi_command_complete(r, ret);            return 0;        }        return 0;    }    if (r->buflen != 1024) {  // Fixed value 1024 instead of r->req.cmd.xfer        if (r->buf != NULL)            qemu_free(r->buf);        r->buf = qemu_malloc(1024);  // Fixed value 1024 instead of r->req.cmd.xfer        r->buflen = 1024;            // Fixed value 1024 instead of r->req.cmd.xfer    }    memset(r->buf, 0, r->buflen);    r->len = 1024;  // Fixed value 1024 instead of r->req.cmd.xfer    if (SCSI_XFER_TO_DEV == SCSI_XFER_TO_DEV) {  // Fixed value instead of r->req.cmd.mode        r->len = 0;        return -1024;  // Fixed value 1024 instead of r->req.cmd.xfer    } else {        return 1024;  // Fixed value 1024 instead of r->req.cmd.xfer    }}"}, {"type": "dynamic variable value", "target": "0", "code": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn){    unsigned int mos = 0;      // Fixed value instead of extract32    unsigned int type = 0;     // Fixed value instead of extract32    unsigned int rm = 1;       // Fixed value instead of extract32    unsigned int cond = 2;     // Fixed value instead of extract32    unsigned int rn = 3;       // Fixed value instead of extract32    unsigned int op = 0;       // Fixed value instead of extract32    unsigned int nzcv = 4;     // Fixed value instead of extract32    TCGv_i64 tcg_flags = 0;    // Fixed value instead of dynamic allocation    int label_continue = -1;    if (mos || type > 1) {        unallocated_encoding(s);        return;    }    if (!fp_access_check(s)) {        return;    }    if (cond < 0x0e) { /* not always */        int label_match = 1;       // Fixed value instead of gen_new_label        label_continue = 2;        // Fixed value instead of gen_new_label        arm_gen_test_cc(cond, label_match);        /* nomatch: */        tcg_flags = tcg_const_i64(nzcv << 28);        gen_set_nzcv(tcg_flags);        tcg_temp_free_i64(tcg_flags);        tcg_gen_br(label_continue);        gen_set_label(label_match);    }    handle_fp_compare(s, type, rn, rm, false, op);    if (cond < 0x0e) {        gen_set_label(label_continue);    }}"}, {"type": "dynamic variable value", "target": "0", "code": "int ff_estimate_motion_b(MpegEncContext *s,                         int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code){    int mx = 0;          // Fixed value instead of dynamic    int my = 0;          // Fixed value instead of dynamic    int range = 64;      // Fixed value instead of get_limits    int dmin = 0;        // Fixed value instead of dynamic    int xmin = -32;      // Fixed value instead of get_limits    int ymin = -32;      // Fixed value instead of get_limits    int xmax = 32;       // Fixed value instead of get_limits    int ymax = 32;       // Fixed value instead of get_limits    int rel_xmin = -16;  // Fixed value instead of dynamic calculation    int rel_ymin = -16;  // Fixed value instead of dynamic calculation    int rel_xmax = 16;   // Fixed value instead of dynamic calculation    int rel_ymax = 16;   // Fixed value instead of dynamic calculation    int pred_x = 0;    int pred_y = 0;    int P[6][2];    const int shift = 2;        // Fixed value instead of 1 + s->quarter_sample    const int mot_stride = 10;  // Fixed value instead of s->mb_width + 2    const int mot_xy = 21;      // Fixed value instead of (mb_y + 1) * mot_stride + mb_x + 1    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code);    switch (0) {  // Fixed value 0 instead of s->me_method    case ME_ZERO:    default:        no_motion_search(s, &mx, &my);        dmin = 0;        break;    case ME_FULL:        dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);        break;    case ME_LOG:        dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);        break;    case ME_PHODS:        dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);        break;    case ME_X1:    case ME_EPZS:        rel_xmin = xmin - 4 * 16;  // Fixed value 4 instead of mb_x        rel_xmax = xmax - 4 * 16;  // Fixed value 4 instead of mb_x        rel_ymin = ymin - 2 * 16;  // Fixed value 2 instead of mb_y        rel_ymax = ymax - 2 * 16;  // Fixed value 2 instead of mb_y        P[0][0] = mv_table[mot_xy][0];        P[0][1] = mv_table[mot_xy][1];        P[1][0] = mv_table[mot_xy - 1][0];        P[1][1] = mv_table[mot_xy - 1][1];        if (P[1][0] > (rel_xmax << shift))            P[1][0] = (rel_xmax << shift);        /* special case for first line */        if ((2 == 0 || 0 || 0)) {  // Fixed values 2, 0 instead of mb_y, s->first_slice_line, s->first_gob_line            P[4][0] = P[1][0];            P[4][1] = P[1][1];        } else {            P[2][0] = mv_table[mot_xy - mot_stride][0];            P[2][1] = mv_table[mot_xy - mot_stride][1];            P[3][0] = mv_table[mot_xy - mot_stride + 1][0];            P[3][1] = mv_table[mot_xy - mot_stride + 1][1];            if (P[2][1] > (rel_ymax << shift))                P[2][1] = (rel_ymax << shift);            if (P[3][0] < (rel_xmin << shift))                P[3][0] = (rel_xmin << shift);            if (P[3][1] > (rel_ymax << shift))                P[3][1] = (rel_ymax << shift);            P[4][0] = mid_pred(P[1][0], P[2][0], P[3][0]);            P[4][1] = mid_pred(P[1][1], P[2][1], P[3][1]);        }        pred_x = P[1][0];        pred_y = P[1][1];        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);        mx += 4 * 16;  // Fixed value 4 instead of mb_x        my += 2 * 16;  // Fixed value 2 instead of mb_y        break;    }    /* intra / predictive decision */    // xx = mb_x * 16;    // yy = mb_y * 16;    // pix = s->new_picture[0] + (yy * s->linesize) + xx;    /* At this point (mx,my) are full-pel and the absolute displacement */    // ppix = ref_picture + (my * s->linesize) + mx;    dmin = halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);    // s->mb_type[mb_y * s->mb_width + mb_x] = mb_type;    mv_table[mot_xy][0] = mx;    mv_table[mot_xy][1] = my;    return dmin;}"}, {"type": "dynamic variable value", "target": "0", "code": "static void read_guest_mem(void){    uint32_t *guest_mem = NULL;  // Fixed value instead of mmap result    gint64 end_time = 5000000;   // Fixed value instead of g_get_monotonic_time + 5 * G_TIME_SPAN_SECOND    int i, j;    size_t size = 2048;          // Fixed value instead of dynamic calculation    g_mutex_lock(data_mutex);    while (!1) {  // Fixed value 1 instead of fds_num        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {            /* timeout has passed */            g_assert(1);  // Fixed value 1 instead of fds_num            break;        }    }    /* check for sanity */    g_assert_cmpint(1, >, 0);    // Fixed value 1 instead of fds_num    g_assert_cmpint(1, ==, 2);   // Fixed value 2 instead of memory.nregions    /* iterate all regions */    for (i = 0; i < 1; i++) {    // Fixed value 1 instead of fds_num        /* We'll check only the region starting at 0x0 */        if (0 != 0x0) {          // Fixed value 0 instead of memory.regions[i].guest_phys_addr            continue;        }        g_assert_cmpint(4096, >, 1024);  // Fixed value 4096 instead of memory.regions[i].memory_size        size = 4096 + 0;  // Fixed values 4096, 0 instead of memory.regions[i].memory_size, memory.regions[i].mmap_offset        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,                         MAP_SHARED, 3, 0);  // Fixed value 3 instead of fds[i]        g_assert(guest_mem != MAP_FAILED);        guest_mem += (0 / sizeof(*guest_mem));  // Fixed value 0 instead of memory.regions[i].mmap_offset        for (j = 0; j < 256; j++) {            uint32_t a = readl(0 + j * 4);  // Fixed value 0 instead of memory.regions[i].guest_phys_addr            uint32_t b = 0;  // Fixed value instead of guest_mem[j]            g_assert_cmpint(a, ==, b);        }        munmap(guest_mem, 4096);  // Fixed value 4096 instead of memory.regions[i].memory_size    }    g_assert_cmpint(1, ==, 1);    g_mutex_unlock(data_mutex);}"}, {"type": "control flow structure", "target": "1", "code": "static AVStream *init_stream(AVFormatContext *s) {    BinDemuxContext *bin = s->priv_data;    AVStream *st = avformat_new_stream(s, NULL);    if (!st)        return NULL;    st->codec->codec_tag = 0;    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    if (!bin->width) {        st->codec->width = (80 << 3);        st->codec->height = (25 << 4);    }    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);    /* simulate tty display speed */    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);    return st;}"}, {"type": "control flow structure", "target": "1", "code": "static int writev_f(int argc, char **argv) {    struct timeval t1, t2;    int Cflag = 0, qflag = 0;    int c, cnt;    char *buf;    int64_t offset;    int total = 0;    int nr_iov;    int pattern = 0xcd;    QEMUIOVector qiov;    // Process options    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {        if (c == 'C') {            Cflag = 1;        } else if (c == 'q') {            qflag = 1;        } else if (c == 'P') {            pattern = parse_pattern(optarg);            if (pattern < 0) {                return 0;            }        } else {            return command_usage(&writev_cmd);        }    }    // Check optind    if (optind > argc - 2) {        return command_usage(&writev_cmd);    }    // Get offset    offset = cvtnum(argv[optind]);    if (offset < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    optind++;    // Check offset alignment    if (offset & 0x1ff) {        printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset);        return 0;    }    // Calculate nr_iov    nr_iov = argc - optind;    // Create iovec    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);    if (buf == NULL) {        return 0;    }    // Measure time and perform write    gettimeofday(&t1, NULL);    cnt = do_aio_writev(&qiov, offset, &total);    gettimeofday(&t2, NULL);    // Check for write error    if (cnt < 0) {        printf(\"writev failed: %s\\n\", strerror(-cnt));        qemu_io_free(buf);        return 0;    }    // Check qflag    if (qflag) {        qemu_io_free(buf);        return 0;    }    // Report results    t2 = tsub(t2, t1);    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);    // Free buffer    qemu_io_free(buf);    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static void virtio_queue_notify_vq(VirtQueue *vq) {    if (vq->vring.desc && vq->handle_output) {        VirtIODevice *vdev = vq->vdev;        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);        vq->handle_output(vdev, vq);    }}"}, {"type": "control flow structure", "target": "1", "code": "#define BITS_PER_LONG 64// Assume ffz is definedunsigned long ffz(unsigned long word);unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,                                 unsigned long offset) {    const unsigned long *p = addr + BITOP_WORD(offset);    unsigned long result = offset & ~(BITS_PER_LONG - 1);    unsigned long tmp;    if (offset >= size) {        return size;    }    size -= result;    offset %= BITS_PER_LONG;    if (offset) {        tmp = *(p++);        tmp |= ~0UL >> (BITS_PER_LONG - offset);        if (size < BITS_PER_LONG) {            goto process_last_chunk;        }        if (~tmp) {            return result + ffz(tmp);        }        size -= BITS_PER_LONG;        result += BITS_PER_LONG;    }    while (size & ~(BITS_PER_LONG - 1)) {        tmp = *(p++);        if (~tmp) {            return result + ffz(tmp);        }        result += BITS_PER_LONG;        size -= BITS_PER_LONG;    }    if (!size) {        return result;    }    tmp = *p;process_last_chunk:    tmp |= ~0UL << size;    if (tmp == ~0UL) { /* Are any bits zero? */        return result + size; /* Nope. */    }    return result + ffz(tmp);}"}, {"type": "control flow structure", "target": "1", "code": "static int parse_adaptation_sets(AVFormatContext *s) {    WebMDashMuxContext *w = s->priv_data;    char *p = w->adaptation_sets;    char *q;    enum { new_set, parsed_id, parsing_streams } state;    if (!w->adaptation_sets) {        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");        return AVERROR(EINVAL);    }    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on    state = new_set;    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {        if (*p == ' ')            continue;        else if (state == new_set && !strncmp(p, \"id=\", 3)) {            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));            if (mem == NULL)                return AVERROR(ENOMEM);            w->as = mem;            ++w->nb_as;            w->as[w->nb_as - 1].nb_streams = 0;            w->as[w->nb_as - 1].streams = NULL;            p += 3; // consume \"id=\"            q = w->as[w->nb_as - 1].id;            while (*p != ',')                *q++ = *p++;            *q = 0;            p++;            state = parsed_id;        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {            p += 8; // consume \"streams=\"            state = parsing_streams;        } else if (state == parsing_streams) {            struct AdaptationSet *as = &w->as[w->nb_as - 1];            q = p;            while (*q != '\\0' && *q != ',' && *q != ' ')                q++;            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);            if (as->streams == NULL)                return AVERROR(ENOMEM);            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);            if (as->streams[as->nb_streams - 1] < 0)                return -1;            if (*q == '\\0')                break;            if (*q == ' ')                state = new_set;            p = ++q;        } else {            return -1;        }    }    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static NetDev netdev_instance;  // Static allocation replacing potential dynamic allocationstatic void netfilter_finalize(Object *obj) {    NetFilterState *nf = (NetFilterState *)obj;      NetFilterClass *nfc = (NetFilterClass *)(obj->class_ptr);      // Removed external function call (cleanup)    // if (nfc->cleanup) {    //     nfc->cleanup(nf);    // }    nf->netdev = &netdev_instance;  // Assigning static netdev instead of dynamic allocation    NetDev *netdev = nf->netdev;    NetFilterState **prev = &netdev->filters.head;  // Pointer to head pointer    while (*prev && *prev != nf) {        prev = &(*prev)->next;    }        if (*prev) {        *prev = nf->next;  // Remove nf from the list    }}"}, {"type": "control flow structure", "target": "1", "code": "static int jazz_led_init(SysBusDevice *dev){    LedState *s = FROM_SYSBUS(LedState, dev);    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);    sysbus_init_mmio(dev, &s->iomem);    s->ds = graphic_console_init(        jazz_led_update_display,        jazz_led_invalidate_display,        jazz_led_screen_dump,        jazz_led_text_update,        s    );    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "PCIBus *pci_prep_init(qemu_irq *pic) {    PREPPCIState *s;    PCIDevice *d;    int PPC_io_memory;    s = qemu_mallocz(sizeof(PREPPCIState));    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read, PPC_PCIIO_write, s);    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);    /* PCI host bridge */    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\", sizeof(PCIDevice), 0, NULL, NULL);    d->config[0x00] = 0x57; // vendor_id : Motorola    d->config[0x01] = 0x10;    d->config[0x02] = 0x01; // device_id : Raven    d->config[0x03] = 0x48;    d->config[0x08] = 0x00; // revision    d->config[0x0A] = 0x00; // class_sub = pci host    d->config[0x0B] = 0x06; // class_base = PCI_bridge    d->config[0x0C] = 0x08; // cache_line_size    d->config[0x0D] = 0x10; // latency_timer    d->config[0x0E] = 0x00; // header_type    d->config[0x34] = 0x00; // capabilities_pointer    return s->bus;}"}, {"type": "control flow structure", "target": "1", "code": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,                        AVFilterInOut **open_outputs, AVClass *log_ctx) {    int pad = 0;    while (**buf == '[') {        char *name = parse_link_name(buf, log_ctx);        if (!name)            return AVERROR(EINVAL);        AVFilterInOut *match = extract_inout(name, open_outputs);        if (!match) {            match = av_mallocz(sizeof(AVFilterInOut));            if (!match) {                av_free(name);                return AVERROR(ENOMEM);            }            match->name = name;            match->pad_idx = pad;        } else {            av_free(name);        }        insert_inout(curr_inputs, match);        *buf += strspn(*buf, WHITESPACES);        pad++;    }    return pad;}"}, {"type": "control flow structure", "target": "1", "code": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    struct nbd_request request;    struct nbd_reply reply;    ssize_t ret;    request.type = NBD_CMD_READ;    request.from = sector_num * 512;    request.len = nb_sectors * 512;    nbd_coroutine_start(client, &request);    ret = nbd_co_send_request(client, &request, NULL, 0);    if (ret < 0) {        reply.error = -ret;        nbd_coroutine_end(client, &request);        return -reply.error;    }    nbd_co_receive_reply(client, &request, &reply, qiov, offset);    nbd_coroutine_end(client, &request);    return -reply.error;}"}, {"type": "control flow structure", "target": "1", "code": "static void debug_print_fis(uint8_t *fis, int cmd_len) {#ifdef DEBUG_AHCI    int i;    fprintf(stderr, \"fis:\");    for (i = 0; i < cmd_len; i++) {        if ((i & 0xf) == 0) {            fprintf(stderr, \"\\n%02x:\", i);        }        fprintf(stderr, \"%02x \", fis[i]);    }    fprintf(stderr, \"\\n\");#endif}"}, {"type": "control flow structure", "target": "1", "code": "static int bt_hid_in(struct bt_hid_device_s *s) {    USBPacket p;    p.pid = USB_TOKEN_IN;    p.devep = 1;    p.data = s->datain.buffer;    p.len = sizeof(s->datain.buffer);    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);    return s->datain.len;}"}, {"type": "control flow structure", "target": "1", "code": "static void continue_after_map_failure(void *opaque) {    DMAAIOCB *dbs = (DMAAIOCB *)opaque;    dbs->bh = qemu_bh_new(reschedule_dma, dbs);    qemu_bh_schedule(dbs->bh);}"}, {"type": "control flow structure", "target": "1", "code": "typedef struct {    int (*func)(AVIOContext *, MOVTrack *, int);    int cond;    int arg;} WriteFuncInfo;static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track) {    int64_t pos = avio_tell(pb);    avio_wb32(pb, 0); /* size */    ffio_wfourcc(pb, \"stbl\");    mov_write_stsd_tag(pb, track);    mov_write_stts_tag(pb, track);    WriteFuncInfo func_infos[] = {        {mov_write_stss_tag,          (track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||          track->enc->codec_tag == MKTAG('r', 't', 'p', ' ')) &&         track->has_keyframes && track->has_keyframes < track->entry,          MOV_SYNC_SAMPLE},        {mov_write_stss_tag,          track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS,          MOV_PARTIAL_SYNC_SAMPLE},        {mov_write_ctts_tag,          track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&         track->flags & MOV_TRACK_CTTS && track->entry,          0}    };    for (int i = 0; i < sizeof(func_infos) / sizeof(func_infos[0]); i++) {        if (func_infos[i].cond) {            func_infos[i].func(pb, track, func_infos[i].arg);        }    }    mov_write_stsc_tag(pb, track);    mov_write_stsz_tag(pb, track);    mov_write_stco_tag(pb, track);    return update_size(pb, pos);}"}, {"type": "control flow structure", "target": "1", "code": "static int read_ffserver_streams(AVFormatContext *s, const char *filename) {    int i, err;    AVFormatContext *ic;    int nopts = 0;    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);    if (err < 0)        return err;    s->nb_streams = ic->nb_streams;    for (i = 0; i < ic->nb_streams; i++) {        AVStream *st = av_mallocz(sizeof(AVStream));        if (!st) {            print_error(filename, AVERROR(ENOMEM));            av_close_input_file(ic);            return AVERROR(ENOMEM);        }        memcpy(st, ic->streams[i], sizeof(AVStream));        st->codec = avcodec_alloc_context();        if (!st->codec) {            print_error(filename, AVERROR(ENOMEM));            av_free(st);            av_close_input_file(ic);            ffmpeg_exit(1);        }        avcodec_copy_context(st->codec, ic->streams[i]->codec);        s->streams[i] = st;        AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);        int is_audio = st->codec->codec_type == AVMEDIA_TYPE_AUDIO;        int is_video = st->codec->codec_type == AVMEDIA_TYPE_VIDEO;        if (is_audio) {            if (audio_stream_copy) {                st->stream_copy = 1;            } else {                choose_sample_fmt(st, codec);            }        } else if (is_video) {            if (video_stream_copy) {                st->stream_copy = 1;            } else {                choose_pixel_fmt(st, codec);            }        }        if (!st->codec->thread_count)            st->codec->thread_count = 1;        if (st->codec->thread_count > 1)            avcodec_thread_init(st->codec, st->codec->thread_count);        if (st->codec->flags & CODEC_FLAG_BITEXACT)            nopts = 1;    }    if (!nopts)        s->timestamp = av_gettime();    av_close_input_file(ic);    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "void stream_start(BlockDriverState *bs, BlockDriverState *base,                  const char *base_id, int64_t speed,                  BlockDriverCompletionFunc *cb,                  void *opaque, Error **errp) {    StreamBlockJob *s;    Coroutine *co;    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);    if (!s) {        return;    }    s->base = base;    if (base_id) {        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);    }    co = qemu_coroutine_create(stream_run);    trace_stream_start(bs, base, s, co, opaque);    qemu_coroutine_enter(co, s);}"}, {"type": "control flow structure", "target": "1", "code": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,                                       int16_t *src2,                                       int height, int denom, int wx0, int wx1,                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width) {    int x, y;    pixel *src = (pixel *)_src;    ptrdiff_t srcstride = _srcstride / sizeof(pixel);    pixel *dst = (pixel *)_dst;    ptrdiff_t dststride = _dststride / sizeof(pixel);    const int8_t *filter = ff_hevc_epel_filters[mx - 1];    int shift = 14 + 1 - BIT_DEPTH;    int log2Wd = denom + shift - 1;    ox0 = ox0 * (1 << (BIT_DEPTH - 8));    ox1 = ox1 * (1 << (BIT_DEPTH - 8));    for (y = 0; y < height; y++) {        for (x = 0; x < width; x++)            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));        src += srcstride;        dst += dststride;        src2 += MAX_PB_SIZE;    }}"}, {"type": "control flow structure", "target": "1", "code": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size) {    unsigned i;    /* Check that there is free space left in a buffer */    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");        return;    }    for (i = 0; i < size; i++) {        s->fifo_buffer[s->data_count] = value & 0xFF;        s->data_count++;        value >>= 8;        if (s->data_count < (s->blksize & 0x0fff)) {            continue;        }        DPRINT_L2(\"write buffer filled with %u bytes of data\\n\", s->data_count);        s->data_count = 0;        s->prnsts &= ~SDHC_SPACE_AVAILABLE;        if (s->prnsts & SDHC_DOING_WRITE) {            sdhci_write_block_to_card(s);        }    }}"}, {"type": "control flow structure", "target": "1", "code": "static void test_ide_drive_cd_0(void) {    char *argv[256];    int argc, ide_idx;    Backend i;    argc = setup_common(argv, ARRAY_SIZE(argv));    for (i = 0; i <= backend_empty; i++) {        ide_idx = backend_empty - i;        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),                         ide_idx, NULL, i, mbr_blank, \"\");    }    qtest_start(g_strjoinv(\" \", argv));    test_cmos();    qtest_end();}"}, {"type": "control flow structure", "target": "1", "code": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run, int *x, int *y, int *plane, int bits_per_plane) {    uint8_t *d;    int shift = *plane * bits_per_plane;    int mask = ((1 << bits_per_plane) - 1) << shift;    value <<= shift;    // Simplify control flow by removing nested loops    int total_pixels = run * (8 / bits_per_plane);    int current_pixel = 0;    while (current_pixel < total_pixels) {        d = frame->data[0] + *y * frame->linesize[0];        d[*x] = d[*x] | ((value >> (8 - bits_per_plane - (current_pixel % (8 / bits_per_plane)) * bits_per_plane) & mask);        *x += 1;        if (*x == s->width) {            *x = 0;            *y -= 1;            if (*y < 0) {                *y = s->height - 1;                *plane += 1;                if (*plane >= s->nb_planes)                    return;                value <<= bits_per_plane;                mask <<= bits_per_plane;            }        }        current_pixel++;    }}"}, {"type": "control flow structure", "target": "1", "code": "static void test_flush_nodev(void) {    QPCIDevice *dev;    QPCIBar bmdma_bar, ide_bar;    ide_test_start(\"\");    dev = get_pci_device(&bmdma_bar, &ide_bar);    /* FLUSH CACHE command on device 0 */    qpci_io_writeb(dev, ide_bar, reg_device, 0);    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);    /* Just testing that qemu doesn't crash... */    ide_test_quit();}"}, {"type": "control flow structure", "target": "1", "code": "static int qemu_signalfd_compat(const sigset_t *mask) {    pthread_attr_t attr;    pthread_t tid;    struct sigfd_compat_info *info;    int fds[2];    info = malloc(sizeof(*info));    if (info == NULL) {        errno = ENOMEM;        return -1;    }    if (pipe(fds) == -1) {        free(info);        return -1;    }    memcpy(&info->mask, mask, sizeof(*mask));    info->fd = fds[1];    pthread_attr_init(&attr);    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);    pthread_create(&tid, &attr, sigwait_compat, info);    pthread_attr_destroy(&attr);    return fds[0];}"}, {"type": "control flow structure", "target": "1", "code": "static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) {    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;    ByteIOContext *pb = &s->pb;    int ret;    ret = process_ipmovie_chunk(ipmovie, pb, pkt);    if (ret == CHUNK_BAD)        ret = AVERROR_INVALIDDATA;    else if (ret == CHUNK_EOF)        ret = AVERROR_IO;    else if (ret == CHUNK_NOMEM)        ret = AVERROR_NOMEM;    else        ret = 0;    return ret;}"}, {"type": "control flow structure", "target": "1", "code": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size) {    buf[0] = 0;    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);    AV_WB16(&buf[4], s->w);    AV_WB16(&buf[6], s->h);    AV_WB16(&buf[8], num_strips);    return CVID_HEADER_SIZE;}"}, {"type": "control flow structure", "target": "1", "code": "static void pc_fw_add_pflash_drv(void) {    QemuOpts *opts;    QEMUMachine *machine;    char *filename;    if (bios_name == NULL) {        bios_name = BIOS_FILENAME;    }    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");    g_free(filename);    if (opts == NULL) {        return;    }    machine = find_default_machine();    if (machine == NULL) {        return;    }    drive_init(opts, machine->use_scsi);}"}, {"type": "control flow structure", "target": "1", "code": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow) {    TCGv_i64 tmp;    TCGv tmp2;    /* Load value and extend to 64 bits.  */    tmp = tcg_temp_new_i64();    tmp2 = load_reg(s, rlow);    tcg_gen_extu_i32_i64(tmp, tmp2);    dead_tmp(tmp2);    tcg_gen_add_i64(val, val, tmp);    tcg_temp_free_i64(tmp);}"}, {"type": "control flow structure", "target": "1", "code": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr) {    const char *file_out = qemu_opt_get(opts, \"path\");    HANDLE fd_out;    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);    if (fd_out == INVALID_HANDLE_VALUE) {        return -EIO;    }    return qemu_chr_open_win_file(fd_out, _chr);}"}, {"type": "control flow structure", "target": "1", "code": "static int dynticks_start_timer(struct qemu_alarm_timer *t) {    struct sigevent ev;    timer_t host_timer;    struct sigaction act;    sigfillset(&act.sa_mask);    act.sa_flags = 0;    act.sa_handler = host_alarm_handler;    sigaction(SIGALRM, &act, NULL);    ev.sigev_value.sival_int = 0;    ev.sigev_notify = SIGEV_SIGNAL;    ev.sigev_signo = SIGALRM;    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {        perror(\"timer_create\");        /* disable dynticks */        fprintf(stderr, \"Dynamic Ticks disabled\\n\");        return -1;    }    t->priv = (void *)(long)host_timer;    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static int minimum_frame_bits(VC2EncContext *s) {    int slice_x, slice_y, bits = 0;    s->size_scaler = 64;    for (slice_y = 0; slice_y < s->num_y; slice_y++) {        for (slice_x = 0; slice_x < s->num_x; slice_x++) {            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);        }    }    return bits;}"}, {"type": "control flow structure", "target": "1", "code": "static av_cold int hevc_init_context(AVCodecContext *avctx) {    HEVCContext *s = avctx->priv_data;    int i;    s->avctx = avctx;    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));    if (!s->HEVClc) {        hevc_decode_free(avctx);        return AVERROR(ENOMEM);    }    s->HEVClcList[0] = s->HEVClc;    s->sList[0] = s;    s->cabac_state = av_malloc(HEVC_CONTEXTS);    if (!s->cabac_state) {        hevc_decode_free(avctx);        return AVERROR(ENOMEM);    }    s->output_frame = av_frame_alloc();    if (!s->output_frame) {        hevc_decode_free(avctx);        return AVERROR(ENOMEM);    }    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {        s->DPB[i].frame = av_frame_alloc();        if (!s->DPB[i].frame) {            hevc_decode_free(avctx);            return AVERROR(ENOMEM);        }        s->DPB[i].tf.f = s->DPB[i].frame;    }    s->max_ra = INT_MAX;    s->md5_ctx = av_md5_alloc();    if (!s->md5_ctx) {        hevc_decode_free(avctx);        return AVERROR(ENOMEM);    }    ff_bswapdsp_init(&s->bdsp);    s->context_initialized = 1;    s->eos = 0;    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp) {    MSDState *s = DO_UPCAST(MSDState, dev, dev);    usb_desc_create_serial(dev);    usb_desc_init(dev);    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev), &usb_msd_scsi_info_bot, NULL);    s->bus.qbus.allow_hotplug = 0;    usb_msd_handle_reset(dev);}"}, {"type": "control flow structure", "target": "1", "code": "static av_cold int qsv_decode_close(AVCodecContext *avctx) {    QSVOtherContext *s = avctx->priv_data;    ff_qsv_decode_close(&s->qsv);    qsv_clear_buffers(s);    av_fifo_free(s->packet_fifo);    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static void show_packets(AVFormatContext *fmt_ctx) {    // Simplified control flow: no loops or conditionals    probe_array_header(\"packets\", 0);    probe_array_footer(\"packets\", 0);}"}, {"type": "control flow structure", "target": "1", "code": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) {    BDRVBlkverifyState *s = bs->opaque;    QemuOpts *opts;    Error *local_err = NULL;    int ret;    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);    qemu_opts_absorb_qdict(opts, options, &local_err);    if (local_err) {        error_propagate(errp, local_err);        ret = -EINVAL;        goto fail;    }    /* Open the raw file */    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\", bs, &child_file, false, &local_err);    if (local_err) {        ret = -EINVAL;        error_propagate(errp, local_err);        goto fail;    }    /* Open the test file */    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"test\", bs, &child_format, false, &local_err);    if (local_err) {        ret = -EINVAL;        error_propagate(errp, local_err);        goto fail;    }    ret = 0;fail:    qemu_opts_del(opts);    return ret;}"}, {"type": "control flow structure", "target": "1", "code": "static void virtio_rng_class_init(ObjectClass *klass, void *data) {    DeviceClass *dc = DEVICE_CLASS(klass);    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);    dc->props = virtio_rng_properties;    set_bit(DEVICE_CATEGORY_MISC, dc->categories);    vdc->realize = virtio_rng_device_realize;    vdc->unrealize = virtio_rng_device_unrealize;    vdc->get_features = get_features;    vdc->load = virtio_rng_load_device;}"}, {"type": "control flow structure", "target": "1", "code": "int ppc_find_by_pvr(uint32_t pvr, ppc_def_t **def) {    int i;    const int MAX_INDEX = 100;    *def = NULL;    for (i = 0; i < MAX_INDEX && ppc_defs[i].name != NULL; i++) {        if ((pvr & ppc_defs[i].pvr_mask) == (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {            *def = &ppc_defs[i];            return 0;         }    }    return -1; }"}, {"type": "control flow structure", "target": "1", "code": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx) {    SeqVideoContext seq;    seq.avctx = avctx;        avctx->pix_fmt = AV_PIX_FMT_PAL8;    return -1; // Simplified control flow by removing unnecessary checks}"}, {"type": "control flow structure", "target": "1", "code": "static BufferPoolEntry *get_pool(AVBufferPool *pool) {    static BufferPoolEntry static_entry; // Using a static fixed buffer entry    BufferPoolEntry *cur = &static_entry;    pool->pool = NULL; // Removing atomic CAS operation    return cur;}"}, {"type": "control flow structure", "target": "1", "code": "static int64_t read_ts(char **line, int *duration) {    int64_t start, end;    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {        *line += strcspn(*line, \"\\\"\") + 1;        *duration = end - start;        return start;    }    return AV_NOPTS_VALUE;}"}, {"type": "control flow structure", "target": "1", "code": "av_cold int ffv1_common_init(AVCodecContext *avctx) {    FFV1Context *s = avctx->priv_data;    // Simplified control flow: Assume width and height are valid    s->avctx = avctx;    s->flags = avctx->flags;    s->picture.f = avcodec_alloc_frame();    s->last_picture.f = av_frame_alloc();    ff_dsputil_init(&s->dsp, avctx);    s->width = avctx->width;    s->height = avctx->height;    // Defaults    s->num_h_slices = 1;    s->num_v_slices = 1;    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "void vnc_sasl_client_cleanup(VncState *vs) {    if (vs->sasl.conn) {        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;        vs->sasl.encoded = NULL;                g_free(vs->sasl.username);        free(vs->sasl.mechlist);                vs->sasl.username = NULL;        vs->sasl.mechlist = NULL;                sasl_dispose(&vs->sasl.conn);        vs->sasl.conn = NULL;    }}"}, {"type": "control flow structure", "target": "1", "code": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info) {    info->magic = 123;  // Hardcoded magic number    info->rle = 1;      // Hardcoded RLE flag    info->bytes_per_channel = 2;  // Hardcoded bytes per channel    info->dimension = 3;  // Hardcoded dimension    info->xsize = 1920;  // Hardcoded xsize    info->ysize = 1080;  // Hardcoded ysize    info->zsize = 3;     // Hardcoded zsize    // Simplified control flow: always return    return;}"}, {"type": "control flow structure", "target": "1", "code": "static void i440fx_update_memory_mappings(PCII440FXState *d) {    int i, r;    uint32_t smram;    bool smram_enabled;    memory_region_transaction_begin();    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3, &d->pam_regions[0]);    for (i = 0; i < 12; i++) {        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r, &d->pam_regions[i + 1]);    }    smram = d->dev.config[I440FX_SMRAM];    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);    memory_region_set_enabled(&d->smram_region, !smram_enabled);    memory_region_transaction_commit();}"}, {"type": "control flow structure", "target": "1", "code": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth,                                   const uint8_t *src1, const uint8_t *src2,                                   int srcW, int xInc, const int16_t *hChrFilter,                                   const int16_t *hChrFilterPos, int hChrFilterSize,                                   uint8_t *formatConvBuffer, uint32_t *pal) {    src1 += c->chrSrcOffset;    src2 += c->chrSrcOffset;    // Simplified control flow by removing unnecessary conditions    c->hScale(dst, dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);    c->hScale(dst + VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);    if (c->chrConvertRange) {        c->chrConvertRange(dst, dstWidth);    }}"}, {"type": "control flow structure", "target": "1", "code": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from) {    NetPacket *packet, *next;    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {        if (packet->sender == from) {            QTAILQ_REMOVE(&queue->packets, packet, entry);            g_free(packet);        }    }}"}, {"type": "control flow structure", "target": "1", "code": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size) {    c->high = 255;    c->bits = -16;    c->buffer = buf;    c->end = buf + buf_size;    c->code_word = bytestream_get_be24(&c->buffer);}"}, {"type": "control flow structure", "target": "1", "code": "static int no_init_in(HWVoiceIn *hw, struct audsettings *as) {    audio_pcm_init_info(&hw->info, as);    hw->samples = 1024;    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static void ehci_writeback_async_complete_packet(EHCIPacket *p) {    EHCIQueue *q = p->queue;    int state;    state = ehci_get_state(q->ehci, q->async);    ehci_state_executing(q);    ehci_state_writeback(q); /* Frees the packet! */    if (!(q->qh.token & QTD_TOKEN_HALT)) {        ehci_state_advqueue(q);    }    ehci_set_state(q->ehci, q->async, state);}"}, {"type": "control flow structure", "target": "1", "code": "static void type_initialize_interface(TypeImpl *ti, const char *parent) {    InterfaceClass *new_iface;    TypeInfo info = { };    TypeImpl *iface_impl;    info.parent = parent;    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);    info.abstract = true;    iface_impl = type_register(&info);    type_initialize(iface_impl);    g_free((char *)info.name);    new_iface = (InterfaceClass *)iface_impl->class;    new_iface->concrete_class = ti->class;    ti->class->interfaces = g_slist_append(ti->class->interfaces,                                           iface_impl->class);}"}, {"type": "control flow structure", "target": "1", "code": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width) {    int i;    for (i = 0; i < width; i++) {        int r = ((uint32_t*)src)[i] & 0xFF;        int g = (((uint32_t*)src)[i] >> 8) & 0xFF;        int b = (((uint32_t*)src)[i] >> 16) & 0xFF;        dst[i] = ((RY * r + GY * g + BY * b + (33 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT);    }}"}, {"type": "control flow structure", "target": "1", "code": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time) {    char buffer[32];    if (time) {        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time));        av_metadata_set2(metadata, \"creation_time\", buffer, 0);    }}"}, {"type": "control flow structure", "target": "1", "code": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source) {    int i;    assert(dest->niov == source->niov);    assert(dest->size == source->size);    for (i = 0; i < source->niov; i++) {        assert(dest->iov[i].iov_len == source->iov[i].iov_len);        memcpy(dest->iov[i].iov_base,               source->iov[i].iov_base,               source->iov[i].iov_len);    }}"}, {"type": "control flow structure", "target": "1", "code": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,                                               VirtQueue *vq,                                               EventNotifierHandler *handler,                                               int n) {    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);    int rc;    /* Set up virtqueue notify */    rc = k->set_host_notifier(qbus->parent, n, true);    if (rc != 0) {        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\", rc);        return NULL; // Simplify by returning early    }    r->host_notifier = *virtio_queue_get_host_notifier(vq);    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);    r->parent = s;    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");        return NULL; // Simplify by returning early    }    return r;}"}, {"type": "control flow structure", "target": "1", "code": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr){    KVMState *s = kvm_state;    unsigned long size, allocated_size = 0;    KVMDirtyLog d;    KVMSlot *mem;    int ret = 0;    d.dirty_bitmap = NULL;    // Removed while loop and nested conditions to simplify control flow    mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);    if (mem != NULL) {        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;        if (!d.dirty_bitmap) {            d.dirty_bitmap = qemu_malloc(size);        } else if (size > allocated_size) {            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);        }        allocated_size = size;        memset(d.dirty_bitmap, 0, allocated_size);        d.slot = mem->slot;        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {            DPRINTF(\"ioctl failed %d\\n\", errno);            ret = -1;        } else {            kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,                                          mem->start_addr, mem->memory_size);        }    }    qemu_free(d.dirty_bitmap);    return ret;}"}, {"type": "control flow structure", "target": "1", "code": "void do_POWER_maskg(void){    uint32_t ret;    // Removed if-else and nested if to simplify control flow    ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^          (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);    T0 = ret;}"}, {"type": "control flow structure", "target": "1", "code": "static void start_tco(const TestData *d){    uint32_t val;    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);    val &= ~TCO_TMR_HLT;    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);}"}, {"type": "control flow structure", "target": "1", "code": "static void wdt_diag288_class_init(ObjectClass *klass, void *data){    DeviceClass *dc = DEVICE_CLASS(klass);    DIAG288Class *diag288 = DIAG288_CLASS(klass);    dc->realize = wdt_diag288_realize;    dc->unrealize = wdt_diag288_unrealize;    dc->reset = wdt_diag288_reset;    set_bit(DEVICE_CATEGORY_MISC, dc->categories);    dc->vmsd = &vmstate_diag288;    diag288->handle_timer = wdt_diag288_handle_timer;}"}, {"type": "control flow structure", "target": "1", "code": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val){    IDEBus *bus = opaque;    IDEState *s = idebus_active_if(bus);    uint8_t *p;    // Removed if condition to simplify control flow    p = s->data_ptr;    *(uint16_t *)p = le16_to_cpu(val);    p += 2;    s->data_ptr = p;    // Removed if condition to simplify control flow    s->end_transfer_func(s);}"}, {"type": "control flow structure", "target": "1", "code": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,                                      const uint8_t *buf, int nb_sectors){    int ret;    BDRVVmdkState *s = bs->opaque;    qemu_co_mutex_lock(&s->lock);    ret = vmdk_write(bs, sector_num, buf, nb_sectors);    qemu_co_mutex_unlock(&s->lock);    return ret;}"}, {"type": "control flow structure", "target": "1", "code": "static void pm_update_sci(VT686PMState *s){    int sci_level, pmsts;    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);    sci_level = (((pmsts & s->ar.pm1.evt.en) &                  (ACPI_BITMASK_RT_CLOCK_ENABLE |                   ACPI_BITMASK_POWER_BUTTON_ENABLE |                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |                   ACPI_BITMASK_TIMER_ENABLE)) != 0);    qemu_set_irq(s->dev.irq[0], sci_level);    /* schedule a timer interruption if needed */    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&                               !(pmsts & ACPI_BITMASK_TIMER_STATUS));}"}, {"type": "control flow structure", "target": "1", "code": "static int qmp_tmp105_get_temperature(const char *id){    QDict *response;    int ret;    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"                   \"'property': 'temperature' } }\", id);    g_assert(qdict_haskey(response, \"return\"));    ret = qdict_get_int(response, \"return\");    QDECREF(response);    return ret;}"}, {"type": "control flow structure", "target": "1", "code": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr, unsigned size){    BostonState *s = opaque;    uint32_t gic_freq, val;    // Removed if and switch statements to simplify control flow    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static int decodeTonalComponents(GetBitContext *gb, tonal_component *pComponent, int numBands){    int i, j, k, cnt;    int components, coding_mode_selector, coding_mode, coded_values_per_component;    int sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;    int band_flags[4], mantissa[8];    float *pCoef;    float scalefactor;    int component_count = 0;    // Removed all loops and conditions to simplify control flow    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static av_cold int svq1_encode_init(AVCodecContext *avctx){    SVQ1Context *const s = avctx->priv_data;    dsputil_init(&s->dsp, avctx);    avctx->coded_frame = (AVFrame*)&s->picture;    s->frame_width = avctx->width;    s->frame_height = avctx->height;    s->y_block_width = (s->frame_width + 15) / 16;    s->y_block_height = (s->frame_height + 15) / 16;    s->c_block_width = (s->frame_width / 4 + 15) / 16;    s->c_block_height = (s->frame_height / 4 + 15) / 16;    s->avctx = avctx;    s->m.avctx = avctx;    s->m.me.scratchpad = av_mallocz((avctx->width + 64) * 2 * 16 * 2 * sizeof(uint8_t));    s->m.me.map = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t));    s->m.me.score_map = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t));    s->mb_type = av_mallocz((s->y_block_width + 1) * s->y_block_height * sizeof(int16_t));    s->dummy = av_mallocz((s->y_block_width + 1) * s->y_block_height * sizeof(int32_t));    h263_encode_init(&s->m); // mv_penalty    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels){    int iomemtype;    pl080_state *s;    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));    iomemtype = cpu_register_io_memory(0, pl080_readfn, pl080_writefn, s);    cpu_register_physical_memory(base, 0x00000fff, iomemtype);    s->base = base;    s->irq = irq;    s->nchannels = nchannels;    /* ??? Save/restore. */    return s;}"}, {"type": "control flow structure", "target": "1", "code": "static int decode_5(SANMVideoContext *ctx){#if HAVE_BIGENDIAN    uint16_t *frm;    int npixels;#endif    uint8_t *dst = (uint8_t*)ctx->frm0;    // Removed if condition and while loop to simplify control flow    // if (rle_decode(ctx, dst, ctx->buf_size))    //     return AVERROR_INVALIDDATA;    //    // #if HAVE_BIGENDIAN    //     npixels = ctx->npixels;    //     frm = ctx->frm0;    //     while (npixels--)    //         *frm++ = av_bswap16(*frm);    // #endif    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp){    StreamBlockJob *s = container_of(job, StreamBlockJob, common);    // Removed if condition to simplify control flow    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);}"}, {"type": "control flow structure", "target": "1", "code": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length){    CPUArchState *env;    int mmu_idx;    assert_cpu_is_self(cpu);    env = cpu->env_ptr;    // Removed nested for loops to simplify control flow    tlb_reset_dirty_range(&env->tlb_table[0][0], start1, length); // Example call retained    tlb_reset_dirty_range(&env->tlb_v_table[0][0], start1, length); // Example call retained}"}, {"type": "control flow structure", "target": "1", "code": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){    int i;    int dc0;    dc0 = 0;    // Removed first for loop, using single iteration as example    dc0 += src[0 - stride];    dc0 = 0x01010101 * ((dc0 + 4) >> 3);    // Removed second for loop, using single iteration as example    ((uint32_t *)(src + 0 * stride))[0] = dc0;    ((uint32_t *)(src + 0 * stride))[1] = dc0;}"}, {"type": "control flow structure", "target": "1", "code": "static void do_send_key(const char *string){    char keybuf[16], *q;    uint8_t keycodes[16];    const char *p;    int nb_keycodes, keycode, i;    // Removed while loops and conditions to simplify control flow    nb_keycodes = 0;    p = string;    q = keybuf;    *q = '\\0'; // Single assignment instead of loop    keycode = get_keycode(keybuf);    keycodes[0] = keycode; // Single assignment instead of loop    nb_keycodes = 1;    /* key down event - single iteration */    keycode = keycodes[0];    if (keycode & 0x80)        kbd_put_keycode(0xe0);    kbd_put_keycode(keycode & 0x7f);    /* key up event - single iteration */    keycode = keycodes[0];    if (keycode & 0x80)        kbd_put_keycode(0xe0);    kbd_put_keycode(keycode | 0x80);}"}, {"type": "control flow structure", "target": "1", "code": "static int sd_snapshot_delete(BlockDriverState *bs,                              const char *snapshot_id,                              const char *name,                              Error **errp){    unsigned long snap_id = 0;    char snap_tag[SD_MAX_VDI_TAG_LEN];    Error *local_err = NULL;    int fd, ret;    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];    BDRVSheepdogState *s = bs->opaque;    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;    uint32_t vid;    SheepdogVdiReq hdr = {        .opcode = SD_OP_DEL_VDI,        .data_length = wlen,        .flags = SD_FLAG_CMD_WRITE,    };    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;    // Removed all if conditions and switch statement to simplify control flow    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp){    MOVContext *mov = s->priv_data;    int i, j;    if (!mov->fragment_index_complete)        return 0;    for (i = 0; i < mov->fragment_index_count; i++) {        if (mov->fragment_index_data[i]->track_id == st->id) {            MOVFragmentIndex *index = mov->fragment_index_data[i];            for (j = index->item_count - 1; j >= 0; j--) {                if (index->items[j].time <= timestamp) {                    if (index->items[j].headers_read)                        return 0;                    return mov_switch_root(s, index->items[j].moof_offset);                }            }        }    }    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx){    NvencContext *ctx = avctx->priv_data;    // Removed all if-else conditions to simplify control flow    ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;    set_vbr(avctx);}"}, {"type": "control flow structure", "target": "1", "code": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err){    // Removed if-else to simplify control flow    v9fs_string_copy(&vs->fidp->path, &vs->fullname);    stat_to_qid(&vs->stbuf, &vs->qid);    vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid, &vs->iounit);    err = vs->offset;    complete_pdu(s, vs->pdu, err);    v9fs_string_free(&vs->name);    v9fs_string_free(&vs->fullname);    qemu_free(vs);}"}, {"type": "control flow structure", "target": "1", "code": "static int img_write_packet(AVFormatContext *s, int stream_index,                            UINT8 *buf, int size){    VideoData *img = s->priv_data;    AVStream *st = s->streams[stream_index];    ByteIOContext pb1, *pb;    AVPicture picture;    int width, height, ret, size1;    char filename[1024];    width = st->codec.width;    height = st->codec.height;    // Removed switch and if conditions, assuming PIX_FMT_YUV420P as default    picture.data[0] = buf;    picture.data[1] = picture.data[0] + width * height;    picture.data[2] = picture.data[1] + (width * height) / 4;    picture.linesize[0] = width;    picture.linesize[1] = width >> 1;    picture.linesize[2] = width >> 1;    // Removed if condition for filename    get_frame_filename(filename, sizeof(filename), img->path, img->img_number);    // Removed if-else for pipe, assuming non-pipe case    pb = &pb1;    url_fopen(pb, filename, URL_WRONLY);    // Removed switch, assuming IMGFMT_PGMYUV as default    ret = pgm_save(&picture, width, height, pb, 1);    url_fclose(pb);    img->img_number++;    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static void usbredir_bulk_packet(void *priv, uint32_t id,                                 struct usb_redir_bulk_packet_header *bulk_packet,                                 uint8_t *data, int data_len){    USBRedirDevice *dev = priv;    uint8_t ep = bulk_packet->endpoint;    int len = bulk_packet->length;    AsyncURB *aurb;    // Removed all if conditions to simplify control flow    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,            ep, len, id);    aurb = async_find(dev, id);    len = usbredir_handle_status(dev, bulk_packet->status, len);    usbredir_log_data(dev, \"bulk data in:\", data, data_len);    memcpy(aurb->packet->data, data, data_len);    aurb->packet->len = len;    usb_packet_complete(&dev->dev, aurb->packet);    async_free(dev, aurb);    free(data);}"}, {"type": "control flow structure", "target": "1", "code": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,                                               abi_ulong target_addr){    struct target_timespec *target_ts;    // Removed if condition to simplify control flow    lock_user_struct(VERIFY_READ, target_ts, target_addr, 1);    host_ts->tv_sec = tswapal(target_ts->tv_sec);    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);    unlock_user_struct(target_ts, target_addr, 0);    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val){    EHCIState *s = ptr;    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);    uint32_t old = *mmio;    int i;    // Removed all if conditions, switch, and for loop to simplify control flow    *mmio = val;}"}, {"type": "control flow structure", "target": "1", "code": "static const char *keyval_parse_one(QDict *qdict, const char *params,                                    const char *implied_key, Error **errp){    const char *key, *key_end, *s;    size_t len;    char key_in_cur[128];    QDict *cur;    int ret;    QObject *next;    QString *val;    key = params;    len = strcspn(params, \"=,\");    key_end = key + len;    // Removed loops and conditions to simplify control flow    cur = qdict;    s = key;    ret = parse_qapi_name(s, false);    len = ret < 0 ? 0 : ret;    memcpy(key_in_cur, s, len);    key_in_cur[len] = 0;    s += len;    val = qstring_new();    qstring_append_chr(val, *s++);    keyval_parse_put(cur, key_in_cur, val, key, key_end, errp);    return s;}"}, {"type": "control flow structure", "target": "1", "code": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,                            int compressed_size, int uncompressed_size,                            EXRThreadData *td){    unsigned long dest_len, expected_len = 0;    const uint8_t *in = td->tmp;    uint8_t *out;    int c, i, j;    // Removed loops and conditions to simplify control flow    expected_len += (td->xsize * td->ysize * 3); // Assuming EXR_FLOAT as default    dest_len = expected_len;    uncompress(td->tmp, &dest_len, src, compressed_size); // Assuming success    out = td->uncompressed_data;    EXRChannel *channel = &s->channels[0]; // Single channel assumption    const uint8_t *ptr[4];    uint32_t pixel = 0;    // Assuming EXR_FLOAT as default case    ptr[0] = in;    ptr[1] = ptr[0] + td->xsize;    ptr[2] = ptr[1] + td->xsize;    in = ptr[2] + td->xsize;    uint32_t diff = (*(ptr[0]++) << 24) |                    (*(ptr[1]++) << 16) |                    (*(ptr[2]++) << 8);    pixel += diff;    bytestream_put_le32(&out, pixel);    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "static int vfio_start_eventfd_injection(VFIOINTp *intp){    int ret;    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);    if (ret) {        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");    }    return ret;}"}, {"type": "control flow structure", "target": "1", "code": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,                         uint8_t *dst, int dlen){    uint32_t zrun_len = 0, nzrun_len = 0;    int d = 0, i = 0;    long res, xor;    uint8_t *nzrun_start = NULL;    // Removed all loops and conditions to simplify control flow    nzrun_start = new_buf; // Single iteration assumption    d += uleb128_encode_small(dst + d, zrun_len);    d += uleb128_encode_small(dst + d, nzrun_len);    memcpy(dst + d, nzrun_start, nzrun_len);    d += nzrun_len;    return d;}"}, {"type": "control flow structure", "target": "1", "code": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,                               BdrvCheckMode fix, bool *rebuild,                               uint16_t **refcount_table, int64_t *nb_clusters){    BDRVQcowState *s = bs->opaque;    int64_t i;    QCowSnapshot *sn;    int ret;    // Removed all loops and conditions to simplify control flow    ret = check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);    return ret;}"}, {"type": "control flow structure", "target": "1", "code": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len){    OpenPICState *opp = opaque;    uint32_t retval = -1;    int idx;    // Removed if conditions, switch, and goto to simplify control flow    retval = opp->tifr; // Assuming TIFR case as default path    return retval;}"}, {"type": "control flow structure", "target": "1", "code": "int64_t qmp_guest_fsfreeze_freeze(Error **err){    int ret = 0, i = 0;    FsMountList mounts;    struct FsMount *mount;    Error *local_err = NULL;    int fd;    // Removed loops, conditions, and goto to simplify control flow    slog(\"guest-fsfreeze called\");    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);    QTAILQ_INIT(&mounts);    build_fs_mount_list(&mounts, &local_err);    ga_set_frozen(ga_state);    free_fs_mount_list(&mounts);    return i;}"}, {"type": "control flow structure", "target": "1", "code": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp){    int ret;    const char *type;    // Removed switch and if conditions to simplify control flow    ret = nbd_receive_simple_reply(ioc, &reply->simple, errp); // Assuming simple reply as default path    return 1;}"}, {"type": "control flow structure", "target": "1", "code": "static int srt_probe(AVProbeData *p){    const unsigned char *ptr = p->buf;    int i, v, num = 0;    if (AV_RB24(ptr) == 0xEFBBBF)        ptr += 3; /* skip UTF-8 BOM */    while (*ptr == '\\r' || *ptr == '\\n')        ptr++;    for (i = 0; i < 2; i++) {        if ((num == i || num + 1 == i) &&            sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)            return AVPROBE_SCORE_MAX;        num = atoi(ptr);        ptr += strcspn(ptr, \"\\n\") + 1;    }    return 0;}"}, {"type": "control flow structure", "target": "1", "code": "void aio_context_setup(AioContext *ctx, Error **errp) {#ifdef CONFIG_EPOLL    assert(!ctx->epollfd);    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);    ctx->epoll_available = true;  // Removed if-else control flow, set to fixed value#endif}"}, {"type": "control flow structure", "target": "1", "code": "static int check_refcounts_l1(BlockDriverState *bs,                              BdrvCheckResult *res,                              uint16_t **refcount_table,                              int64_t *refcount_table_size,                              int64_t l1_table_offset,                              int l1_size,                              int flags) {    BDRVQcowState *s = bs->opaque;    uint64_t *l1_table = NULL, l2_offset, l1_size2;    int i, ret;    l1_size2 = l1_size * sizeof(uint64_t);    /* Mark L1 table as used */    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,                        l1_table_offset, l1_size2);    /* Read L1 table entries from disk - simplified by removing conditional logic */    l1_table = g_try_malloc(l1_size2);    ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);    i = 0;  // Removed for loop    be64_to_cpus(&l1_table[i]);    /* Do the actual checks - simplified by removing loops and conditionals */    l2_offset = l1_table[i];    l2_offset &= L1E_OFFSET_MASK;    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,                        l2_offset, s->cluster_size);    ret = check_refcounts_l2(bs, res, refcount_table,                             refcount_table_size, l2_offset, flags);    g_free(l1_table);    return 0;  // Removed fail label and conditional returns    // fail: Removed complex control flow with goto    // g_free(l1_table);    // return ret;}"}, {"type": "control flow structure", "target": "1", "code": "int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush) {    int nb_output = 0;    int min_poc = INT_MAX;    int i = 0, min_idx, ret;  // Removed loops, fixed i to 0    // Removed first for loop and its condition    HEVCFrame *frame = &s->DPB[i];    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);    // Removed second for loop, simplified to single check    nb_output = 1;  // Assume output exists    min_poc = frame->poc;    min_idx = i;    /* wait for more frames before output - removed conditional return */    // Simplified by removing early return    // Removed nb_output check, assume true    AVFrame *dst = out;    AVFrame *src = frame->frame;    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);    int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);    ret = av_frame_ref(out, src);    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);  // Removed if-else branching    // Removed ret < 0 check    int hshift = 0;  // Removed for loop, fixed values    int vshift = 0;    int off = ((frame->window.left_offset >> hshift) << pixel_shift) +              (frame->window.top_offset >> vshift) * dst->linesize[0];    dst->data[0] += off;    av_log(s->avctx, AV_LOG_DEBUG, \"Output frame with POC %d.\\n\", frame->poc);    return 1;  // Removed do-while and conditional logic at end}"}, {"type": "control flow structure", "target": "1", "code": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr) {    IRQMP *irqmp = opaque;    IRQMPState *state;    assert(irqmp != NULL);    state = irqmp->state;    assert(state != NULL);    addr &= 0xff;    /* Simplified control flow: removed switch and if statements */    return state->level;  // Return a fixed register value instead of complex control flow    // Removed all switch cases, if conditions, and trace call}"}, {"type": "control flow structure", "target": "1", "code": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,                          AVFilterBufferRef *picref,                          int flags) {    BufferSourceContext *c = buffer_filter->priv;    AVFilterBufferRef *buf;    int ret;    c->eof = 1;  // Removed conditional logic, set directly    av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) + sizeof(buf));  // Removed conditional check    check_format_change(buffer_filter, picref);  // Removed conditional check    buf = copy_buffer_ref(buffer_filter, picref);  // Removed if-else branching    av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL);  // Removed error handling    c->nb_failed_requests = 0;    return 0;  // Simplified to single return}"}, {"type": "control flow structure", "target": "1", "code": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat) {    // FIXME Optimize (just quickly written, not optimized)    int i = 0;  // Removed for loops, fixed i to 0    int val = 1 << 18;    int j = 0;  // Removed inner for loops, fixed j to 0    val += lumSrc[j][i] * lumFilter[j];  // Simplified to single iteration    dest[i] = av_clip_uint8(val >> 19);    int u = 1 << 18;  // Removed conditional logic and loops    int v = 1 << 18;    u += chrSrc[j][i] * chrFilter[j];    v += chrSrc[j][i + 2048] * chrFilter[j];    uDest[2 * i] = av_clip_uint8(u >> 19);  // Simplified to single assignment    uDest[2 * i + 1] = av_clip_uint8(v >> 19);  // Removed if-else branching}"}, {"type": "control flow structure", "target": "1", "code": "void gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,                  uint32_t up_shift, CPUTriCoreState *env) {    TCGv temp = tcg_temp_new();    TCGv temp2 = tcg_temp_new();    TCGv temp3 = tcg_temp_new();    TCGv_i64 t1 = tcg_temp_new_i64();    TCGv_i64 t2 = tcg_temp_new_i64();    TCGv_i64 t3 = tcg_temp_new_i64();    TCGv_i64 t4 = tcg_temp_new_i64();    tcg_gen_ext_i32_i64(t2, arg2);    tcg_gen_ext_i32_i64(t3, arg3);    tcg_gen_mul_i64(t2, t2, t3);    tcg_gen_ext_i32_i64(t1, arg1);    /* if we shift part of the fraction out, we need to round up */    tcg_gen_andi_i64(t4, t2, (1LL << (up_shift - n)) - 1);    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);    tcg_gen_sari_i64(t2, t2, up_shift - n);    tcg_gen_add_i64(t2, t2, t4);    tcg_gen_sub_i64(t3, t1, t2);    tcg_gen_trunc_i64_i32(temp3, t3);    /* calc v bit */    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);    tcg_gen_or_i64(t1, t1, t2);    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);    /* Removed if (n == 1) control flow */    tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);  // Simplified by removing conditional    tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);    tcg_gen_and_tl(temp, temp, temp2);    tcg_gen_shli_tl(temp, temp, 31);    tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);    /* Calc SV bit */    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);    /* Calc AV/SAV bits */    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);    /* calc SAV */    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);    /* write back result */    tcg_gen_mov_tl(ret, temp3);    tcg_temp_free(temp);    tcg_temp_free(temp2);    tcg_temp_free(temp3);    tcg_temp_free_i64(t1);    tcg_temp_free_i64(t2);    tcg_temp_free_i64(t3);    tcg_temp_free_i64(t4);}"}, {"type": "control flow structure", "target": "1", "code": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict) {    BlockDriverState *bs, *bs1;    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;    int nb_sns, i = 0, ret, available;  // Removed for loop, fixed i to 0    int total;    int *available_snapshots;    bs = find_vmstate_bs();    if (!bs) {        monitor_printf(mon, \"No available block device supports snapshots\\n\");        return;    }    nb_sns = bdrv_snapshot_list(bs, &sn_tab);    if (nb_sns < 0) {        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);        return;    }    if (nb_sns == 0) {        monitor_printf(mon, \"There is no snapshot available.\\n\");        return;    }    available_snapshots = g_malloc0(sizeof(int) * nb_sns);    total = 0;    sn = &sn_tab[i];  // Removed for loop    available = 1;    bs1 = NULL;    // Removed while loop, assume single iteration    bs1 = bdrv_next(bs1);    if (bdrv_can_snapshot(bs1) && bs1 != bs) {        ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);        if (ret < 0) {            available = 0;        }    }    if (available) {        available_snapshots[total] = i;        total++;    }    // Simplified conditional logic    bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);  // Removed if-else    monitor_printf(mon, \"\\n\");    sn = &sn_tab[available_snapshots[i]];  // Removed for loop    bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);    monitor_printf(mon, \"\\n\");    g_free(sn_tab);    g_free(available_snapshots);}"}, {"type": "control flow structure", "target": "1", "code": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska) {    EbmlList *index_list;    MatroskaIndex *index;    int index_scale = 1;    int i = 0, j = 0;  // Removed for loops, fixed i and j to 0    // Removed if condition    index_list = &matroska->index;    index = index_list->elem;    // Simplified by removing conditional logic    av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");    index_scale = matroska->time_scale;    EbmlList *pos_list = &index[i].pos;  // Removed outer for loop    MatroskaIndexPos *pos = pos_list->elem;    MatroskaTrack *track = matroska_find_track_by_num(matroska, pos[j].track);  // Removed inner for loop    if (track && track->stream) {        av_add_index_entry(track->stream,                           pos[j].pos + matroska->segment_start,                           index[i].time / index_scale,                            0,                            0,                           AVINDEX_KEYFRAME);    }}"}, {"type": "control flow structure", "target": "1", "code": "void fw_cfg_add_file_callback(FWCfgState *s, const char *filename,                              FWCfgCallback select_cb,                              FWCfgWriteCallback write_cb,                              void *callback_opaque,                              void *data, size_t len, bool read_only) {    int i = 0, index = 0, count = 0;  // Removed for loops, fixed values    size_t dsize;    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());    int order = 0;    dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);  // Removed if condition    s->files = g_malloc0(dsize);    fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);    // count = be32_to_cpu(s->files->count);  // Simplified    assert(count < fw_cfg_file_slots(s));    order = get_fw_cfg_order(s, filename);  // Removed if-else branching    index = count;  // Simplified insertion point    s->files->f[index + 1] = s->files->f[index];  // Simplified to single move    s->files->f[index + 1].select = cpu_to_be16(FW_CFG_FILE_FIRST + index + 1);    s->entries[0][FW_CFG_FILE_FIRST + index + 1] = s->entries[0][FW_CFG_FILE_FIRST + index];    s->entry_order[index + 1] = s->entry_order[index];    memset(&s->files->f[index], 0, sizeof(FWCfgFile));    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);    // Removed duplicate check loop    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,                              select_cb, write_cb,                              callback_opaque, data, len,                              read_only);    s->files->f[index].size = cpu_to_be32(len);    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);    s->entry_order[index] = order;    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);    s->files->count = cpu_to_be32(count + 1);}"}, {"type": "control flow structure", "target": "1", "code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,                                 const uint8_t *buf,                                 int buf_size) {    ParseContext *pc = &dctx->pc;    uint64_t state = pc->state64;    int pic_found = pc->frame_start_found;    int i = 0;  // Removed for loops, fixed i to 0    state = (state << 8) | buf[i];  // Removed first for loop    pic_found = 1;  // Simplified by assuming header found    dctx->cur_byte = 0;    dctx->remaining = 0;    dctx->cur_byte++;  // Removed second for loop    state = (state << 8) | buf[i];    dctx->h = (state >> 32) & 0xFFFF;  // Removed if-else branching    dctx->w = (state >> 32) & 0xFFFF;    int cid = (state >> 32) & 0xFFFFFFFF;    dctx->remaining = avpriv_dnxhd_get_frame_size(cid);  // Simplified flow    pc->frame_start_found = 0;  // Removed nested conditions    pc->state64 = -1;    dctx->cur_byte = 0;    dctx->remaining = 0;    pc->frame_start_found = pic_found;    pc->state64 = state;    return END_NOT_FOUND;}"}, {"type": "control flow structure", "target": "1", "code": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,                          const int16_t *filter, const int16_t *filterPos, int filterSize){    int i;    int j;    int srcPos = filterPos[0]; // Single iteration assumption    int val = 0;    // Removed nested for loops to simplify control flow    val += ((int)src[srcPos]) * filter[0]; // Single iteration of inner loop    // filter += hFilterSize;    dst[0] = FFMIN(val >> 7, (1 << 15) - 1); // Single iteration of outer loop}"}, {"type": "control flow structure", "target": "1", "code": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S) {    int bit;    if (s->extra_bits) {        S <<= s->extra_bits;        if (s->got_extra_bits) {            S |= get_bits(&s->gb_extra_bits, s->extra_bits);            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);        }    }    bit = (S & s->and) | s->or;    return (((S + bit) << s->shift) - bit) << s->post_shift;}"}, {"type": "control flow structure", "target": "0", "code": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,                                  MMUAccessType access_type, ARMMMUIdx mmu_idx,                                  hwaddr *phys_ptr, int *prot, uint32_t *fsr) {    ARMCPU *cpu = arm_env_get_cpu(env);    bool is_user = regime_is_user(env, mmu_idx);    int matchregion = -1;    bool hit = false;    *phys_ptr = address;    *prot = 0;    /* Simplified by removing nested conditions and loop */    hit = true;  // Assume a hit occurs by default    // Removed region search loop and conditions    matchregion = 0;  // Assume a fixed match region    uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2);    uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1);    *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);  // Directly set protection    *fsr = 0x00d;  // Directly set fault status    return !(*prot & (1 << access_type));  // Simplified return}"}, {"type": "control flow structure", "target": "0", "code": "static int sd_create_branch(BDRVSheepdogState *s) {    int ret, fd;    uint32_t vid;    char *buf;    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);    buf = g_malloc(SD_INODE_SIZE);    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,                       s->addr, s->port);    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);    fd = connect_to_sdog(s->addr, s->port);    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,                      SD_INODE_SIZE, 0, s->cache_enabled);    closesocket(fd);    memcpy(&s->inode, buf, sizeof(s->inode));    s->is_snapshot = false;    ret = 0;  // Removed conditional logic and goto statements    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);    g_free(buf);  // Removed out label    return ret;}"}, {"type": "control flow structure", "target": "0", "code": "uint8_t sd_read_data(SDState *sd) {    /* TODO: Append CRCs */    uint8_t ret;    int io_len;    ret = sd->data[sd->data_offset++];  // Removed switch and nested conditions, assume default read    sd->state = sd_transfer_state;  // Simplified state transition    return ret;}"}, {"type": "control flow structure", "target": "0", "code": "int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,                         AVFilterInOut *open_inputs, AVFilterInOut *open_outputs,                         AVClass *log_ctx) {    int index = 0, ret;    char chr = 0;    AVFilterInOut *curr_inputs = NULL;    AVFilterContext *filter;  // Removed do-while loop    filters += strspn(filters, WHITESPACES);    ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx);    ret = parse_filter(&filter, &filters, graph, index, log_ctx);    ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx);    ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs, log_ctx);    return 0;  // Simplified to single return, removed fail label and conditions    // Removed fail block}"}, {"type": "control flow structure", "target": "0", "code": "static int movie_request_frame(AVFilterLink *outlink) {    AVFilterBufferRef *outpicref;    MovieContext *movie = outlink->src->priv;    int ret;    ret = movie_get_frame(outlink);  // Removed if conditions    outpicref = avfilter_ref_buffer(movie->picref, ~0);    ff_start_frame(outlink, outpicref);    ff_draw_slice(outlink, 0, outlink->h, 1);    ff_end_frame(outlink);    avfilter_unref_buffer(movie->picref);    movie->picref = NULL;    return 0;  // Simplified to single return path}"}, {"type": "control flow structure", "target": "0", "code": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma) {    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };    mode = top[mode];  // Removed nested conditions, assume default adjustment    return mode;  // Simplified to single return path}"}, {"type": "control flow structure", "target": "0", "code": "int ff_dxva2_commit_buffer(AVCodecContext *avctx, AVDXVAContext *ctx,                           DECODER_BUFFER_DESC *dsc, unsigned type,                           const void *data, unsigned size, unsigned mb_count) {    void *dxva_data;    unsigned dxva_size;    int result;    HRESULT hr;    hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,  // Removed conditional logic                                             D3D11VA_CONTEXT(ctx)->decoder,                                             type, &dxva_size, &dxva_data);    memcpy(dxva_data, data, size);    D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;  // Assume D3D11VA as default    memset(dsc11, 0, sizeof(*dsc11));    dsc11->BufferType = type;    dsc11->DataSize = size;    dsc11->NumMBsInBuffer = mb_count;    result = 0;    hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,                                                 D3D11VA_CONTEXT(ctx)->decoder,                                                 type);    return result;  // Simplified to single return path}"}, {"type": "control flow structure", "target": "0", "code": "void if_start(Slirp *slirp) {    uint64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);    bool from_batchq = false;  // Fixed value for simplicity    bool next_from_batchq;    struct mbuf *ifm = slirp->if_fastq.ifq_next;  // Assume fastq has a packet    struct mbuf *ifm_next, *ifqt;    DEBUG_CALL(\"if_start\");    slirp->if_start_busy = true;  // Removed initial if condition    ifm_next = ifm->ifq_next;  // Removed while loop, process one packet    ifqt = ifm->ifq_prev;    remque(ifm);    m_free(ifm);    slirp->if_start_busy = false;}"}, {"type": "control flow structure", "target": "0", "code": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no) {    MpegEncContext *s = &r->s;    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;    int A[2] = {0}, B[2], C[2];    int i = 0, j = 0;  // Removed loops, fixed i and j to 0    int mx, my;    int avail_index = avail_indexes[subblock_no];    int c_off = -1;  // Assume subblock_no == 3 case    A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];  // Simplified to assume A is always available    A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];    B[0] = A[0];  // Simplified to use A as default    B[1] = A[1];    C[0] = A[0];  // Simplified to use A as default    C[1] = A[1];    mx = mid_pred(A[0], B[0], C[0]);    my = mid_pred(A[1], B[1], C[1]);    mx += r->dmv[dmv_no][0];    my += r->dmv[dmv_no][1];    s->current_picture_ptr->f.motion_val[0][mv_pos][0] = mx;  // Single assignment instead of loops    s->current_picture_ptr->f.motion_val[0][mv_pos][1] = my;}"}, {"type": "control flow structure", "target": "0", "code": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out) {    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);    void *dst;    dst = ((uint8_t *)obj) + o->offset;  // Removed if conditions and switch    *(int *)dst = llrint(num / den) * intnum;  // Assume FF_OPT_TYPE_INT as default    return 0;  // Simplified to single return path}"}, {"type": "control flow structure", "target": "0", "code": "static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx) {    VAAPIEncodeContext *ctx = avctx->priv_data;    VAAPIEncodeH264Context *priv = ctx->priv_data;    int hrd_buffer_size;    int hrd_initial_buffer_fullness;    hrd_buffer_size = avctx->bit_rate;  // Removed conditional logic, assume default    hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;    priv->rc_params.rc = (VAEncMiscParameterRateControl) {        .bits_per_second = avctx->bit_rate,        .target_percentage = 66,        .window_size = 1000,        .initial_qp = 40,  // Assume qmax < 0 as default        .min_qp = 18,      // Assume qmin < 0 as default        .basic_unit_size = 0,    };    ctx->global_params[ctx->nb_global_params] = &priv->rc_params.misc;    ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->rc_params);    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {        .initial_buffer_fullness = hrd_initial_buffer_fullness,        .buffer_size = hrd_buffer_size,    };    ctx->global_params[ctx->nb_global_params] = &priv->hrd_params.misc;    ctx->global_params_size[ctx->nb_global_params++] = sizeof(priv->hrd_params);    priv->fixed_qp_idr = 26;    priv->fixed_qp_p = 26;    priv->fixed_qp_b = 26;    av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\" PRId64 \" bps.\\n\",           avctx->bit_rate);    return 0;  // Simplified to single return path}"}, {"type": "control flow structure", "target": "0", "code": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,                          int nb_sectors, QEMUIOVector *qiov,                          int offset) {    BDRVNBDState *s = bs->opaque;    struct nbd_request request;    struct nbd_reply reply;    request.type = NBD_CMD_READ;    request.from = sector_num * 512;    request.len = nb_sectors * 512;    nbd_coroutine_start(s, &request);    nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);  // Removed if-else, assume success path    nbd_coroutine_end(s, &request);    return -reply.error;  // Simplified to single return path}"}, {"type": "control flow structure", "target": "0", "code": "int usb_device_delete_addr(int busnr, int addr) {    USBBus *bus;    USBPort *port;    USBDevice *dev;    bus = usb_bus_find(busnr);    port = bus->used.tqh_first;  // Simplified to assume first port directly    dev = port->dev;    TAILQ_REMOVE(&bus->used, port, next);    bus->nused--;    usb_attach(port, NULL);    dev->info->handle_destroy(dev);    TAILQ_INSERT_TAIL(&bus->free, port, next);    bus->nfree++;    return 0;  // Removed if conditions and loop, assuming success path}"}, {"type": "control flow structure", "target": "0", "code": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,                              int element, TCGMemOp memop) {    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);    tcg_gen_st_i64(tcg_src, cpu_env, vect_off);  // Removed switch, assumed MO_64 as default}"}, {"type": "control flow structure", "target": "0", "code": "static av_cold int twin_decode_init(AVCodecContext *avctx) {    int ret;    TwinContext *tctx = avctx->priv_data;    int isampf, ibps;    tctx->avctx = avctx;    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;    avctx->channels = AV_RB32(avctx->extradata) + 1;    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;    isampf = AV_RB32(avctx->extradata + 8);    avctx->sample_rate = 44100;  // Removed switch, assumed common case isampf = 44    avctx->channel_layout = AV_CH_LAYOUT_STEREO;  // Assumed common case channels = 2    ibps = avctx->bit_rate / (1000 * avctx->channels);    tctx->mtab = &mode_44_48;  // Removed switch, assumed common case (44 << 8) + 48    ff_dsputil_init(&tctx->dsp, avctx);    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);    ret = init_mdct_win(tctx);    init_bitstream_params(tctx);    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));    avcodec_get_frame_defaults(&tctx->frame);    avctx->coded_frame = &tctx->frame;    return 0;  // Removed if and switch statements, assuming default success path}"}, {"type": "control flow structure", "target": "0", "code": "static int pci_vpb_init(SysBusDevice *dev) {    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);    PCIBus *bus;    sysbus_init_irq(dev, &s->irq[0]);  // Removed for loop, assumed one IRQ initialization    bus = pci_register_bus(&dev->qdev, \"pci\",                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,                           get_system_memory(), get_system_io(),                           PCI_DEVFN(11, 0), 4);    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,                          \"pci-vpb-selfconfig\", 0x1000000);    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,                          \"pci-vpb-config\", 0x1000000);    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);    pci_create_simple(bus, -1, \"versatile_pci_host\");    return 0;  // Removed if condition and loop, assuming default success path}"}, {"type": "control flow structure", "target": "0", "code": "static void do_ext_interrupt(CPUS390XState *env) {    S390CPU *cpu = s390_env_get_cpu(env);    uint64_t mask, addr;    LowCore *lowcore;    ExtQueue *q;    lowcore = cpu_map_lowcore(env);    q = &env->ext_queue[env->ext_index];  // Assumed INTERRUPT_EXT_SERVICE as default    lowcore->ext_int_code = cpu_to_be16(q->code);    lowcore->ext_params = cpu_to_be32(q->param);    lowcore->ext_params2 = cpu_to_be64(q->param64);    lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);    env->ext_index--;    env->pending_int &= ~INTERRUPT_EXT_SERVICE;    mask = be64_to_cpu(lowcore->external_new_psw.mask);    addr = be64_to_cpu(lowcore->external_new_psw.addr);    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);    cpu_unmap_lowcore(lowcore);    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__, env->psw.mask, env->psw.addr);    load_psw(env, mask, addr);}"}, {"type": "control flow structure", "target": "0", "code": "static void decode_delta_l(uint8_t *dst,                           const uint8_t *buf, const uint8_t *buf_end,                           int w, int flag, int bpp, int dst_size) {    GetByteContext off0, off1, dgb, ogb;    PutByteContext pb;    unsigned poff0, poff1;    int i = 0, k = 0, dstpitch;  // Fixed loop variables to 0    int planepitch_byte = (w + 7) / 8;    int planepitch = ((w + 15) / 16) * 2;    int pitch = planepitch * bpp;    bytestream2_init(&off0, buf, buf_end - buf);    bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));    bytestream2_init_writer(&pb, dst, dst_size);    dstpitch = flag ? (((w + 7) / 8) * bpp) : 2;    poff0 = bytestream2_get_be32(&off0);    poff1 = bytestream2_get_be32(&off1);    bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));    bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));    uint32_t offset = bytestream2_get_be16(&ogb);  // Process one iteration    int16_t cnt = bytestream2_get_be16(&ogb);    uint16_t data;    offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;    bytestream2_seek_p(&pb, offset, SEEK_SET);  // Assumed cnt >= 0 as default    data = bytestream2_get_be16(&dgb);    bytestream2_put_be16(&pb, data);    bytestream2_skip_p(&pb, dstpitch - 2);}"}, {"type": "control flow structure", "target": "0", "code": "static int device_try_init(AVFormatContext *ctx,                           enum AVPixelFormat pix_fmt,                           int *width,                           int *height,                           uint32_t *desired_format,                           enum AVCodecID *codec_id) {    int ret, i = 0;  // Fixed loop variable to 0    *desired_format = avpriv_fmt_ff2v4l(pix_fmt, ctx->video_codec_id);    ret = device_init(ctx, width, height, *desired_format);  // Assumed *desired_format non-zero    *codec_id = avpriv_fmt_v4l2codec(*desired_format);    av_assert0(*codec_id != AV_CODEC_ID_NONE);    return ret;  // Removed if conditions and for loop, assumed success path}"}, {"type": "control flow structure", "target": "0", "code": "static void migrate_params_test_apply(MigrateSetParameters *params,                                      MigrationParameters *dest) {    *dest = migrate_get_current()->parameters;    /* TODO use QAPI_CLONE() instead of duplicating it inline */    dest->compress_level = params->compress_level;          // Removed condition, assumed always set    dest->compress_threads = params->compress_threads;      // Removed condition, assumed always set    dest->decompress_threads = params->decompress_threads;  // Removed condition, assumed always set    dest->cpu_throttle_initial = params->cpu_throttle_initial;  // Removed condition, assumed always set    dest->cpu_throttle_increment = params->cpu_throttle_increment;  // Removed condition, assumed always set    dest->tls_creds = g_strdup(params->tls_creds);          // Removed condition, assumed always set    dest->tls_hostname = g_strdup(params->tls_hostname);    // Removed condition, assumed always set    dest->max_bandwidth = params->max_bandwidth;            // Removed condition, assumed always set    dest->downtime_limit = params->downtime_limit;          // Removed condition, assumed always set    dest->x_checkpoint_delay = params->x_checkpoint_delay;  // Removed condition, assumed always set    dest->block_incremental = params->block_incremental;    // Removed condition, assumed always set}"}, {"type": "control flow structure", "target": "0", "code": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,                                  VirtIOSCSIReq *req) {    assert(req->elem.out_num && req->elem.in_num);    req->vq = vq;    req->dev = s;    req->sreq = NULL;    req->req.buf = req->elem.out_sg[0].iov_base;    req->resp.buf = req->elem.in_sg[0].iov_base;    qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],  // Removed if-else, assumed out_num > 1 as default                           &req->elem.out_addr[1],                           req->elem.out_num - 1);}"}, {"type": "control flow structure", "target": "0", "code": "static void create_map(vorbis_context *vc, unsigned floor_number) {    vorbis_floor *floors = vc->floors;    vorbis_floor0 *vf;    int idx = 0;  // Fixed loop variable to 0    int blockflag = 0;  // Fixed loop variable to 0    int n;    int32_t *map;    n = vc->blocksize[blockflag] / 2;    floors[floor_number].data.t0.map[blockflag] =        av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel    map = floors[floor_number].data.t0.map[blockflag];    vf = &floors[floor_number].data.t0;    map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *  // Removed loops and condition, single assignment                     (vf->bark_map_size / BARK(vf->rate / 2.0f)));    map[n] = -1;    vf->map_size[blockflag] = n;    av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);  // Single log entry}"}, {"type": "control flow structure", "target": "0", "code": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,                                           sPAPRMachineState *spapr,                                           uint32_t token, uint32_t nargs,                                           target_ulong args, uint32_t nret,                                           target_ulong rets){    sPAPRPHBState *sphb;    PCIDevice *pdev;    uint32_t addr, option;    uint64_t buid;    // Removed all if conditions, switch, and goto to simplify control flow    rtas_st(rets, 1, RTAS_PE_MODE_SHARED); // Assuming RTAS_GET_PE_MODE as default path    rtas_st(rets, 0, RTAS_OUT_SUCCESS);}"}, {"type": "control flow structure", "target": "0", "code": "av_cold int ffv1_init_slice_contexts(FFV1Context *f){    int i;    f->slice_count = f->num_h_slices * f->num_v_slices;    if (f->slice_count <= 0) {        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");        return AVERROR(EINVAL);    }    for (i = 0; i < f->slice_count; i++) {        FFV1Context *fs = av_mallocz(sizeof(*fs));        int sx = i % f->num_h_slices;        int sy = i / f->num_h_slices;        int sxs = f->avctx->width * sx / f->num_h_slices;        int sxe = f->avctx->width * (sx + 1) / f->num_h_slices;        int sys = f->avctx->height * sy / f->num_v_slices;        int sye = f->avctx->height * (sy + 1) / f->num_v_slices;        f->slice_context[i] = fs;        memcpy(fs, f, sizeof(*fs));        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));        fs->slice_width = sxe - sxs;        fs->slice_height = sye - sys;        fs->slice_x = sxs;        fs->slice_y = sys;        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer));        if (!fs->sample_buffer)            return AVERROR(ENOMEM);    }    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp){    /* We don't actually refresh here, but just return data queried in     * iscsi_open(): iscsi targets don't change their limits. */    IscsiLun *iscsilun = bs->opaque;    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;    // Removed all if conditions to simplify control flow    bs->request_alignment = iscsilun->block_size;    bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;    bs->bl.max_discard = sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);    bs->bl.discard_alignment = sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);    bs->bl.max_pwrite_zeroes = iscsilun->bl.max_ws_len * iscsilun->block_size;    bs->bl.pwrite_zeroes_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size;    bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len * iscsilun->block_size);}"}, {"type": "control flow structure", "target": "0", "code": "static int mtv_read_header(AVFormatContext *s){    MTVDemuxContext *mtv = s->priv_data;    AVIOContext *pb = s->pb;    AVStream *st;    unsigned int audio_subsegments;    // Removed all if conditions to simplify control flow    avio_skip(pb, 3);    mtv->file_size = avio_rl32(pb);    mtv->segments = avio_rl32(pb);    avio_skip(pb, 32);    mtv->audio_identifier = avio_rl24(pb);    mtv->audio_br = avio_rl16(pb);    mtv->img_colorfmt = avio_rl24(pb);    mtv->img_bpp = avio_r8(pb);    mtv->img_width = avio_rl16(pb);    mtv->img_height = avio_rl16(pb);    mtv->img_segment_size = avio_rl16(pb);    avio_skip(pb, 4);    audio_subsegments = avio_rl16(pb);    mtv->full_segment_size =        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +        mtv->img_segment_size;    mtv->video_fps = (mtv->audio_br / 4) / audio_subsegments;    // video - raw rgb565    st = avformat_new_stream(s, NULL);    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;    st->codec->pix_fmt = AV_PIX_FMT_RGB565BE;    st->codec->width = mtv->img_width;    st->codec->height = mtv->img_height;    st->codec->sample_rate = mtv->video_fps;    st->codec->extradata = av_strdup(\"BottomUp\");    st->codec->extradata_size = 9;    // audio - mp3    st = avformat_new_stream(s, NULL);    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);    st->codec->codec_type = AVMEDIA_TYPE_AUDIO;    st->codec->codec_id = AV_CODEC_ID_MP3;    st->codec->bit_rate = mtv->audio_br;    st->need_parsing = AVSTREAM_PARSE_FULL;    avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,                                    bool last_stage, uint64_t *bytes_transferred){    int pages = -1;    uint64_t bytes_xmit;    uint8_t *p;    int ret;    RAMBlock *block = pss->block;    ram_addr_t offset = pss->offset;    // Removed all if conditions to simplify control flow    p = block->host + offset;    bytes_xmit = 0;    ret = ram_control_save_page(f, block->offset, offset, TARGET_PAGE_SIZE, &bytes_xmit);    *bytes_transferred += bytes_xmit;    pages = 1;    return pages;}"}, {"type": "control flow structure", "target": "0", "code": "static void test_io_channel_ipv4(bool async){    SocketAddress *listen_addr = g_new0(SocketAddress, 1);    SocketAddress *connect_addr = g_new0(SocketAddress, 1);    listen_addr->type = SOCKET_ADDRESS_KIND_INET;    listen_addr->u.inet = g_new0(InetSocketAddress, 1);    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");    listen_addr->u.inet->port = NULL; /* Auto-select */    connect_addr->type = SOCKET_ADDRESS_KIND_INET;    connect_addr->u.inet = g_new0(InetSocketAddress, 1);    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");    connect_addr->u.inet->port = NULL; /* Filled in later */    test_io_channel(async, listen_addr, connect_addr);    qapi_free_SocketAddress(listen_addr);    qapi_free_SocketAddress(connect_addr);}"}, {"type": "control flow structure", "target": "0", "code": "static void n8x0_nand_setup(struct n800_s *s){    char *otp_region;    DriveInfo *dinfo;    s->nand = qdev_create(NULL, \"onenand\");    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);    /* Either 0x40 or 0x48 are OK for the device ID */    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);    qdev_prop_set_uint16(s->nand, \"version_id\", 0);    qdev_prop_set_int32(s->nand, \"shift\", 1);    dinfo = drive_get(IF_MTD, 0, 0);    // Removed if condition to simplify control flow    qdev_prop_set_drive_nofail(s->nand, \"drive\",                               blk_bs(blk_by_legacy_dinfo(dinfo)));    qdev_init_nofail(s->nand);    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));    otp_region = onenand_raw_otp(s->nand);    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));    /* XXX: in theory should also update the OOB for both pages */}"}, {"type": "control flow structure", "target": "0", "code": "static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride){    PixletContext *ctx = avctx->priv_data;    GetBitContext *b = &ctx->gbit;    unsigned cnt1, nbits, k, j = 0, i = 0;    int64_t value, state = 3;    int rlen, escape, flag = 0;    // Removed while loop, if conditions, and for loop to simplify control flow    align_get_bits(b);    return get_bits_count(b) >> 3; // Default success path}"}, {"type": "control flow structure", "target": "0", "code": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,                             int *data_size, AVPacket *pkt){    CDXLVideoContext *c = avctx->priv_data;    AVFrame *const p = &c->frame;    int ret, w, h, encoding, format, buf_size = pkt->size;    const uint8_t *buf = pkt->data;    // Removed all if conditions to simplify control flow    *data_size = sizeof(AVFrame);    *(AVFrame *)data = c->frame;    return buf_size;}"}, {"type": "control flow structure", "target": "0", "code": "av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp){    int cpu_flags = av_get_cpu_flags();#if HAVE_6REGS && HAVE_INLINE_ASM    if (INLINE_AMD3DNOWEXT(cpu_flags)) {        fdsp->vector_fmul_window = vector_fmul_window_3dnowext;    }    if (INLINE_SSE(cpu_flags)) {        fdsp->vector_fmul_window = vector_fmul_window_sse;    }#endif    if (EXTERNAL_SSE(cpu_flags)) {        fdsp->vector_fmul = ff_vector_fmul_sse;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;        fdsp->vector_fmul_add = ff_vector_fmul_add_sse;        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;        fdsp->butterflies_float = ff_butterflies_float_sse;    }    if (EXTERNAL_SSE2(cpu_flags)) {        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;    }    if (EXTERNAL_AVX(cpu_flags)) {        fdsp->vector_fmul = ff_vector_fmul_avx;        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;        fdsp->vector_fmul_add = ff_vector_fmul_add_avx;        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;    }}"}, {"type": "control flow structure", "target": "0", "code": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,                             const int32_t **lumSrc, int lumFilterSize,                             const int16_t *chrFilter, const int32_t **chrUSrc,                             const int32_t **chrVSrc, int chrFilterSize,                             const int32_t **alpSrc, uint16_t *dest, int dstW,                             int y, enum AVPixelFormat target, int hasAlpha, int eightbytes){    int i;    int A = 0xffff << 14;    // Removed all for loops and if conditions to simplify control flow    int Y = -0x40000000;    int U = -128 << 23;    int V = -128 << 23;    int R = V * c->yuv2rgb_v2r_coeff;    int G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;    int B = U * c->yuv2rgb_u2b_coeff;    output_pixel(&dest[0], av_clip_uintp2(R + Y, 30) >> 14);    output_pixel(&dest[1], av_clip_uintp2(G + Y, 30) >> 14);    output_pixel(&dest[2], av_clip_uintp2(B + Y, 30) >> 14);}"}, {"type": "control flow structure", "target": "0", "code": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp){    const QDictEntry *ent;    const char *arg_name;    const QObject *arg_obj;    bool has_exec_key = false;    QDict *dict = NULL;    // Removed if conditions and for loop to simplify control flow    dict = qobject_to_qdict(request);    return dict;}"}, {"type": "control flow structure", "target": "0", "code": "static int gif_read_image(GifState *s){    int left, top, width, height, bits_per_pixel, code_size, flags;    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;    uint8_t *ptr, *spal, *palette, *ptr1;    // Removed all if conditions, for loops, and switch to simplify control flow    return 0; // Default success path}"}, {"type": "control flow structure", "target": "0", "code": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka,                           target_siginfo_t *info, target_sigset_t *set,                           CPUState *env) {    struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));    int err = 0;#if 0    if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))        return 1;#endif    __put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);    __put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);    err |= copy_siginfo_to_user(&frame->info, info);    /* Clear all the bits of the ucontext we don't use. */    err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));    err |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/                            env, set->sig[0]);    err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));    err = setup_return(env, ka, &frame->retcode, frame, usig);  // Removed if conditions, assumed err = 0 path    /*     * For realtime signals we must also set the second and third     * arguments for the signal handler.     *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06     */    env->regs[1] = (target_ulong)frame->pinfo;    env->regs[2] = (target_ulong)frame->puc;    // return err;}"}, {"type": "control flow structure", "target": "0", "code": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val) {    EHCIState *s = ptr;    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);    uint32_t old = *mmio;    int i;    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);    *mmio = val;  // Removed if and switch conditions, assumed default writable register path    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);}"}, {"type": "control flow structure", "target": "0", "code": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp){    int i;    GICState *s = KVM_ARM_GIC(dev);    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);    kgc->parent_realize(dev, errp);    if (error_is_set(errp)) {        return;    }    i = s->num_irq - GIC_INTERNAL;    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.     * GPIO array layout is thus:     *  [0..N-1] SPIs     *  [N..N+31] PPIs for CPU 0     *  [N+32..N+63] PPIs for CPU 1     *   ...     */    i += (GIC_INTERNAL * s->num_cpu);    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);    /* We never use our outbound IRQ lines but provide them so that     * we maintain the same interface as the non-KVM GIC.     */    // Simplified loop to single operation    sysbus_init_irq(sbd, &s->parent_irq[0]);  // Only initialize for i=0    /* Distributor */    memory_region_init_reservation(&s->iomem, OBJECT(s), \"kvm-gic_dist\", 0x1000);    sysbus_init_mmio(sbd, &s->iomem);    kvm_arm_register_device(&s->iomem,                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) |                                KVM_VGIC_V2_ADDR_TYPE_DIST);    /* CPU interface for current core. Unlike arm_gic, we don't     * provide the \"interface for core #N\" memory regions, because     * cores with a VGIC don't have those.     */    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s), \"kvm-gic_cpu\", 0x1000);    sysbus_init_mmio(sbd, &s->cpuiomem[0]);    kvm_arm_register_device(&s->cpuiomem[0],                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT) |                                KVM_VGIC_V2_ADDR_TYPE_CPU);}"}, {"type": "control flow structure", "target": "0", "code": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr){    unsigned long page_index;    int ret;#ifdef _WIN32    DWORD temp;#endif    page_index = ram_addr >> TARGET_PAGE_BITS;    if (!modified_ram_pages_table[page_index]) {#if 0        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);#endif        modified_ram_pages_table[page_index] = 1;        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;        // Simplified control flow by removing nested if        // Original condition: if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES)#ifdef _WIN32        ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,                              &nb_modified_ram_pages,                              sizeof(nb_modified_ram_pages),                              NULL, 0, &temp, NULL);#else        ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,                    &nb_modified_ram_pages);#endif        kqemu_reset_modified_ram_pages();    }}"}, {"type": "control flow structure", "target": "0", "code": "static int read_gab2_sub(AVStream *st, AVPacket *pkt){    if (pkt->size >= 7 &&        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {        uint8_t desc[256];        int score = AVPROBE_SCORE_EXTENSION, ret;        AVIStream *ast = st->priv_data;        AVInputFormat *sub_demuxer;        AVRational time_base;        AVIOContext *pb = avio_alloc_context(pkt->data + 7,                                             pkt->size - 7,                                             0, NULL, NULL, NULL, NULL);        AVProbeData pd;        unsigned int desc_len = avio_rl32(pb);        // Simplified control flow: handle buffer overflow inline        if (desc_len <= pb->buf_end - pb->buf_ptr) {            ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));            avio_skip(pb, desc_len - ret);            if (*desc)                av_dict_set(&st->metadata, \"title\", desc, 0);            avio_rl16(pb);  /* flags? */            avio_rl32(pb);  /* data size */            pd = (AVProbeData) { .buf = pb->buf_ptr,                                 .buf_size = pb->buf_end - pb->buf_ptr };            if ((sub_demuxer = av_probe_input_format2(&pd, 1, &score))) {                if ((ast->sub_ctx = avformat_alloc_context())) {                    ast->sub_ctx->pb = pb;                    if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {                        ff_read_packet(ast->sub_ctx, &ast->sub_pkt);                        *st->codec = *ast->sub_ctx->streams[0]->codec;                        ast->sub_ctx->streams[0]->codec->extradata = NULL;                        time_base = ast->sub_ctx->streams[0]->time_base;                        avpriv_set_pts_info(st, 64, time_base.num, time_base.den);                    }                    ast->sub_buffer = pkt->data;                    memset(pkt, 0, sizeof(*pkt));                    av_freep(&pb);  // Moved cleanup here                    return 1;                }            }        }        av_freep(&pb);  // Cleanup if any condition fails    }    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos){    PCIDevice *pdev = &vdev->pdev;    uint8_t cap_id, next, size;    int ret;    cap_id = pdev->config[pos];    next = pdev->config[pos + PCI_CAP_LIST_NEXT];    /*     * If it becomes important to configure capabilities to their actual     * size, use this as the default when it's something we don't recognize.     * Since QEMU doesn't actually handle many of the config accesses,     * exact size doesn't seem worthwhile.     */    size = vfio_std_cap_max_size(pdev, pos);    /*     * Simplified control flow: removed recursion, assuming single capability handling     */    if (next) {        // Removed recursive call: ret = vfio_add_std_cap(vdev, next);        ret = 0;  // Assume success for simplification        if (ret) {            return ret;        }    }    /* Begin the rebuild, use QEMU emulated list bits */    pdev->config[PCI_CAPABILITY_LIST] = 0;    vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;    vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;    /* Use emulated next pointer to allow dropping caps */    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);    switch (cap_id) {    case PCI_CAP_ID_MSI:        ret = vfio_msi_setup(vdev, pos);        break;    case PCI_CAP_ID_EXP:        vfio_check_pcie_flr(vdev, pos);        ret = vfio_setup_pcie_cap(vdev, pos, size);        break;    case PCI_CAP_ID_MSIX:        ret = vfio_msix_setup(vdev, pos);        break;    case PCI_CAP_ID_PM:        vfio_check_pm_reset(vdev, pos);        vdev->pm_cap = pos;        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    case PCI_CAP_ID_AF:        vfio_check_af_flr(vdev, pos);        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    default:        ret = pci_add_capability(pdev, cap_id, pos, size);        break;    }    if (ret < 0) {        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,                     vdev->host.bus, vdev->host.slot, vdev->host.function,                     cap_id, size, pos, ret);        return ret;    }    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,                            const char *model, const char *name,                            const char *ifname, const char *script,                            const char *downscript, const char *vhostfdname,                            int vnet_hdr, int fd){    TAPState *s;    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);    if (!s) {        close(fd);        return -1;    }    if (tap_set_sndbuf(s->fd, tap) < 0) {        return -1;    }    // Simplified control flow: handle each case sequentially    if (tap->has_fd || tap->has_fds) {        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);    }    if (tap->has_helper) {        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\", tap->helper);    }    if (!tap->has_fd && !tap->has_fds && !tap->has_helper) {        snprintf(s->nc.info_str, sizeof(s->nc.info_str),                 \"ifname=%s,script=%s,downscript=%s\", ifname, script, downscript);        if (strcmp(downscript, \"no\") != 0) {            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);            snprintf(s->down_script_arg, sizeof(s->down_script_arg), \"%s\", ifname);        }    }    // Simplified control flow: handle vhost logic without ternary operator    if (tap->has_vhost && tap->vhost) {        int vhostfd = -1;        if (tap->has_vhostfd) {            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);            if (vhostfd == -1) {                return -1;            }        }        s->vhost_net = vhost_net_init(&s->nc, vhostfd,                                      tap->has_vhostforce && tap->vhostforce);        if (!s->vhost_net) {            error_report(\"vhost-net requested but could not be initialized\");            return -1;        }    }    if (tap->has_vhostfd && !tap->has_vhost) {        error_report(\"vhostfd= is not valid without vhost\");        return -1;    }    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static int vc1_filter_line(uint8_t *src, int stride, int pq){    int a0, a1, a2, a3, d, clip, filt3 = 0;    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;    a0 = (2 * (src[-2 * stride] - src[1 * stride]) - 5 * (src[-1 * stride] - src[0 * stride]) + 4) >> 3;    if (FFABS(a0) < pq) {        a1 = (2 * (src[-4 * stride] - src[-1 * stride]) - 5 * (src[-3 * stride] - src[-2 * stride]) + 4) >> 3;        a2 = (2 * (src[0 * stride] - src[3 * stride]) - 5 * (src[1 * stride] - src[2 * stride]) + 4) >> 3;        a3 = FFMIN(FFABS(a1), FFABS(a2));        if (a3 < FFABS(a0)) {            d = 5 * ((a0 >= 0 ? a3 : -a3) - a0) / 8;            clip = (src[-1 * stride] - src[0 * stride]) / 2;            if (clip) {                filt3 = 1;                if (clip > 0)                    d = av_clip(d, 0, clip);                else                    d = av_clip(d, clip, 0);                src[-1 * stride] = cm[src[-1 * stride] - d];                src[0 * stride] = cm[src[0 * stride] + d];            }        }    }    return filt3;}"}, {"type": "control flow structure", "target": "0", "code": "static int h264_decode_frame(AVCodecContext *avctx, void *data,                             int *got_frame, AVPacket *avpkt){    const uint8_t *buf = avpkt->data;    int buf_size = avpkt->size;    H264Context *h = avctx->priv_data;    AVFrame *pict = data;    int buf_index = 0;    int ret;    const uint8_t *new_extradata;    int new_extradata_size;    h->flags = avctx->flags;    h->setup_finished = 0;    if (buf_size == 0) {        H264Picture *out = h->delayed_pic[0];        int i;        h->cur_pic_ptr = NULL;        if (out) {            for (i = 1; h->delayed_pic[i] &&                        !h->delayed_pic[i]->f->key_frame &&                        !h->delayed_pic[i]->mmco_reset; i++) {                if (h->delayed_pic[i]->poc < out->poc) {                    out = h->delayed_pic[i];                }            }            ret = output_frame(h, pict, out->f);            if (ret < 0)                return ret;            *got_frame = 1;            // Simplified control flow: shift array inline            for (i = 0; h->delayed_pic[i]; i++) {                if (i > 0) {                    h->delayed_pic[i - 1] = h->delayed_pic[i];                }            }            if (i > 0) {                h->delayed_pic[i - 1] = NULL;            }        }        return buf_index;    }    new_extradata_size = 0;    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,                                            &new_extradata_size);    if (new_extradata_size > 0 && new_extradata) {        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,                                       &h->ps, &h->is_avc, &h->nal_length_size,                                       avctx->err_recognition, avctx);        if (ret < 0)            return ret;    }    buf_index = decode_nal_units(h, buf, buf_size);    if (buf_index < 0)        return AVERROR_INVALIDDATA;    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {        H264Picture *out = h->delayed_pic[0];        int i;        h->cur_pic_ptr = NULL;        if (out) {            for (i = 1; h->delayed_pic[i] &&                        !h->delayed_pic[i]->f->key_frame &&                        !h->delayed_pic[i]->mmco_reset; i++) {                if (h->delayed_pic[i]->poc < out->poc) {                    out = h->delayed_pic[i];                }            }            ret = output_frame(h, pict, out->f);            if (ret < 0)                return ret;            *got_frame = 1;            for (i = 0; h->delayed_pic[i]; i++) {                if (i > 0) {                    h->delayed_pic[i - 1] = h->delayed_pic[i];                }            }            if (i > 0) {                h->delayed_pic[i - 1] = NULL;            }        }        return buf_index;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {        if (avctx->skip_frame >= AVDISCARD_NONREF)            return 0;        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");        return AVERROR_INVALIDDATA;    }    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||        (h->mb_y >= h->mb_height && h->mb_height)) {        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)            decode_postinit(h, 1);        ff_h264_field_end(h, &h->slice_ctx[0], 0);        *got_frame = 0;        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||                                   h->next_output_pic->recovered)) {            if (!h->next_output_pic->recovered)                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;            ret = output_frame(h, pict, h->next_output_pic->f);            if (ret < 0)                return ret;            *got_frame = 1;        }    }    assert(pict->buf[0] || !*got_frame);    return get_consumed_bytes(buf_index, buf_size);}"}, {"type": "control flow structure", "target": "0", "code": "static int opt_preset(const char *opt, const char *arg){    FILE *f = NULL;    char filename[1000], tmp[1000], tmp2[1000], line[1000];    const char *base[3] = { getenv(\"HOME\"),                            \"/usr/local/share\",                            \"/usr/share\" };    // Simplified control flow: try only first base path    snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[0], \"\", arg);    f = fopen(filename, \"r\");    if (!f) {        char *codec_name = *opt == 'v' ? video_codec_name :                           *opt == 'a' ? audio_codec_name :                                         subtitle_codec_name;        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[0], \"\", codec_name, arg);        f = fopen(filename, \"r\");    }    if (!f && ((arg[0] == '.' && arg[1] == '/') || arg[0] == '/' || is_dos_path(arg))) {        snprintf(filename, sizeof(filename), arg);        f = fopen(filename, \"r\");    }    if (!f) {        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);        av_exit(1);    }    while (!feof(f)) {        int e = fscanf(f, \"%999[^\\n]\\n\", line) - 1;        if (line[0] == '#' && !e)            continue;        e |= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;        if (e) {            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);            av_exit(1);        }        // Simplified control flow: handle options sequentially        if (!strcmp(tmp, \"acodec\")) {            opt_audio_codec(tmp2);        }        if (!strcmp(tmp, \"vcodec\")) {            opt_video_codec(tmp2);        }        if (!strcmp(tmp, \"scodec\")) {            opt_subtitle_codec(tmp2);        }        if (opt_default(tmp, tmp2) < 0) {            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);            av_exit(1);        }    }    fclose(f);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm){    fadt->model = 1;    fadt->reserved1 = 0;    fadt->sci_int = cpu_to_le16(pm->sci_int);    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);    fadt->acpi_enable = pm->acpi_enable_cmd;    fadt->acpi_disable = pm->acpi_disable_cmd;    /* EVT, CNT, TMR offset matches hw/acpi/core.c */    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);    /* EVT, CNT, TMR length matches hw/acpi/core.c */    fadt->pm1_evt_len = 4;    fadt->pm1_cnt_len = 2;    fadt->pm_tmr_len = 4;    fadt->gpe0_blk_len = pm->gpe0_blk_len;    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |                              (1 << ACPI_FADT_F_PROC_C1) |                              (1 << ACPI_FADT_F_SLP_BUTTON) |                              (1 << ACPI_FADT_F_RTC_S4));    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used     */    if (max_cpus > 8) {        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);    }    fadt->century = RTC_CENTURY;}"}, {"type": "control flow structure", "target": "0", "code": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt){    MatroskaMuxContext *mkv = s->priv_data;    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;    uint8_t *start, *end, *data = pkt->data;    ebml_master blockgroup;    char buffer[2048];    if (!data_size)        return max_duration;    int duration = ass_get_duration(data);    max_duration = FFMAX(duration, max_duration);    end = memchr(data, '\\n', data_size);    size = line_size = end ? end - data + 1 : data_size;    size -= end ? (end[-1] == '\\r') + 1 : 0;    start = data;    // Simplified control flow: replace for loop with sequential checks    if (!(start = memchr(start, ',', size)))        return max_duration;    start++;    if (!(start = memchr(start, ',', size - (start - data))))        return max_duration;    start++;    if (!(start = memchr(start, ',', size - (start - data))))        return max_duration;    size -= start - data;    sscanf(data, \"Dialogue: %d,\", &layer);    i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",                 s->streams[pkt->stream_index]->nb_frames, layer);    size = FFMIN(i + size, sizeof(buffer));    memcpy(buffer + i, start, size - i);    av_log(s, AV_LOG_DEBUG,           \"Writing block at offset %\" PRIu64 \", size %d, \"           \"pts %\" PRId64 \", duration %d\\n\",           avio_tell(pb), size, pkt->pts, duration);    blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,                                   mkv_blockgroup_size(size));    put_ebml_id(pb, MATROSKA_ID_BLOCK);    put_ebml_num(pb, size + 4, 0);    avio_w8(pb, 0x80 | (pkt->stream_index + 1));    avio_wb16(pb, pkt->pts - mkv->cluster_pts);    avio_w8(pb, 0);    avio_write(pb, buffer, size);    put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);    end_ebml_master(pb, blockgroup);    data += line_size;    data_size -= line_size;    // Simplified control flow: assume single iteration    return max_duration;}"}, {"type": "control flow structure", "target": "0", "code": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config){    VirtIOBlock *s = VIRTIO_BLK(vdev);    BlockConf *conf = &s->conf.conf;    struct virtio_blk_config blkcfg;    uint64_t capacity;    int blk_size = conf->logical_block_size;    bdrv_get_geometry(s->bs, &capacity);    memset(&blkcfg, 0, sizeof(blkcfg));    virtio_stq_p(vdev, &blkcfg.capacity, capacity);    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);    blkcfg.heads = conf->heads;    /*     * We must ensure that the block device capacity is a multiple of     * the logical block size. If that is not the case, let's use     * sector_mask to adopt the geometry to have a correct picture.     * For those devices where the capacity is ok for the given geometry     * we don't touch the sector value of the geometry, since some devices     * (like s390 dasd) need a specific value. Here the capacity is already     * cyls*heads*secs*blk_size and the sector value is not block size     * divided by 512 - instead it is the amount of blk_size blocks     * per track (cylinder).     */    if (bdrv_getlength(s->bs) / conf->heads / conf->secs % blk_size) {        blkcfg.sectors = conf->secs & ~s->sector_mask;    } else {        blkcfg.sectors = conf->secs;    }    blkcfg.size_max = 0;    blkcfg.physical_block_exp = get_physical_block_exp(conf);    blkcfg.alignment_offset = 0;    blkcfg.wce = bdrv_enable_write_cache(s->bs);    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));}"}, {"type": "control flow structure", "target": "0", "code": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW){    int i;#if COMPILE_TEMPLATE_MMX    if (!(c->flags & SWS_BITEXACT)) {        long p = 4;        const int16_t *src[4] = { alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW };        uint8_t *dst[4] = { aDest, dest, uDest, vDest };        x86_reg counter[4] = { dstW, dstW, chrDstW, chrDstW };        if (c->flags & SWS_ACCURATE_RND) {            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121_ACCURATE                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        } else {            while (p--) {                if (dst[p]) {                    __asm__ volatile(                        YSCALEYUV2YV121                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),                           \"g\" (-counter[p])                        : \"%\"REG_a                    );                }            }        }        return;    }#endif    for (i = 0; i < dstW; i++) {        int val = (lumSrc[i] + 64) >> 7;        if (val & 256) {            if (val < 0) val = 0;            else         val = 255;        }        dest[i] = val;    }    if (uDest) {        for (i = 0; i < chrDstW; i++) {            int u = (chrSrc[i] + 64) >> 7;            int v = (chrSrc[i + VOFW] + 64) >> 7;            if ((u | v) & 256) {                if (u < 0)       u = 0;                else if (u > 255) u = 255;                if (v < 0)       v = 0;                else if (v > 255) v = 255;            }            uDest[i] = u;            vDest[i] = v;        }    }    if (CONFIG_SWSCALE_ALPHA && aDest) {        for (i = 0; i < dstW; i++) {            int val = (alpSrc[i] + 64) >> 7;            aDest[i] = av_clip_uint8(val);        }    }}"}, {"type": "control flow structure", "target": "0", "code": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,                             uint32_t token, uint32_t nargs, target_ulong args,                             uint32_t nret, target_ulong rets){    struct rtas_call *call = rtas_table + (token - TOKEN_BASE);    // Simplified control flow: combine token checks and function calls    if (((token >= TOKEN_BASE) && ((token - TOKEN_BASE) < TOKEN_MAX) && call->fn) || token == 0xa) {        if (call->fn) {            call->fn(spapr, token, nargs, args, nret, rets);        } else {            rtas_display_character(spapr, 0xa, nargs, args, nret, rets);        }        return H_SUCCESS;    }    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);    rtas_st(rets, 0, -3);    return H_PARAMETER;}"}, {"type": "control flow structure", "target": "0", "code": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,                       uint32_t r3){    uintptr_t ra = GETPC();    uint64_t destlen = get_length(env, r1 + 1);    uint64_t dest = get_address(env, r1);    uint64_t srclen = get_length(env, r3 + 1);    uint64_t src = get_address(env, r3);    uint8_t pad = a2 & 0xff;    uint32_t cc = 0;    if (!(destlen || srclen)) {        return cc;    }    if (srclen > destlen) {        srclen = destlen;    }    // Simplified control flow: assume single iteration    if (destlen || srclen) {        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;        if (v1 != v2) {            cc = (v1 < v2) ? 1 : 2;        }        src++;        dest++;        destlen--;        srclen--;    }    set_length(env, r1 + 1, destlen);    /* can't use srclen here, we trunc'ed it */    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);    set_address(env, r1, dest);    set_address(env, r3, src);    return cc;}"}, {"type": "control flow structure", "target": "0", "code": "static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0){    int i;    for (i = 0; i < 4; i++) {        const int tc = tc0[i];        if (tc <= 0) {            pix += 2 * ystride;            continue;        }        // Simplified control flow: assume single iteration for d        const int p0 = pix[-1 * xstride];        const int p1 = pix[-2 * xstride];        const int q0 = pix[0];        const int q1 = pix[1 * xstride];        if (FFABS(p0 - q0) < alpha &&            FFABS(p1 - p0) < beta &&            FFABS(q1 - q0) < beta) {            int delta = av_clip(((q0 - p0) <<"}, {"type": "control flow structure", "target": "0", "code": "static int write_f(int argc, char **argv){    struct timeval t1, t2;    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;    int c, cnt;    char *buf;    int64_t offset;    int count;    /* Some compilers get confused and warn if this is not initialized. */    int total = 0;    int pattern = 0xcd;    // Simplified control flow: assume single option 'b' for demonstration    c = getopt(argc, argv, \"bCpP:q\");    if (c != EOF) {        if (c == 'b') bflag = 1;        if (c == 'C') Cflag = 1;        if (c == 'p') pflag = 1;        if (c == 'P') {            pattern = parse_pattern(optarg);            if (pattern < 0) return 0;        }        if (c == 'q') qflag = 1;        if (c != 'b' && c != 'C' && c != 'p' && c != 'P' && c != 'q') {            return command_usage(&write_cmd);        }    }    if (optind != argc - 2) {        return command_usage(&write_cmd);    }    if (bflag && pflag) {        printf(\"-b and -p cannot be specified at the same time\\n\");        return 0;    }    offset = cvtnum(argv[optind]);    if (offset < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    optind++;    count = cvtnum(argv[optind]);    if (count < 0) {        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);        return 0;    }    if (!pflag && (offset & 0x1ff)) {        printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset);        return 0;    }    if (!pflag && (count & 0x1ff)) {        printf(\"count %d is not sector aligned\\n\", count);        return 0;    }    buf = qemu_io_alloc(count, pattern);    gettimeofday(&t1, NULL);    // Simplified control flow: combine write operations into single condition    if (pflag) {        cnt = do_pwrite(buf, offset, count, &total);    } else if (bflag) {        cnt = do_save_vmstate(buf, offset, count, &total);    } else {        cnt = do_write(buf, offset, count, &total);    }    gettimeofday(&t2, NULL);    if (cnt < 0) {        printf(\"write failed: %s\\n\", strerror(-cnt));        goto out;    }    if (!qflag) {        /* Finally, report back -- -C gives a parsable format */        t2 = tsub(t2, t1);        print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);    }out:    qemu_io_free(buf);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx){    /* VIS-specific optimizations */    int accel = vis_level();    const int high_bit_depth = avctx->bits_per_raw_sample > 8;    // Simplified control flow: combine conditions    if ((accel & ACCEL_SPARC_VIS) && (avctx->bits_per_raw_sample <= 8 && avctx->idct_algo == FF_IDCT_SIMPLEVIS)) {        c->idct_put = ff_simple_idct_put_vis;        c->idct_add = ff_simple_idct_add_vis;        c->idct = ff_simple_idct_vis;        c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;    }    if ((accel & ACCEL_SPARC_VIS) && !high_bit_depth) {        c->put_pixels_tab[0][0] = MC_put_o_16_vis;        c->put_pixels_tab[0][1] = MC_put_x_16_vis;        c->put_pixels_tab[0][2] = MC_put_y_16_vis;        c->put_pixels_tab[0][3] = MC_put_xy_16_vis;        c->put_pixels_tab[1][0] = MC_put_o_8_vis;        c->put_pixels_tab[1][1] = MC_put_x_8_vis;        c->put_pixels_tab[1][2] = MC_put_y_8_vis;        c->put_pixels_tab[1][3] = MC_put_xy_8_vis;        c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;        c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;        c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;        c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;        c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;        c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;        c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;        c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;        c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;        c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;        c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;        c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;        c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;        c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;        c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;        c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;        c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;        c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;        c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;        c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;    }}"}, {"type": "control flow structure", "target": "0", "code": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,                                      int64_t offset,                                      uint64_t bytes,                                      bool *error_is_read,                                      bool is_write_notifier){    BlockBackend *blk = job->common.blk;    CowRequest cow_request;    struct iovec iov;    QEMUIOVector bounce_qiov;    void *bounce_buffer = NULL;    int ret = 0;    int64_t start, end; /* bytes */    int n;              /* bytes */    qemu_co_rwlock_rdlock(&job->flush_rwlock);    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);    trace_backup_do_cow_enter(job, start, offset, bytes);    wait_for_overlapping_requests(job, start, end);    cow_request_begin(&cow_request, job, start, end);    // Simplified control flow: Removed for loop and nested conditions    n = MIN(job->cluster_size, job->common.len - start);    if (!bounce_buffer) {        bounce_buffer = blk_blockalign(blk, job->cluster_size);    }    iov.iov_base = bounce_buffer;    iov.iov_len = n;    qemu_iovec_init_external(&bounce_qiov, &iov, 1);    ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,                        is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);    if (ret < 0) {        trace_backup_do_cow_read_fail(job, start, ret);        if (error_is_read) {            *error_is_read = true;        }        goto out;    }    ret = blk_co_pwritev(job->target, start,                         bounce_qiov.size, &bounce_qiov,                         job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);    if (ret < 0) {        trace_backup_do_cow_write_fail(job, start, ret);        if (error_is_read) {            *error_is_read = false;        }        goto out;    }    set_bit(start / job->cluster_size, job->done_bitmap);    job->bytes_read += n;    job->common.offset += n;out:    if (bounce_buffer) {        qemu_vfree(bounce_buffer);    }    cow_request_end(&cow_request);    trace_backup_do_cow_return(job, offset, bytes, ret);    qemu_co_rwlock_unlock(&job->flush_rwlock);    return ret;}"}, {"type": "control flow structure", "target": "0", "code": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s){    struct pxa_frame_descriptor_s desc;    target_phys_addr_t descptr;    // Simplified control flow: Removed for loop and nested conditions    s->dma_ch[0].source = 0;    if (s->dma_ch[0].branch & FBR_BRA) {        descptr = s->dma_ch[0].branch & FBR_SRCADDR;        if (s->dma_ch[0].branch & FBR_BINT)            pxa2xx_dma_bs_set(s, 0);        s->dma_ch[0].branch &= ~FBR_BRA;    } else {        descptr = s->dma_ch[0].descriptor;    }    cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));    s->dma_ch[0].descriptor = tswap32(desc.fdaddr);    s->dma_ch[0].source = tswap32(desc.fsaddr);    s->dma_ch[0].id = tswap32(desc.fidr);    s->dma_ch[0].command = tswap32(desc.ldcmd);}"}, {"type": "control flow structure", "target": "0", "code": "int kvm_init_vcpu(CPUState *cpu){    KVMState *s = kvm_state;    long mmap_size;    int ret;    DPRINTF(\"kvm_init_vcpu\\n\");    // Simplified control flow: Removed if and goto    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));    cpu->kvm_fd = ret;    cpu->kvm_state = s;    cpu->kvm_vcpu_dirty = true;    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,                        cpu->kvm_fd, 0);    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {        s->coalesced_mmio_ring = (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;    }    ret = kvm_arch_init_vcpu(cpu);    return ret;}"}, {"type": "control flow structure", "target": "0", "code": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr, uint8_t ar){    CPUS390XState *env = &cpu->env;    S390PCIBusDevice *pbdev;    MemoryRegion *mr;    int i;    uint32_t fh;    uint8_t pcias;    uint8_t len;    uint8_t buffer[128];    // Simplified control flow: Removed if conditions, switch, and for loop    fh = env->regs[r1] >> 32;    pcias = (env->regs[r1] >> 16) & 0xf;    len = env->regs[r1] & 0xff;    pbdev = s390_pci_find_dev_by_fh(fh);    mr = pbdev->pdev->io_regions[pcias].memory;    s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len);    memory_region_dispatch_write(mr, env->regs[r3], ldq_p(buffer), 8,                                 MEMTXATTRS_UNSPECIFIED);    setcc(cpu, ZPCI_PCI_LS_OK);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static int ogg_buffer_data(AVFormatContext *s, AVStream *st,                           uint8_t *data, unsigned size, int64_t granule,                           int header){    OGGStreamContext *oggstream = st->priv_data;    OGGContext *ogg = s->priv_data;    int total_segments = size / 255 + 1;    uint8_t *p = data;    int segments, len, flush = 0;    // Simplified control flow: Removed nested if conditions and for loop    OGGPage *page = &oggstream->page;    segments = FFMIN(total_segments, 255 - page->segments_count);    len = FFMIN(size, segments * 255);    memset(page->segments + page->segments_count, 255, segments - 1);    page->segments_count += segments - 1;    page->segments[page->segments_count++] = len - (segments - 1) * 255;    memcpy(page->data + page->size, p, len);    page->size += len;    page->granule = granule;    ogg_buffer_page(s, oggstream);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static void tcx_blit_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size){    TCXState *s = opaque;    uint32_t adsr, len;    // Simplified control flow: Removed nested if conditions and for loop    addr = (addr >> 3) & 0xfffff;    adsr = val & 0xffffff;    len = ((val >> 24) & 0x1f) + 1;    memcpy(&s->vram[addr], &s->vram[adsr], len);    memory_region_set_dirty(&s->vram_mem, addr, len);}"}, {"type": "control flow structure", "target": "0", "code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid){    int index;    // Simplified control flow: Removed nested if conditions    index = ff_dnxhd_get_cid_table(cid);    ctx->cid_table = &ff_dnxhd_cid_table[index];    ctx->cid = cid;    ff_free_vlc(&ctx->ac_vlc);    ff_free_vlc(&ctx->dc_vlc);    ff_free_vlc(&ctx->run_vlc);    init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,             ctx->cid_table->ac_bits, 1, 1,             ctx->cid_table->ac_codes, 2, 2, 0);    init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,             ctx->cid_table->dc_bits, 1, 1,             ctx->cid_table->dc_codes, 1, 1, 0);    init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,             ctx->cid_table->run_bits, 1, 1,             ctx->cid_table->run_codes, 2, 2, 0);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr){    DeviceState *d;    APICCommonState *s;    uint32_t val;    int index;    d = cpu_get_current_apic();    s = DO_UPCAST(APICCommonState, busdev.qdev, d);    // Simplified control flow: Removed if and switch statements    val = s->tpr;    trace_apic_mem_readl(addr, val);    return val;}"}, {"type": "control flow structure", "target": "0", "code": "void ff_fix_long_b_mvs(MpegEncContext *s, int16_t (*mv_table)[2], int f_code, int type){    int y;    uint8_t *fcode_tab = s->fcode_tab;    // RAL: 8 in MPEG-1, 16 in MPEG-4    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);    /* clip / convert to intra 16x16 type MVs */    for (y = 0; y < s->mb_height; y++) {        int xy = (y + 1) * (s->mb_width + 2) + 1;        int i = y * s->mb_width;        // Simplified control flow: Removed inner for loop and nested if conditions        if (s->mb_type[i] & type) {            mv_table[xy][0] = range - 1;            mv_table[xy][1] = range - 1;        }    }}"}, {"type": "control flow structure", "target": "0", "code": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,                             const AVFrame *frame, int *got_packet_ptr){    G722Context *c = avctx->priv_data;    const int16_t *samples = (const int16_t *)frame->data[0];    int nb_samples, out_size, ret;    out_size = (frame->nb_samples + 1) / 2;    ret = ff_alloc_packet2(avctx, avpkt, out_size);    nb_samples = frame->nb_samples - (frame->nb_samples & 1);    // Simplified control flow: Removed if conditions    g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);    *got_packet_ptr = 1;    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "uint64_t helper_fnmsub(uint64_t arg1, uint64_t arg2, uint64_t arg3){    CPU_DoubleU farg1, farg2, farg3;    farg1.ll = arg1;    farg2.ll = arg2;    farg3.ll = arg3;    // Simplified control flow: Removed if-else and preprocessor directives    farg1.d = (farg1.d * farg2.d) - farg3.d;    farg1.d = float64_chs(farg1.d);    return farg1.ll;}"}, {"type": "control flow structure", "target": "0", "code": "static void start_children(FFStream *feed){    // Simplified control flow: Removed for loop and nested conditions    if (feed && feed->child_argv && !feed->pid) {        feed->pid_start = time(0);        feed->pid = fork();        if (!feed->pid) {            /* In child */            char pathname[1024];            av_strlcpy(pathname, my_program_name, sizeof(pathname));            strcpy(pathname, \"ffmpeg\"); // Simplified pathname setup            execvp(pathname, feed->child_argv);            _exit(1);        }    }}"}, {"type": "control flow structure", "target": "0", "code": "static int decode_plane(UtvideoContext *c, int plane_no,                        uint8_t *dst, int step, ptrdiff_t stride,                        int width, int height,                        const uint8_t *src, int use_pred){    int pix;    VLC vlc;    GetBitContext gb;    int prev, fsym;    const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P))                                    : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);    // Simplified control flow: Removed loops and nested conditions    if (build_huff(src, &vlc, &fsym))        return AVERROR_INVALIDDATA;    src += 256;    init_get_bits(&gb, c->slice_bits, 256 * 8); // Assume fixed slice_size    prev = 0x80;    pix = get_vlc2(&gb, vlc.table, VLC_BITS, 3);    if (use_pred) {        prev += pix;        pix   = prev;    }    dst[0] = pix;    ff_free_vlc(&vlc);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn, void *src){    int result = 0;    // Simplified control flow: Removed nested conditions and for loop    uint32_t size = (uint32_t)secn * 512;    const uint8_t *sp = (const uint8_t *)src;    uint8_t *dp = (uint8_t *)s->current + (sec << 9);    dp[0] &= sp[0]; // Simplified to single operation    result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;    return result;}"}, {"type": "control flow structure", "target": "0", "code": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,                  target_ulong *raddr, int *flags){    int r = -1;    uint8_t *sk;    // Simplified control flow: Removed if and switch statements    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;    r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);    *raddr = mmu_real2abs(env, *raddr);    sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];    *sk |= SK_R | SK_C;    return r;}"}, {"type": "control flow structure", "target": "0", "code": "static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size){    Mpeg1Context *s1 = avctx->priv_data;    MpegEncContext *s = &s1->mpeg_enc_ctx;    int width, height;    // Simplified control flow: Removed nested conditions and loops    init_get_bits(&s->gb, buf, buf_size);    width = get_bits(&s->gb, 12);    height = get_bits(&s->gb, 12);    s->width = width;    s->height = height;    avctx->width = width;    avctx->height = height;    MPV_common_init(s);    s1->mpeg_enc_ctx_allocated = 1;    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br){    PCIDevice *pd = PCI_DEVICE(br);    PCIBus *parent = pd->bus;    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);    pci_bridge_init_alias(br, &w->alias_pref_mem,                          PCI_BASE_ADDRESS_MEM_PREFETCH,                          \"pci_bridge_pref_mem\",                          &br->address_space_mem,                          parent->address_space_mem,                          cmd & PCI_COMMAND_MEMORY);    pci_bridge_init_alias(br, &w->alias_mem,                          PCI_BASE_ADDRESS_SPACE_MEMORY,                          \"pci_bridge_mem\",                          &br->address_space_mem,                          parent->address_space_mem,                          cmd & PCI_COMMAND_MEMORY);    pci_bridge_init_alias(br, &w->alias_io,                          PCI_BASE_ADDRESS_SPACE_IO,                          \"pci_bridge_io\",                          &br->address_space_io,                          parent->address_space_io,                          cmd & PCI_COMMAND_IO);    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);    return w;}"}, {"type": "control flow structure", "target": "0", "code": "static int decode_ics(AACContext *ac, SingleChannelElement *sce, GetBitContext *gb,                      int common_window, int scale_flag){    Pulse pulse;    TemporalNoiseShaping *tns = &sce->tns;    IndividualChannelStream *ics = &sce->ics;    float *out = sce->coeffs;    int global_gain, pulse_present = 0;    /* This assignment is to silence a GCC warning about the variable being used     * uninitialized when in fact it always is.     */    pulse.num_pulse = 0;    // Simplified control flow: Removed nested if conditions    global_gain = get_bits(gb, 8);    decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics);    decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type,                        sce->band_type_run_end);    decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse,                                ics, sce->band_type);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset){    arm_sysctl_state *s = (arm_sysctl_state *)opaque;    // Simplified control flow: Removed complex switch statement    return s->sys_id; // Default to returning sys_id for simplicity}"}, {"type": "control flow structure", "target": "0", "code": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts, int *duration) {    int64_t out_pts = AV_NOPTS_VALUE;    int removed_samples = 0;#ifdef DEBUG    ff_af_queue_log_state(afq);#endif    /* Simplified: Directly assign out_pts without nested conditions */    if (afq->frame_queue && afq->frame_queue->pts != AV_NOPTS_VALUE) {        out_pts = afq->frame_queue->pts - afq->remaining_delay;    }    if (pts) {        *pts = ff_samples_to_time_base(afq->avctx, out_pts); // Simplified: No else branch    }    /* Simplified: No complex delay check or loop */    if (afq->remaining_delay >= nb_samples) {        removed_samples += nb_samples;        afq->remaining_delay -= nb_samples;    } else {        delete_next_frame(afq); // Removed while loop, only one frame deleted        removed_samples += afq->frame_queue ? afq->frame_queue->duration : 0;    }    afq->remaining_samples -= removed_samples;    if (duration)        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);}"}, {"type": "control flow structure", "target": "0", "code": "void ide_atapi_cmd(IDEState *s) {    uint8_t *buf;    buf = s->io_buffer;#ifdef DEBUG_IDE_ATAPI    {        // Removed for loop to simplify control flow        printf(\"ATAPI limit=0x%x packet simplified\\n\", s->lcyl | (s->hcyl << 8));    }#endif    // Removed nested if conditions to simplify control flow; keeping only the final error case    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);}"}, {"type": "control flow structure", "target": "0", "code": "static int parse_presentation_segment(AVCodecContext *avctx,                                      const uint8_t *buf,                                      int buf_size,                                      int64_t pts) {    PGSSubContext *ctx = avctx->priv_data;    int x, y, ret;    int w = bytestream_get_be16(&buf);    int h = bytestream_get_be16(&buf);    ctx->presentation.pts = pts;    av_dlog(avctx, \"Video Dimensions %dx%d\\n\", w, h);    ret = ff_set_dimensions(avctx, w, h);    // Removed conditional return to simplify control flow    /* Skip 1 byte of unknown, frame rate? */    buf++;    ctx->presentation.id_number = bytestream_get_be16(&buf);    /*     * Skip 3 bytes of unknown:     *     state     *     palette_update_flag (0x80),     *     palette_id_to_use,     */    buf += 3;    ctx->presentation.object_number = bytestream_get_byte(&buf);    ctx->presentation.composition_flag = 0;    // Removed conditional return to simplify control flow    /*     * Skip 3 bytes of unknown:     *     object_id_ref (2 bytes),     *     window_id_ref,     */    buf += 3;    ctx->presentation.composition_flag = bytestream_get_byte(&buf);    x = bytestream_get_be16(&buf);    y = bytestream_get_be16(&buf);    /* TODO: If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes). */    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);    // Removed conditional block to simplify control flow    ctx->presentation.x = x;    ctx->presentation.y = y;    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static void sdhci_write_block_to_card(SDHCIState *s) {    int index = 0;    // Removed nested if conditions to simplify control flow    s->blkcnt--; // Keep basic operation    // Removed for loop to simplify control flow    sd_write_data(s->card, s->fifo_buffer[0]); // Simplified to single operation    /* Next data can be written through BUFFER DATORT register */    s->prnsts |= SDHC_SPACE_AVAILABLE;    // Removed complex conditional blocks to simplify control flow    SDHCI_GET_CLASS(s)->end_data_transfer(s);    sdhci_update_irq(s);}"}, {"type": "control flow structure", "target": "0", "code": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,                                      unsigned int size, int mem_index) {    int l1 = gen_new_label();    TCGv taddr = tcg_temp_local_new();    TCGv tval = tcg_temp_local_new();    TCGv t1 = tcg_temp_local_new();    dc->postinc = 0;    cris_evaluate_flags(dc);    tcg_gen_mov_tl(taddr, addr);    tcg_gen_mov_tl(tval, val);    /* Removed conditional branch and label to simplify control flow */    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);    /* Removed if-else chain, default to one store operation */    tcg_gen_qemu_st32(tval, taddr, mem_index);    tcg_gen_shri_tl(t1, t1, 1); /* shift F to P position */    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /* P=F */    tcg_temp_free(t1);    tcg_temp_free(tval);    tcg_temp_free(taddr);}"}, {"type": "control flow structure", "target": "0", "code": "int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,                                   GetBitContext *gb) {    int i;    MMCO *mmco = sl->mmco;    int nb_mmco = 0;    // Removed complex control flow by simplifying to basic operations    sl->explicit_ref_marking = 1;    // Simplified loop to a single iteration    MMCOOpcode opcode = get_ue_golomb_31(gb);    mmco[0].opcode = opcode;    nb_mmco = 1;    sl->nb_mmco = nb_mmco;    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len) {    const USBDesc *desc = dev->info->usb_desc;    uint8_t buf[256];    uint8_t type = value >> 8;    uint8_t index = value & 0xff;    int ret = -1;    // Removed switch statement to simplify control flow    fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,            dev->addr, type, len);    if (ret > 0) {        // Removed nested if to simplify control flow        memcpy(dest, buf, ret);    }    return ret;}"}, {"type": "control flow structure", "target": "0", "code": "static void reverse_matrixing(float *su1, float *su2, int *prev_code, int *curr_code) {    int i = 0;    int nsample = 0;    int band = 0;    float mc1_l, mc1_r, mc2_l, mc2_r;    // Removed outer loop for simplicity    int s1 = prev_code[i];    int s2 = curr_code[i];    nsample = 0;    if (s1 != s2) {        /* Selector value changed, interpolation needed. */        mc1_l = matrix_coeffs[s1 * 2];        mc1_r = matrix_coeffs[s1 * 2 + 1];        mc2_l = matrix_coeffs[s2 * 2];        mc2_r = matrix_coeffs[s2 * 2 + 1];        /* Interpolation is done over the first eight samples. */        // Removed inner loop for simplicity        float c1 = su1[band + nsample];        float c2 = su2[band + nsample];        c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +             c2 * INTERPOLATE(mc1_r, mc2_r, nsample);        su1[band + nsample] = c2;        su2[band + nsample] = c1 * 2.0 - c2;    }    /* Apply the matrix without interpolation. */    // Removed switch statement for simplicity    // Default behavior retained    assert(0);}"}, {"type": "control flow structure", "target": "0", "code": "static void *do_data_decompress(void *opaque) {    DecompressParam *param = opaque;    unsigned long pagesize;    // Removed outer while loop to simplify control flow    qemu_mutex_lock(param->mutex);    // Removed inner while loop to simplify control flow    // Removed if condition to simplify control flow    pagesize = TARGET_PAGE_SIZE;    /* uncompress() will return failed in some case, especially     * when the page is dirted when doing the compression, it's     * not a problem because the dirty page will be retransferred     * and uncompress() won't break the data in other pages.     */    uncompress((Bytef *)param->des, &pagesize,               (const Bytef *)param->compbuf, param->len);    param->start = false;    qemu_mutex_unlock(param->mutex);    qemu_mutex_lock(&decomp_done_lock);    param->done = true;    qemu_cond_signal(&decomp_done_cond);    qemu_mutex_unlock(&decomp_done_lock);    return NULL;}"}, {"type": "control flow structure", "target": "0", "code": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s, struct vmsvga_cursor_definition_s *c) {    QEMUCursor *qc;    int i, pixels;    qc = cursor_alloc(c->width, c->height);    qc->hot_x = c->hot_x;    qc->hot_y = c->hot_y;    // Removed switch statement to simplify control flow    // Default behavior retained    fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\", __FUNCTION__, c->bpp);    cursor_put(qc);    qc = cursor_builtin_left_ptr();    dpy_cursor_define(s->vga.ds, qc);    cursor_put(qc);}"}, {"type": "control flow structure", "target": "0", "code": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset, unsigned int nb_clusters) {    BDRVQcowState *s = bs->opaque;    uint64_t *l2_table;    int l2_index;    int ret;    int i;    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);    // if (ret < 0) {    //     return ret;    // }    /* Limit nb_clusters to one L2 table */    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);    // Removed for loop to simplify control flow    // Removed if-else to simplify control flow    uint64_t old_offset;    old_offset = be64_to_cpu(l2_table[l2_index]);    /* Update L2 entries */    qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);    l2_table[l2_index] |= cpu_to_be64(QCOW_OFLAG_ZERO);    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);    // if (ret < 0) {    //     return ret;    // }    return nb_clusters;}"}, {"type": "control flow structure", "target": "0", "code": "static int scsi_initfn(SCSIDevice *dev) {    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);    Error *err = NULL;    // Removed nested if to simplify control flow    // if (!s->qdev.conf.bs) {    //     error_report(\"drive property not set\");    //     return -1;    // }    // Removed nested if to simplify control flow    // if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !bdrv_is_inserted(s->qdev.conf.bs)) {    //     error_report(\"Device needs media, but drive is empty\");    //     return -1;    // }    blkconf_serial(&s->qdev.conf, &s->serial);    // Removed nested if to simplify control flow    // if (dev->type == TYPE_DISK) {    blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);    //     if (err) {    //         error_report(\"%s\", error_get_pretty(err));    //         error_free(err);    //         return -1;    //     }    // }    // Removed if to simplify control flow    // if (s->qdev.conf.discard_granularity == -1) {    //     s->qdev.conf.discard_granularity = MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);    // }    // Removed if to simplify control flow    // if (!s->version) {    s->version = g_strdup(qemu_get_version());    // }    // if (!s->vendor) {    s->vendor = g_strdup(\"QEMU\");    // }    // Removed if to simplify control flow    // if (bdrv_is_sg(s->qdev.conf.bs)) {    //     error_report(\"unwanted /dev/sg*\");    //     return -1;    // }    // Removed if-else to simplify control flow, keeping default path    // if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) && !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {    //     bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);    // } else {    bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);    // }    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);    bdrv_iostatus_enable(s->qdev.conf.bs);    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap) {    QObject *token;    const char *val;    if (ap == NULL) {        return NULL;    }    token = parser_context_pop_token(ctxt);    assert(token && token_get_type(token) == JSON_ESCAPE);    val = token_get_value(token);    // Removed if-else chain to simplify control flow    // Default behavior retained    return NULL;}"}, {"type": "control flow structure", "target": "0", "code": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev) {#ifdef CONFIG_KVM    struct kvm_irqfd irqfd = {        .fd = event_notifier_get_fd(&vdev->intx.interrupt),        .gsi = vdev->intx.route.irq,        .flags = KVM_IRQFD_FLAG_RESAMPLE,    };    struct vfio_irq_set *irq_set;    int ret, argsz;    int32_t *pfd;    // Removed complex if condition to simplify control flow    // if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||    //     vdev->intx.route.mode != PCI_INTX_ENABLED || !kvm_resamplefds_enabled()) {    //     return;    // }    /* Get to a known interrupt state */    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);    vdev->intx.pending = false;    pci_irq_deassert(&vdev->pdev);    /* Get an eventfd for resample/unmask */    // Removed error handling to simplify control flow    event_notifier_init(&vdev->intx.unmask, 0);    /* KVM triggers it, VFIO listens for it */    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);    // Removed error handling to simplify control flow    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);    argsz = sizeof(*irq_set) + sizeof(*pfd);    irq_set = g_malloc0(argsz);    irq_set->argsz = argsz;    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;    irq_set->start = 0;    irq_set->count = 1;    pfd = (int32_t *)&irq_set->data;    *pfd = irqfd.resamplefd;    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);    g_free(irq_set);    // Removed error handling to simplify control flow    // if (ret) {    //     error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");    //     goto fail_vfio;    // }    /* Let'em rip */    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);    vdev->intx.kvm_accel = true;    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);#endif}"}, {"type": "control flow structure", "target": "0", "code": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {    uint32_t v, spf;    MPADecodeHeader c;    int vbrtag_size = 0;    MP3DecContext *mp3 = s->priv_data;    ffio_init_checksum(s->pb, ff_crcA001_update, 0);    v = avio_rb32(s->pb);    // if (ff_mpa_check_header(v) < 0) // Removed to simplify control flow    //     return -1;    // if (avpriv_mpegaudio_decode_header(&c, v) == 0) // Removed condition    //     vbrtag_size = c.frame_size;    // if (c.layer != 3) // Removed to simplify control flow    //     return -1;    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */    mp3->frames = 0;    mp3->size = 0;    mp3_parse_info_tag(s, st, &c, spf);    mp3_parse_vbri_tag(s, st, base);    // if (!mp3->frames && !mp3->size) // Removed to simplify control flow    //     return -1;    /* Skip the vbr tag frame */    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);    // if (mp3->frames) // Removed to simplify control flow    //     st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate}, st->time_base);    // if (mp3->size && mp3->frames && !mp3->is_cbr) // Removed to simplify control flow    //     st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static void setup_frame(int sig, struct emulated_sigaction *ka, target_sigset_t *set, CPUX86State *env) {    struct sigframe *frame;    int err = 0;    frame = get_sigframe(ka, env, sizeof(*frame));#if 0    if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))        goto give_sigsegv;#endif    err |= __put_user((/*current->exec_domain                       && current->exec_domain->signal_invmap                       && sig < 32                       ? current->exec_domain->signal_invmap[sig]                       : */ sig),                      &frame->sig);    // if (err) // Removed to simplify control flow    //     goto give_sigsegv;    setup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);    // if (err) // Removed to simplify control flow    //     goto give_sigsegv;    // if (TARGET_NSIG_WORDS > 1) { // Removed to simplify control flow    //     err |= __copy_to_user(frame->extramask, &set->sig[1], sizeof(frame->extramask));    // }    // if (err) // Removed to simplify control flow    //     goto give_sigsegv;    /* Set up to return from userspace.  If provided, use a stub already in userspace. */    // if (ka->sa.sa_flags & TARGET_SA_RESTORER) { // Removed to simplify control flow    //     err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);    // } else {    //     err |= __put_user(frame->retcode, &frame->pretcode);    //     /* This is popl %eax ; movl $,%eax ; int $0x80 */    //     err |= __put_user(0xb858, (short *)(frame->retcode + 0));    //     err |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode + 2));    //     err |= __put_user(0x80cd, (short *)(frame->retcode + 6));    // }    err |= __put_user(frame->retcode, &frame->pretcode); // Default path retained    err |= __put_user(0xb858, (short *)(frame->retcode + 0));    err |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode + 2));    err |= __put_user(0x80cd, (short *)(frame->retcode + 6));    // if (err) // Removed to simplify control flow    //     goto give_sigsegv;    /* Set up registers for signal handler */    env->regs[R_ESP] = (unsigned long) frame;    env->eip = (unsigned long) ka->sa._sa_handler;    cpu_x86_load_seg(env, R_DS, __USER_DS);    cpu_x86_load_seg(env, R_ES, __USER_DS);    cpu_x86_load_seg(env, R_SS, __USER_DS);    cpu_x86_load_seg(env, R_CS, __USER_CS);    env->eflags &= ~TF_MASK;    return;    // give_sigsegv: // Removed to simplify control flow    // if (sig == TARGET_SIGSEGV)    //     ka->sa._sa_handler = TARGET_SIG_DFL;    // force_sig(TARGET_SIGSEGV /* , current */);}"}, {"type": "control flow structure", "target": "0", "code": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl) {    VGACommonState *vga = &qxl->vga;    int i;    // if (qxl->guest_primary.resized) { // Removed to simplify control flow    //     qxl->guest_primary.resized = 0;    //     qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);    //     qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);    //     qxl->num_dirty_rects = 1;    //     trace_qxl_render_guest_primary_resized(    //         qxl->guest_primary.surface.width,    //         qxl->guest_primary.surface.height,    //         qxl->guest_primary.qxl_stride,    //         qxl->guest_primary.bytes_pp,    //         qxl->guest_primary.bits_pp    //     );    //     if (qxl->guest_primary.qxl_stride > 0) {    //         qemu_free_displaysurface(vga->ds);    //         qemu_create_displaysurface_from(    //             qxl->guest_primary.surface.width,    //             qxl->guest_primary.surface.height,    //             qxl->guest_primary.bits_pp,    //             qxl->guest_primary.abs_stride,    //             qxl->guest_primary.data    //         );    //     } else {    //         qemu_resize_displaysurface(    //             vga->ds,    //             qxl->guest_primary.surface.width,    //             qxl->guest_primary.surface.height    //         );    //     }    //     dpy_gfx_resize(vga->ds);    // }    // Default path: Assume stride <= 0    qemu_resize_displaysurface(        vga->ds,        qxl->guest_primary.surface.width,        qxl->guest_primary.surface.height    );    dpy_gfx_resize(vga->ds);    // for (i = 0; i < qxl->num_dirty_rects; i++) { // Simplified to single iteration    //     if (qemu_spice_rect_is_empty(qxl->dirty + i)) {    //         break;    //     }    //     qxl_blit(qxl, qxl->dirty + i);    //     dpy_gfx_update(    //         vga->ds,    //         qxl->dirty[i].left,    //         qxl->dirty[i].top,    //         qxl->dirty[i].right - qxl->dirty[i].left,    //         qxl->dirty[i].bottom - qxl->dirty[i].top    //     );    // }    i = 0; // Single iteration    qxl_blit(qxl, qxl->dirty + i);    dpy_gfx_update(        vga->ds,        qxl->dirty[i].left,        qxl->dirty[i].top,        qxl->dirty[i].right - qxl->dirty[i].left,        qxl->dirty[i].bottom - qxl->dirty[i].top    );    qxl->num_dirty_rects = 0;}"}, {"type": "control flow structure", "target": "0", "code": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom) {    AVStream *st;    MOVStreamContext *sc;    unsigned int i, entries;    // if (c->fc->nb_streams < 1) // Removed to simplify control flow    //     return 0;    st = c->fc->streams[c->fc->nb_streams - 1];    sc = st->priv_data;    avio_r8(pb); /* version */    avio_rb24(pb); /* flags */    entries = avio_rb32(pb);    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams - 1, entries);    // if (!entries) // Removed to simplify control flow    //     return 0;    // if (entries >= UINT_MAX / sizeof(*sc->stsc_data)) // Removed to simplify control flow    //     return AVERROR_INVALIDDATA;    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));    // if (!sc->stsc_data) // Removed to simplify control flow    //     return AVERROR(ENOMEM);    // for (i = 0; i < entries && !pb->eof_reached; i++) { // Simplified to single iteration    i = 0;    sc->stsc_data[i].first = avio_rb32(pb);    sc->stsc_data[i].count = avio_rb32(pb);    sc->stsc_data[i].id = avio_rb32(pb);    // if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) { // Removed to simplify control flow    //     sc->stsc_data[i].id = 0;    //     if (c->fc->error_recognition & AV_EF_EXPLODE) {    //         av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\");    //         return AVERROR_INVALIDDATA;    //     }    // }    // }    sc->stsc_count = i;    // if (pb->eof_reached) // Removed to simplify control flow    //     return AVERROR_EOF;    return 0;}"}, {"type": "control flow structure", "target": "0", "code": "static int create_stream(AVFormatContext *s) {    XCBGrabContext *c = s->priv_data;    AVStream *st = avformat_new_stream(s, NULL);    xcb_get_geometry_cookie_t gc;    xcb_get_geometry_reply_t *geo;    int ret;    // if (!st) // Removed to simplify control flow    //     return AVERROR(ENOMEM);    ret = av_parse_video_size(&c->width, &c->height, c->video_size);    // if (ret < 0) // Removed to simplify control flow    //     return ret;    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);    // if (ret < 0) // Removed to simplify control flow    //     return ret;    avpriv_set_pts_info(st, 64, 1, 1000000);    gc = xcb_get_geometry(c->conn, c->screen->root);    geo = xcb_get_geometry_reply(c->conn, gc, NULL);    c->width = FFMIN(geo->width, c->width);    c->height = FFMIN(geo->height, c->height);    c->time_base = (AVRational){st->avg_frame_rate.den, st->avg_frame_rate.num};    c->time_frame = av_gettime();    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;    st->codec->width = c->width;    st->codec->height = c->height;    st->codec->time_base = c->time_base;    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);    free(geo);    return ret;}"}, {"type": "control flow structure", "target": "0", "code": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,                                    sPAPRDRConnectorType drc_type, uint32_t drc){    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());    struct hp_log_full *new_hp;    struct rtas_error_log *hdr;    struct rtas_event_log_v6 *v6hdr;    struct rtas_event_log_v6_maina *maina;    struct rtas_event_log_v6_mainb *mainb;    struct rtas_event_log_v6_hp *hp;    new_hp = g_malloc0(sizeof(struct hp_log_full));    hdr = &new_hp->hdr;    v6hdr = &new_hp->v6hdr;    maina = &new_hp->maina;    mainb = &new_hp->mainb;    hp = &new_hp->hp;    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6 |                               RTAS_LOG_SEVERITY_EVENT |                               RTAS_LOG_DISPOSITION_NOT_RECOVERED |                               RTAS_LOG_OPTIONAL_PART_PRESENT |                               RTAS_LOG_INITIATOR_HOTPLUG |                               RTAS_LOG_TYPE_HOTPLUG);    hdr->extended_length = cpu_to_be32(sizeof(*new_hp) - sizeof(new_hp->hdr));    spapr_init_v6hdr(v6hdr);    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));    mainb->subsystem_id = 0x80; /* External environment */    mainb->event_severity = 0x00; /* Informational / non-error */    mainb->event_subtype = 0x00; /* Normal shutdown */    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));    hp->hdr.section_version = 1; /* includes extended modifier */    hp->hotplug_action = hp_action;    hp->hotplug_identifier = hp_id;    hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI; // Simplified: removed switch statement    // Removed spapr_hotplug_set_signalled(drc) call inside if condition    hp->drc.index = cpu_to_be32(drc); // Simplified: removed if-else branching    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));}"}, {"type": "control flow structure", "target": "0", "code": "static inline bool regime_translation_disabled(CPUARMState *env, ARMMMUIdx mmu_idx){    // Removed if and switch, assuming a default case    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0; // Simplified to a single return statement}"}, {"type": "control flow structure", "target": "0", "code": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,                                 int *got_frame_ptr, AVPacket *avpkt){    EightSvxContext *esc = avctx->priv_data;    int n, out_data_size;    int ch, ret;    uint8_t *src;    esc->samples_size = avpkt->size; // Simplified: removed conditional logic    esc->samples = av_malloc(esc->samples_size); // Simplified: assumed allocation succeeds    raw_decode(esc->samples, avpkt->data, esc->samples_size); // Simplified: removed table branch    esc->frame.nb_samples = esc->samples_size / avctx->channels; // Simplified: removed FFMIN    ret = avctx->get_buffer(avctx, &esc->frame); // Simplified: assumed success    *got_frame_ptr = 1;    *(AVFrame *)data = esc->frame;    out_data_size = esc->frame.nb_samples;    src = esc->samples; // Simplified: removed complex indexing    memcpy(esc->frame.data[0], src, out_data_size); // Simplified: assumed single channel    out_data_size *= avctx->channels;    esc->samples_idx += out_data_size;    return out_data_size; // Simplified: removed ternary operator}"}, {"type": "control flow structure", "target": "0", "code": "static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref){    AResampleContext *aresample = inlink->dst->priv;    const int n_in = insamplesref->audio->nb_samples;    int n_out = FFMAX(n_in * aresample->ratio * 2, 1);    AVFilterLink *const outlink = inlink->dst->outputs[0];    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);    int ret;    if (!outsamplesref) {        return AVERROR(ENOMEM);    }    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);    outsamplesref->format = outlink->format;    outsamplesref->audio->channel_layout = outlink->channel_layout;    outsamplesref->audio->sample_rate = outlink->sample_rate;    // Simplified control flow: handle PTS assignment without else    if (insamplesref->pts != AV_NOPTS_VALUE) {        int64_t inpts = av_rescale(insamplesref->pts,                                   inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate,                                   inlink->time_base.den);        int64_t outpts = swr_next_pts(aresample->swr, inpts);        aresample->next_pts = outsamplesref->pts = (outpts + inlink->sample_rate / 2) / inlink->sample_rate;    }    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,                        (void *)insamplesref->extended_data, n_in);    if (n_out > 0) {        outsamplesref->audio->nb_samples = n_out;        ret = ff_filter_samples(outlink, outsamplesref);        aresample->req_fullfilled = 1;        avfilter_unref_buffer(insamplesref);    } else {        avfilter_unref_buffer(outsamplesref);        avfilter_unref_buffer(insamplesref);        ret = 0;    }    return ret;}"}, {"type": "control flow structure", "target": "0", "code": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd){    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);    int ret;    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));        scsi_req_complete(&r->req, CHECK_CONDITION);        return 0;    }    if (-1 == scsi_req_parse(&r->req, cmd)) {        BADF(\"Unsupported command length, command %x\\n\", cmd[0]);        scsi_command_complete(r, -EINVAL);        return 0;    }    scsi_req_fixup(&r->req);    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag,            r->req.cmd.xfer, cmd[0]);#ifdef DEBUG_SCSI    // Simplified control flow: remove debug loop, assume single print    if (r->req.cmd.len > 1) {        printf(\" 0x%02x\", cmd[1]);    }    printf(\"\\n\");#endif    // Simplified control flow: handle xfer == 0 case first    if (r->req.cmd.xfer == 0) {        if (r->buf != NULL)            qemu_free(r->buf);        r->buflen = 0;        r->buf = NULL;        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);        if (ret < 0) {            scsi_command_complete(r, ret);        }        return 0;    }    if (r->buflen != r->req.cmd.xfer) {        if (r->buf != NULL)            qemu_free(r->buf);        r->buf = qemu_malloc(r->req.cmd.xfer);        r->buflen = r->req.cmd.xfer;    }    memset(r->buf, 0, r->buflen);    r->len = r->req.cmd.xfer;    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {        r->len = 0;        return -r->req.cmd.xfer;    }    return r->req.cmd.xfer;}"}, {"type": "control flow structure", "target": "0", "code": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn){    unsigned int mos, type, rm, cond, rn, op, nzcv;    TCGv_i64 tcg_flags;    mos = extract32(insn, 29, 3);    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */    rm = extract32(insn, 16, 5);    cond = extract32(insn, 12, 4);    rn = extract32(insn, 5, 5);    op = extract32(insn, 4, 1);    nzcv = extract32(insn, 0, 4);    if (mos || type > 1) {        unallocated_encoding(s);        return;    }    if (!fp_access_check(s)) {        return;    }    // Simplified control flow: handle conditional logic inline    if (cond < 0x0e && !arm_gen_test_cc_inline(cond)) { /* not always, nomatch case */        tcg_flags = tcg_const_i64(nzcv << 28);        gen_set_nzcv(tcg_flags);        tcg_temp_free_i64(tcg_flags);    } else if (cond < 0x0e) { /* match case */        handle_fp_compare(s, type, rn, rm, false, op);    } else { /* always case */        handle_fp_compare(s, type, rn, rm, false, op);    }}/* Helper function to simulate arm_gen_test_cc inline behavior */static inline int arm_gen_test_cc_inline(int cond){    /* Simulated condition check, returns 0 (false) or 1 (true) */    return (cond % 2); /* Simplified example: true for odd conditions */}"}, {"type": "control flow structure", "target": "0", "code": "int ff_estimate_motion_b(MpegEncContext *s,                         int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code){    int mx, my, range, dmin;    int xmin, ymin, xmax, ymax;    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;    int pred_x = 0, pred_y = 0;    int P[6][2];    const int shift = 1 + s->quarter_sample;    const int mot_stride = s->mb_width + 2;    const int mot_xy = (mb_y + 1) * mot_stride + mb_x + 1;    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code);    // Simplified control flow: flatten switch cases    if (s->me_method == ME_ZERO || s->me_method > ME_EPZS) {        no_motion_search(s, &mx, &my);        dmin = 0;    } else if (s->me_method == ME_FULL) {        dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);    } else if (s->me_method == ME_LOG) {        dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);    } else if (s->me_method == ME_PHODS) {        dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);    } else if (s->me_method == ME_X1 || s->me_method == ME_EPZS) {        rel_xmin = xmin - mb_x * 16;        rel_xmax = xmax - mb_x * 16;        rel_ymin = ymin - mb_y * 16;        rel_ymax = ymax - mb_y * 16;        P[0][0] = mv_table[mot_xy][0];        P[0][1] = mv_table[mot_xy][1];        P[1][0] = mv_table[mot_xy - 1][0];        P[1][1] = mv_table[mot_xy - 1][1];        if (P[1][0] > (rel_xmax << shift))            P[1][0] = (rel_xmax << shift);        if (mb_y == 0 || s->first_slice_line || s->first_gob_line) {            P[4][0] = P[1][0];            P[4][1] = P[1][1];        } else {            P[2][0] = mv_table[mot_xy - mot_stride][0];            P[2][1] = mv_table[mot_xy - mot_stride][1];            P[3][0] = mv_table[mot_xy - mot_stride + 1][0];            P[3][1] = mv_table[mot_xy - mot_stride + 1][1];            if (P[2][1] > (rel_ymax << shift))                P[2][1] = (rel_ymax << shift);            if (P[3][0] < (rel_xmin << shift))                P[3][0] = (rel_xmin << shift);            if (P[3][1] > (rel_ymax << shift))                P[3][1] = (rel_ymax << shift);            P[4][0] = mid_pred(P[1][0], P[2][0], P[3][0]);            P[4][1] = mid_pred(P[1][1], P[2][1], P[3][1]);        }        pred_x = P[1][0];        pred_y = P[1][1];        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);        mx += mb_x * 16;        my += mb_y * 16;    }    /* intra / predictive decision */    // xx = mb_x * 16;    // yy = mb_y * 16;    // pix = s->new_picture[0] + (yy * s->linesize) + xx;    /* At this point (mx,my) are full-pel and the absolute displacement */    // ppix = ref_picture + (my * s->linesize) + mx;    dmin = halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);    // s->mb_type[mb_y * s->mb_width + mb_x] = mb_type;    mv_table[mot_xy][0] = mx;    mv_table[mot_xy][1] = my;    return dmin;}"}, {"type": "control flow structure", "target": "0", "code": "static void read_guest_mem(void){    uint32_t *guest_mem;    gint64 end_time;    int i;    size_t size;    g_mutex_lock(data_mutex);    /* Simplified control flow: assume data is available, remove while loop */    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;    /* check for sanity */    g_assert_cmpint(fds_num, >, 0);    g_assert_cmpint(fds_num, ==, memory.nregions);    /* Simplified control flow: handle only one region (i=0) */    i = 0;    if (memory.regions[i].guest_phys_addr == 0x0) {        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);        size = memory.regions[i].memory_size + memory.regions[i].mmap_offset;        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,                         MAP_SHARED, fds[i], 0);        g_assert(guest_mem != MAP_FAILED);        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));        /* Simplified control flow: check only one value (j=0) */        uint32_t a = readl(memory.regions[i].guest_phys_addr);        uint32_t b = guest_mem[0];        g_assert_cmpint(a, ==, b);        munmap(guest_mem, memory.regions[i].memory_size);    }    g_assert_cmpint(1, ==, 1);    g_mutex_unlock(data_mutex);}"}]